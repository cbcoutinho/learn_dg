var tipuesearch = {"pages":[{"text":"learn_dg Note Watch out, none of this code works More information can be found in the user guide . Dependencies This project uses lapack/blas as the numerical backend. Linking to these\nlibraries was no problem on Linux, but on Windows you need to build lapack/blas\nfrom scratch. First download lapack/blas from Netlib Install using cmake , and then move the libblas.dll.a and liblapack.dll.a libraries into wherever mingw expects to find them: On my machine, I use the following target directory: C:\\Development\\MinGW\\lib Documentation The documentation is built using FORD , a python package that produces documentation from source code similar to Doxygen, but specifically designed for Fortran.\nFORD takes inline documentation, prefixed by !! , and the markdown files located in docs/user_guide , and wraps them all up into an attractive website, available here .\nThe documentation website is automatically updated whenever a commit is added to the master branch. This is done through Travis-CI. To build the documentation locally run make docs This will build the documentation website in the ./docs/html directory. The organization of this project was heavily influenced by FIDASIM Developer Info Chris Coutinho","tags":"","title":" learn_dg ","loc":"index.html"},{"text":"This File Depends On sourcefile~~assembly_mod.f90~~EfferentGraph sourcefile~assembly_mod.f90 assembly_mod.f90 sourcefile~legendre_mod.f90 legendre_mod.f90 sourcefile~legendre_mod.f90->sourcefile~assembly_mod.f90 sourcefile~integration_mod.f90 integration_mod.f90 sourcefile~integration_mod.f90->sourcefile~legendre_mod.f90 sourcefile~linalg_mod.f90 linalg_mod.f90 sourcefile~linalg_mod.f90->sourcefile~legendre_mod.f90 sourcefile~misc_mod.f90 misc_mod.f90 sourcefile~misc_mod.f90->sourcefile~legendre_mod.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files Dependent On This One sourcefile~~assembly_mod.f90~~AfferentGraph sourcefile~assembly_mod.f90 assembly_mod.f90 sourcefile~main.f90 main.f90 sourcefile~assembly_mod.f90->sourcefile~main.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Modules assembly Source Code assembly_mod.f90 Source Code ! Learn_dg - A quick and dirty project to deploy a working DG solver ! Copyright (c) 2017, Chris Coutinho ! All rights reserved. ! ! Licensed under the BSD-2 clause license. See LICENSE for details. module assembly use , intrinsic :: iso_fortran_env , only : wp => real64 use :: legendre , only : getIe , assembleElementalMatrix , getxy implicit none private public :: initialize_global_mats , assemble , set_BCs contains subroutine initialize_global_mats ( num_nodes , & GlobalA , & GlobalB , & GlobalX ) !* This routine initalizes the global stiffness matrix, global rhs vector, !  and global solution vector based on the number of nodes in the system ! ! * This is a bullet point ! * Another bullet point ! ! 1. This might be a number ! 2. Also a number? ! ! Some  \\LaTeX : !  \\frac{\\partial u}{\\partial t} = 0  integer , intent ( in ) :: num_nodes !! The number of nodes in the system real ( wp ), intent ( out ), dimension (:), allocatable :: GlobalB !! Global RHS Vector real ( wp ), intent ( out ), dimension (:), allocatable :: GlobalX !! Global solution vector real ( wp ), intent ( out ), dimension (:,:), allocatable :: GlobalA !! Global mass matrix allocate ( GlobalA ( num_nodes , num_nodes )) allocate ( GlobalB ( num_nodes )) allocate ( GlobalX ( num_nodes )) ! Intial Conditions GlobalA = 0._wp GlobalX = 0._wp GlobalB = 0._wp return end subroutine initialize_global_mats subroutine assemble ( order , xcoords , elem_conn , GlobalA , diff , vel ) !* Assemble the global stiffness matrix based on element connectivity integer , intent ( in ), dimension (:) :: order !! Order of element(s) integer , intent ( in ), dimension (:,:) :: elem_conn !! Element connectivity real ( wp ), intent ( in ) :: diff !! Diffusivity coefficient [m/s&#94;2] real ( wp ), intent ( in ) :: vel !! Velocity [m/s] real ( wp ), intent ( in ), dimension (:) :: xcoords !! Array of nodal coordinates real ( wp ), intent ( out ), dimension (:,:) :: GlobalA !! Global Stiffness matrix integer :: ii real ( wp ), dimension (:,:), allocatable :: Ie ! Add elemental stiffness matrices to Global Stiffness Matrix do ii = 1 , size ( order ) ! Reallocate elemental stiffness matrix allocate ( Ie ( order ( ii ) + 1 , order ( ii ) + 1 )) call getIe ( 1 , 1 , xcoords ( elem_conn ( ii ,:)), Ie ) ! call r8mat_print(order(ii)+1, order(ii)+1, Ie, 'Elemental Stiffness Matrix:') GlobalA ( elem_conn ( ii ,:), elem_conn ( ii ,:)) = & GlobalA ( elem_conn ( ii ,:), elem_conn ( ii ,:)) - diff * Ie call getIe ( 0 , 1 , xcoords ( elem_conn ( ii ,:)), Ie ) ! call r8mat_print(order(ii)+1, order(ii)+1, Ie, 'Elemental Stiffness Matrix:') GlobalA ( elem_conn ( ii ,:), elem_conn ( ii ,:)) = & GlobalA ( elem_conn ( ii ,:), elem_conn ( ii ,:)) - vel * Ie ! Deallocate elemental stiffness matrix after every loop deallocate ( Ie ) ! stop enddo ! call r8mat_print(num_nodes, num_nodes, GlobalA, 'Global Stiffness Matrix:') ! stop return end subroutine assemble subroutine set_BCs ( xcoords , GlobalB , GlobalA ) !*  Set boundary conditions in GlobalA and GlobalB using two Dirchlet !   boundaries real ( wp ), intent ( in ), dimension (:) :: xcoords !! Array of nodal coordinates real ( wp ), intent ( out ), dimension (:) :: GlobalB !! Global RHS Vector real ( wp ), intent ( out ), dimension (:,:) :: GlobalA !! Global Mass Matrix integer , dimension ( 1 ) :: iloc !! Index variable to locate node numbers based on xcoords ! Left Boundary Dirchlet BC iloc = minloc ( xcoords ) GlobalA ( iloc ,:) = 0._wp GlobalA ( iloc , iloc ) = 1._wp GlobalB ( iloc ) = 0._wp ! Right Boundary Dirchlet BC iloc = maxloc ( xcoords ) GlobalA ( iloc ,:) = 0._wp GlobalA ( iloc , iloc ) = 1._wp GlobalB ( iloc ) = 1._wp ! call r8mat_print(num_nodes, 1, GlobalB, 'Global RHS:') ! stop return end subroutine set_BCs end module assembly","tags":"","title":"assembly_mod.f90 – learn_dg","loc":"sourcefile/assembly_mod.f90.html"},{"text":"This File Depends On sourcefile~~doubleint.f90~~EfferentGraph sourcefile~doubleint.f90 doubleint.f90 sourcefile~legendre_mod.f90 legendre_mod.f90 sourcefile~legendre_mod.f90->sourcefile~doubleint.f90 sourcefile~linalg_mod.f90 linalg_mod.f90 sourcefile~linalg_mod.f90->sourcefile~doubleint.f90 sourcefile~linalg_mod.f90->sourcefile~legendre_mod.f90 sourcefile~misc_mod.f90 misc_mod.f90 sourcefile~misc_mod.f90->sourcefile~doubleint.f90 sourcefile~misc_mod.f90->sourcefile~legendre_mod.f90 sourcefile~integration_mod.f90 integration_mod.f90 sourcefile~integration_mod.f90->sourcefile~legendre_mod.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Programs doubleint Source Code doubleint.f90 Source Code ! Learn_dg - A quick and dirty project to deploy a working DG solver ! Copyright (c) 2017, Chris Coutinho ! All rights reserved. ! ! Licensed under the BSD-2 clause license. See LICENSE for details. program doubleint use , intrinsic :: iso_fortran_env , only : wp => real64 use :: linalg , only : linsolve_quick , eye use :: misc , only : r8mat_print use :: legendre , only : assembleElementalMatrix , getxy implicit none integer :: ii ! integer, parameter :: N = 4 integer , parameter :: N = 9 ! integer, parameter :: N = 16 real ( wp ), dimension ( N , 2 ) :: xy real ( wp ), dimension ( N , N ) :: Ie ! real(wp), dimension(10)    :: GlobalB, GlobalX ! real(wp), dimension(10,10)  :: GlobalA real ( wp ), dimension ( 15 ) :: GlobalB , GlobalX real ( wp ), dimension ( 15 , 15 ) :: GlobalA ! real(wp), dimension(16)    :: GlobalB, GlobalX ! real(wp), dimension(16,16)  :: GlobalA ! integer,  dimension(4,4)  :: elem integer , dimension ( 2 , 9 ) :: elem ! integer, dimension(1, 16) :: elem ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!! ! !!!!!! Bi-linear quads !!!!!!! ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!! ! Element connection(s) for 3 bi-linear quadrilaterals ! elem(1,:) = [1, 2, 3, 4] ! elem(2,:) = [2, 5, 6, 3] ! elem(3,:) = [5, 7, 8, 6] ! elem(4,:) = [7, 9, 10, 8] ! Get base xi/eta coordinates for bi-linear quadrilateral ! xy = getxy(N) ! Adjust for bi-linear quad ! xy(:,1) = [0._wp, 1._wp, 1.6_wp, 0._wp] ! xy(:,2) = [-1._wp, -2._wp, 5._wp, 3._wp] ! xy(:,1) = [0._wp, 0.03333_wp, 0.03333_wp, 0._wp] ! xy(:,2) = [0._wp, 0._wp, 0.03333_wp, 0.03333_wp] ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!! ! !!!!!! Bi-linear quads !!!!!!! ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!! ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! ! !!!!!! Bi-quadratic quads !!!!!!! ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! ! Element connection(s) for 2 bi-quadratic quadrilaterals elem ( 1 ,:) = [ 1 , 2 , 5 , 6 , 7 , 8 , 9 , 10 , 11 ] elem ( 2 ,:) = [ 2 , 3 , 4 , 5 , 12 , 13 , 14 , 8 , 15 ] ! Get base xi/eta coordinates for bi-quadratic quadrilateral xy = getxy ( N ) ! Adjust for bi-quadratic quad ! xy(:,1) = [0._wp, 0.03333_wp, 0.03333_wp, 0._wp, 0.016667_wp, 0.03333_wp, 0.016667_wp, 0._wp, 0.016667_wp] ! xy(:,2) = [0._wp, 0._wp, 0.03333_wp, 0.03333_wp, 0._wp, 0.016667_wp, 0.03333_wp, 0.016667_wp, 0.016667_wp] ! xy(1,:) = [-1.25_wp, -0.8_wp] ! xy(6,:) = [0.75_wp, 0.1_wp] ! xy(9,:) = [-0.25_wp, 0.25_wp] ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! ! !!!!!! Bi-quadratic quads !!!!!!! ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!! ! !!!!!! Bi-cubic quads !!!!!!! ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!! ! Element connection(s) for 2 bi-cubic quadrilaterals ! elem(1,:) = [(ii, ii=1,16)] ! Get base xi/eta coordinates for bi-cubic quadrilateral ! xy = getxy(N) ! Adjust for bi-cubic quad ! xy(:,1) = [0._wp, 0.03333_wp, 0.03333_wp, 0._wp, 0.016667_wp, 0.03333_wp, 0.016667_wp, 0._wp, 0.016667_wp] ! xy(:,2) = [0._wp, 0._wp, 0.03333_wp, 0.03333_wp, 0._wp, 0.016667_wp, 0.03333_wp, 0.016667_wp, 0.016667_wp] ! xy(1,:) = [-1.25_wp, -0.8_wp] ! xy(6,:) = [0.75_wp, 0.1_wp] ! xy(9,:) = [-0.25_wp, 0.25_wp] ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!! ! !!!!!! Bi-cubic quads !!!!!!! ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!! GlobalA = 0._wp do ii = 1 , size ( elem , 1 ) Ie = - assembleElementalMatrix ( N , 1 , 1 , xy ) - assembleElementalMatrix ( N , 2 , 2 , xy ) GlobalA ( elem ( ii ,:), elem ( ii ,:)) = GlobalA ( elem ( ii ,:), elem ( ii ,:)) + Ie enddo ! Zero-out the row corresponding with BCs and set A(ii,ii) to 1.0 forall ii ! GlobalA( [1, 4, 9, 10], : ) = 0._wp ! GlobalA( [1, 4, 9, 10], [1, 4, 9, 10] ) = eye(4) GlobalA ( [ 1 , 6 , 10 , 3 , 4 , 13 ], : ) = 0._wp GlobalA ( [ 1 , 6 , 10 , 3 , 4 , 13 ], [ 1 , 6 , 10 , 3 , 4 , 13 ] ) = eye ( 6 ) ! GlobalA( [1, 2, 7, 8, 3, 4, 11, 12], : ) = 0._wp ! GlobalA( [1, 2, 7, 8, 3, 4, 11, 12], [1, 2, 7, 8, 3, 4, 11, 12] ) = eye(8) call r8mat_print ( size ( GlobalA , 1 ), size ( GlobalA , 2 ), GlobalA , \"Global Stiffness Matrix:\" ) ! Set BCs (zero everywhere, 1 on left boundary) GlobalB = 0._wp ! GlobalB( [1, 4] ) = 1._wp GlobalB ( [ 1 , 6 , 10 ] ) = 1._wp ! GlobalB ( [1, 4, 11, 12] ) = 1._wp ! Solve linear system call linsolve_quick ( size ( GlobalA , 1 ), GlobalA , size ( GlobalB , 1 ), GlobalB , GlobalX ) call r8mat_print ( size ( GlobalX , 1 ), 1 , GlobalX , \"Solution Vector:\" ) end program doubleint","tags":"","title":"doubleint.f90 – learn_dg","loc":"sourcefile/doubleint.f90.html"},{"text":"Files Dependent On This One sourcefile~~integration_mod.f90~~AfferentGraph sourcefile~integration_mod.f90 integration_mod.f90 sourcefile~legendre_mod.f90 legendre_mod.f90 sourcefile~integration_mod.f90->sourcefile~legendre_mod.f90 sourcefile~pascal_2d_smod.f90 pascal_2D_smod.f90 sourcefile~legendre_mod.f90->sourcefile~pascal_2d_smod.f90 sourcefile~doubleint.f90 doubleint.f90 sourcefile~legendre_mod.f90->sourcefile~doubleint.f90 sourcefile~assembly_mod.f90 assembly_mod.f90 sourcefile~legendre_mod.f90->sourcefile~assembly_mod.f90 sourcefile~pascal_1d_smod.f90 pascal_1D_smod.f90 sourcefile~legendre_mod.f90->sourcefile~pascal_1d_smod.f90 sourcefile~main.f90 main.f90 sourcefile~assembly_mod.f90->sourcefile~main.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Modules integration Source Code integration_mod.f90 Source Code ! Learn_dg - A quick and dirty project to deploy a working DG solver ! Copyright (c) 2017, Chris Coutinho ! All rights reserved. ! ! Licensed under the BSD-2 clause license. See LICENSE for details. module integration use , intrinsic :: iso_fortran_env , only : wp => real64 use :: lib_array , only : linspace implicit none private public :: integrate , integrate2D interface module function fun2d_interf ( x , y ) result ( z ) real ( wp ), intent ( in ), dimension (:,:) :: x , y real ( wp ), dimension (:,:), allocatable :: z end function module subroutine sub1d_interf ( xx , yy ) real ( wp ), intent ( in ), dimension (:) :: xx real ( wp ), intent ( out ), dimension (:) :: yy end subroutine sub1d_interf end interface contains subroutine integrate ( sub , a , b , result ) ! This routine uses gauss-legendre quadrature to integrate a 1D function ! Input/Output variables real ( wp ), intent ( in ) :: a , b real ( wp ), intent ( out ) :: result procedure ( sub1d_interf ) :: sub ! Local variables integer :: N real ( wp ) :: result_old , error real ( wp ), parameter :: eps = sqrt ( epsilon ( 1.0_wp )) real ( wp ), dimension (:), allocatable :: x , w , y N = 3 result = 0.0_wp error = 1.0_wp do result_old = result allocate ( x ( N ), w ( N ), y ( N )) call gaussquad ( N , x , w ) call sub ( x , y ) result = sum ( y * w ) deallocate ( x , w , y ) ! error = norm2([result, result_old]) error = sqrt (( result - result_old ) ** 2.0_wp ) ! error = abs((result-result_old)/(result_old+eps)) ! print*, N, result, error ! print*, N, result, result_old, error, eps ! Check if error is acceptable, as well as whether the loop was gone ! through at least twice (N = 3, 4, 5...) if ( ( error < eps . or . abs ( result ) < eps ) & . and . N > 5 ) then exit else N = N + 1 endif enddo return end subroutine integrate function integrate2D ( fun ) result ( out ) procedure ( fun2d_interf ) :: fun real ( wp ) :: out integer :: ii , N real ( wp ) :: out_old , error real ( wp ), parameter :: eps = epsilon ( 0 e0 ) real ( wp ), dimension (:), allocatable :: x , w real ( wp ), dimension (:,:), allocatable :: xx , yy , wx , wy , out_spread ! Adaptive integration based on 2D Gauss-Legendre Quadrature ii = 1 ! Iteration number N = 2 ! Initial number of points to use error = 1._wp ! Initial estimate of error do ! Allocate x (positions) and w (weights) based on roots of the Legendre ! polynomial of order 'N' allocate ( x ( N ), w ( N )) allocate ( xx ( N , N ), yy ( N , N )) allocate ( wx ( N , N ), wy ( N , N )) allocate ( out_spread ( N , N )) call gaussquad ( N , x , w ) ! Copy the 'x' array along both the x and y axes xx = spread ( x , dim = 1 , ncopies = N ) yy = spread ( x , dim = 2 , ncopies = N ) ! Copy the weights along both the x and y axes as well wx = spread ( w , dim = 1 , ncopies = N ) wy = spread ( w , dim = 2 , ncopies = N ) ! Calculate the function at the xx and yy nodes, and multiply the result ! with the weights: wx and wy out_spread = fun ( xx , yy ) * wx * wy ! Sum up the resulting array into a single scalar output out = sum ( reshape ( out_spread , [ N * N , 1 ] )) ! print*, out ! Set error if ii > 1 if ( ii > 1 ) then error = out - out_old else error = 1._wp endif ! Deallocate all arrays no longer needed. They will change size in each ! iteration anyway deallocate ( x , w , xx , yy , wx , wy , out_spread ) ! If iteration counter is more than 1 then check exit criteria if ( norm2 ( [ error ] ) <= eps ) then ! print'(a,i3,a,e13.5)', 'Fun integrated in ', N, & !                        ' iterations. Error = ', error exit else out_old = out ii = ii + 1 N = N + 1 endif enddo return end function subroutine gaussquad ( N , x , w ) integer , intent ( in ) :: N real ( wp ), intent ( out ), dimension ( N ) :: x , w select case ( N ) case ( 1 ) x = [ 0._wp ] w = [ 2._wp ] case ( 2 ) x = [ - 0.5773502691896257_wp , & 0.5773502691896257_wp ] w = [ 1._wp , & 1._wp ] case ( 3 ) x = [ - 0.7745966692414834_wp , & 0._wp , & 0.7745966692414834_wp ] w = [ 0.5555555555555556_wp , & 0.8888888888888888_wp , & 0.5555555555555556_wp ] case ( 4 ) x = [ - 0.8611363115940526_wp , & - 0.3399810435848563_wp , & 0.3399810435848563_wp , & 0.8611363115940526_wp ] w = [ 0.3478548451374538_wp , & 0.6521451548625461_wp , & 0.6521451548625461_wp , & 0.3478548451374538_wp ] case ( 5 ) x = [ - 0.9061798459386640_wp , & - 0.5384693101056831_wp , & 0._wp , & 0.5384693101056831_wp , & 0.9061798459386640_wp ] w = [ 0.2369268850561891_wp , & 0.4786286704993665_wp , & 0.5688888888888889_wp , & 0.4786286704993665_wp , & 0.2369268850561891_wp ] case default ! call lgwt(-1._wp, 1._wp, N, x, w) ! call cgwt(N, x, w) call gaussquad_rosetta ( N , x , w ) end select return end subroutine gaussquad subroutine lgwt ( a , b , num_pts , x , w ) !*  This function is a fortran90 port of the matlab function, lgwt.m !   The source code of lgwt.m was originally found at: !     http://www.mathworks.com/matlabcentral/fileexchange/4540 ! Variables in/out integer , intent ( in ) :: num_pts real ( wp ), intent ( in ) :: a , b real ( wp ), intent ( out ), dimension (:) :: x , w ! Local variables integer :: ii , jj , N , N1 , N2 ! real(wp), parameter:: eps=sqrt(epsilon(1.0_wp)) real ( wp ), parameter :: eps = 1 d - 10 real ( wp ), dimension (:), allocatable :: xu , array1 , y , y0 , Lpp real ( wp ), dimension (:, :), allocatable :: L , Lp real ( wp ), parameter :: pi = 4.0_wp * datan ( 1.0_wp ) N = num_pts - 1 N1 = N + 1 N2 = N + 2 ! Allocate and initialize arrays allocate ( xu ( N1 ), array1 ( N1 ), y ( N1 ), y0 ( N1 )) allocate ( L ( N1 , N2 ), Lp ( N1 , N2 ), Lpp ( N1 )) L = 0.0_wp Lp = 0.0_wp call linspace ( - 1.0_wp , 1.0_wp , xu ) array1 = [ ( ii , ii = 0 , N ) ] ! Initial guess of the roots of the Legendre polynomial of order N y = cos (( 2.0_wp * real ( array1 , wp ) + 1.0_wp ) * & pi / ( 2.0_wp * real ( N , wp ) + 2.0_wp )) + & ( 0.27_wp / real ( N1 , wp )) * sin ( pi * xu * real ( N , wp ) / real ( N2 , wp )) y0 = 2.0_wp do L (:, 1 ) = 1.0_wp Lp (:, 1 ) = 0.0_wp L (:, 2 ) = y Lp (:, 2 ) = 1.0_wp do jj = 2 , N1 L (:, jj + 1 ) = ( ( 2.0_wp * real ( jj , wp ) - 1.0_wp ) * y * L (:, jj ) - & real ( jj - 1 , wp ) * L (:, jj - 1 )) / real ( jj , wp ) enddo Lpp = real ( N2 , wp ) * ( L (:, N1 ) - y * L (:, N2 )) / ( 1.0_wp - y ** 2.0_wp ) y0 = y y = y0 - L (:, N2 ) / Lpp if ( norm2 ( y - y0 ) < eps ) then exit endif enddo x = ( a * ( 1.0_wp - y ) + b * ( 1.0_wp + y ) ) / 2.0_wp w = ( b - a ) / (( 1.0_wp - y ** 2.0_wp ) * Lpp ** 2.0_wp ) * & ( real ( N2 , wp ) / real ( N1 , wp )) ** 2.0_wp return end subroutine lgwt subroutine cgwt ( num_pts , x , w ) ! This function  determines the points and weights associated with Chebyshev-Gauss quadrature ! Variables in/out integer , intent ( in ) :: num_pts real ( wp ), intent ( out ), dimension (:) :: x , w ! Local variables integer :: ii real ( wp ), parameter :: pi = 4._wp * datan ( 1._wp ) x = cos ( ( real ( 2 * [( ii , ii = 1 , num_pts )] - 1 , wp ) ) / real ( 2 * num_pts , wp ) * pi ) w = pi / real ( num_pts , wp ) / (( 1.0_wp - x ** 2._wp ) ** ( - 0.5_wp )) ! print*, x ! print*, w ! stop return end subroutine cgwt subroutine gaussquad_rosetta ( n , r1 , r2 ) ! This code was originally found at the following website: !  http://rosettacode.org/wiki/Numerical_integration/Gauss-Legendre_Quadrature#Fortran integer , intent ( in ) :: n real ( wp ), intent ( out ) :: r1 ( n ), r2 ( n ) integer :: k real ( wp ), parameter :: pi = 4._wp * atan ( 1._wp ) real ( wp ) :: x , f , df , dx integer :: i , iter real ( wp ), allocatable :: p0 (:), p1 (:), tmp (:) p0 = [ 1._wp ] p1 = [ 1._wp , 0._wp ] do k = 2 , n tmp = (( 2 * k - 1 ) * [ p1 , 0._wp ] - ( k - 1 ) * [ 0._wp , 0._wp , p0 ]) / k p0 = p1 ; p1 = tmp enddo do i = 1 , n x = cos ( pi * ( i - 0.25_wp ) / ( n + 0.5_wp )) do iter = 1 , 10 f = p1 ( 1 ); df = 0._wp do k = 2 , size ( p1 ) df = f + x * df f = p1 ( k ) + x * f enddo dx = f / df x = x - dx if ( abs ( dx ) < 10 * epsilon ( dx )) exit enddo r1 ( i ) = x r2 ( i ) = 2 / (( 1 - x ** 2 ) * df ** 2 ) enddo return end subroutine gaussquad_rosetta end module integration","tags":"","title":"integration_mod.f90 – learn_dg","loc":"sourcefile/integration_mod.f90.html"},{"text":"Files Dependent On This One sourcefile~~io_mod.f90~~AfferentGraph sourcefile~io_mod.f90 io_mod.f90 sourcefile~main.f90 main.f90 sourcefile~io_mod.f90->sourcefile~main.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Modules io Source Code io_mod.f90 Source Code ! Learn_dg - A quick and dirty project to deploy a working DG solver ! Copyright (c) 2017, Chris Coutinho ! All rights reserved. ! ! Licensed under the BSD-2 clause license. See LICENSE for details. module io use , intrinsic :: iso_fortran_env , only : wp => real64 use :: lib_array , only : linspace implicit none private public :: read_gmsh_file_1D , & write_out_solution contains subroutine read_gmsh_file_1D ( num_nodes , & order , & nodes2vertex , & elem_conn , & xcoords , & dg ) ! !*  Reads the input mesh file (gmsh .msh format) and returns the number of !   nodes, the order of each element, element connectivity, and the !   coordinates of the nodes (nx1 for 1D, nx2 for 2D, etc.) integer , intent ( out ) :: num_nodes !! Number of nodes in mesh integer , intent ( out ), dimension (:), allocatable :: order !! Array containing order of each element integer , intent ( out ), dimension (:), allocatable :: nodes2vertex !! Array containing node to vertex connectivity (only interesting w.r.t discontinuous galerkin) integer , intent ( out ), dimension (:,:), allocatable :: elem_conn !! Array containing node connectivity of each element real ( wp ), intent ( out ), dimension (:), allocatable :: xcoords !! Array containing node coordinates logical , intent ( in ) :: dg !! Logical switch is continuous galerkin or discontinuous galerkin integer :: ii , ios , vertex , num_elements , num_vertexes , d_int integer , dimension (:,:), allocatable :: vertex_conn real ( wp ) :: d_real character ( 80 ) :: filename character ( 80 ) :: blank_string call get_command_argument ( 1 , filename ) ! print*, filename open ( unit = 21 , file = filename , iostat = ios , status = \"old\" , action = \"read\" ) if ( ios /= 0 ) then print * , filename print * , ios stop \"Error opening file \" endif ! Read initial header information - assuming file is in the correct format do read ( 21 , * ) blank_string if ( trim ( blank_string ) == '$Nodes' ) exit enddo ! Read number of nodes read ( 21 , * ) num_vertexes allocate ( xcoords ( num_vertexes )) if ( . not . dg ) then num_nodes = num_vertexes else num_nodes = 2 * num_vertexes - 2 endif ! Read coordinate information for each vertex do ii = 1 , num_vertexes read ( 21 , * ) d_int , xcoords ( ii ), d_real , d_real enddo allocate ( nodes2vertex ( num_nodes )) nodes2vertex = 0 if ( dg ) then vertex = 1 do ii = 1 , num_nodes nodes2vertex ( ii ) = vertex if ( ii == 1 . or . ii == num_nodes ) then vertex = vertex + 1 elseif ( mod ( ii , 2 ) == 0 ) then vertex = vertex + 1 endif enddo else nodes2vertex = [( ii , ii = 1 , num_nodes )] endif do ii = 1 , num_nodes print * , ii , nodes2vertex ( ii ), xcoords ( nodes2vertex ( ii )) enddo print * , ! stop ! Two dummy lines : !   $EndNodes !   $Elements read ( 21 , * ) read ( 21 , * ) read ( 21 , * ) num_elements num_elements = num_elements - 2 allocate ( order ( num_elements )) allocate ( elem_conn ( num_elements , 2 )) allocate ( vertex_conn ( num_elements , 2 )) ! Initialize all elements as first order linear elements order = 1 ! Two dummy lines - Associated with 'point' elements read ( 21 , * ) read ( 21 , * ) do ii = 1 , num_elements read ( 21 , * ) d_int , d_int , d_int , d_int , d_int , vertex_conn ( ii , 1 : 2 ) ! print*, pack(vertex_conn, vertex_conn == nodes2vertex) enddo ! print*, pack([( ii, ii = 1, num_nodes )], & !         nodes2vertex == nodes2vertex(3) & !         .or. nodes2vertex == nodes2vertex(5)) ! stop if ( . not . dg ) then elem_conn = vertex_conn else do ii = 1 , num_elements ! elem_conn(ii,:) = pack([( ii, ii = 1, num_nodes )], & !   nodes2vertex == vertex_conn(ii,1)) ! print*, loc(2._wp) ! print*, loc(nodes2vertex == vertex_conn(ii,2)) print * , order ( ii ), vertex_conn ( ii ,:), elem_conn ( ii ,:) print * , enddo endif print * , do ii = 1 , size ( xcoords ) print * , xcoords ( ii ) enddo print * , close ( unit = 21 , iostat = ios ) if ( ios /= 0 ) stop \"Error closing file unit 21\" return end subroutine read_gmsh_file_1D subroutine write_out_solution ( num_nodes , xcoords , GlobalX ) integer , intent ( in ) :: num_nodes real ( wp ), intent ( in ), dimension (:) :: xcoords , GlobalX integer :: ii , ios open ( unit = 21 , file = 'data.out' , iostat = ios , status = \"replace\" , action = \"write\" ) if ( ios /= 0 ) then print * , ios stop \"Error opening file data.out\" endif do ii = 1 , num_nodes write ( 21 , * ) xcoords ( ii ), GlobalX ( ii ) enddo close ( unit = 21 , iostat = ios ) if ( ios /= 0 ) then print * , ios stop \"Error closing file unit data.out\" endif return end subroutine write_out_solution end module io","tags":"","title":"io_mod.f90 – learn_dg","loc":"sourcefile/io_mod.f90.html"},{"text":"This File Depends On sourcefile~~legendre_mod.f90~~EfferentGraph sourcefile~legendre_mod.f90 legendre_mod.f90 sourcefile~integration_mod.f90 integration_mod.f90 sourcefile~integration_mod.f90->sourcefile~legendre_mod.f90 sourcefile~linalg_mod.f90 linalg_mod.f90 sourcefile~linalg_mod.f90->sourcefile~legendre_mod.f90 sourcefile~misc_mod.f90 misc_mod.f90 sourcefile~misc_mod.f90->sourcefile~legendre_mod.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files Dependent On This One sourcefile~~legendre_mod.f90~~AfferentGraph sourcefile~legendre_mod.f90 legendre_mod.f90 sourcefile~pascal_2d_smod.f90 pascal_2D_smod.f90 sourcefile~legendre_mod.f90->sourcefile~pascal_2d_smod.f90 sourcefile~doubleint.f90 doubleint.f90 sourcefile~legendre_mod.f90->sourcefile~doubleint.f90 sourcefile~assembly_mod.f90 assembly_mod.f90 sourcefile~legendre_mod.f90->sourcefile~assembly_mod.f90 sourcefile~pascal_1d_smod.f90 pascal_1D_smod.f90 sourcefile~legendre_mod.f90->sourcefile~pascal_1d_smod.f90 sourcefile~main.f90 main.f90 sourcefile~assembly_mod.f90->sourcefile~main.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Modules legendre Source Code legendre_mod.f90 Source Code ! Learn_dg - A quick and dirty project to deploy a working DG solver ! Copyright (c) 2017, Chris Coutinho ! All rights reserved. ! ! Licensed under the BSD-2 clause license. See LICENSE for details. module legendre use , intrinsic :: iso_fortran_env , only : wp => real64 use :: misc , only : r8mat_print use :: lib_array , only : linspace use :: integration , only : integrate , integrate2D use :: linalg , only : linsolve_quick , linsolve , inv2 , det2 , eye implicit none real ( wp ), dimension (:,:), allocatable :: alpha private public :: getIe public :: getxy interface getxy pure module function getxy ( N ) result ( xy ) integer , intent ( in ) :: N real ( wp ), dimension ( N , 2 ) :: xy end function end interface getxy public :: assembleElementalMatrix interface assembleElementalMatrix module function assembleElementalMatrix1D ( N , d1 , d2 , xy ) result ( Ie ) integer , intent ( in ) :: N , d1 , d2 real ( wp ), dimension ( N ), intent ( in ) :: xy real ( wp ), dimension ( N , N ) :: Ie end function assembleElementalMatrix1D module function assembleElementalMatrix2D ( N , d1 , d2 , xy ) result ( Ie ) integer , intent ( in ) :: N , d1 , d2 real ( wp ), dimension ( N , 2 ), intent ( in ) :: xy real ( wp ), dimension ( N , N ) :: Ie end function assembleElementalMatrix2D end interface assembleElementalMatrix interface pascal_row pure module function pascal_1D_line ( N , x ) result ( row ) integer , intent ( in ) :: N real ( wp ), intent ( in ) :: x real ( wp ), dimension ( N + 1 ) :: row end function pascal_1D_line pure module function pascal_2D_quad ( N , x , y ) result ( row ) integer , intent ( in ) :: N real ( wp ), intent ( in ) :: x real ( wp ), intent ( in ) :: y real ( wp ), dimension (( N + 1 ) ** 2 ) :: row end function pascal_2D_quad end interface pascal_row interface getArow pure module function getArow ( N , xi , eta ) result ( row ) integer , intent ( in ) :: N real ( wp ), intent ( in ) :: xi , eta real ( wp ), dimension ( N ) :: row end function getArow end interface getArow interface getAlpha module function getAlpha2D ( N ) result ( alpha ) integer , intent ( in ) :: N real ( wp ), dimension ( N , N ) :: alpha end function getAlpha2D end interface getAlpha interface getAlpha_ module function getAlpha1D ( N ) result ( alpha ) integer , intent ( in ) :: N real ( wp ), dimension ( N , N ) :: alpha end function getAlpha1D end interface getAlpha_ interface getJacobian module function getJacobian ( N , xi , eta , xy , alpha ) result ( J ) integer , intent ( in ) :: N !! Number of points in element real ( wp ), intent ( in ) :: xi !! real ( wp ), intent ( in ) :: eta !! real ( wp ), dimension ( N , 2 ), intent ( in ) :: xy !! real ( wp ), dimension ( N , N ), intent ( in ) :: alpha !! real ( wp ), dimension ( 2 , 2 ) :: J !! end function getJacobian end interface getJacobian contains ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! ! !!!!!! Elemental Matrix Routines 1-D !!!!!!! ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! subroutine getIe ( dii , djj , xcoords , Ie ) !*  Routine to calculate the elemental mass/stiffness matrix based on the !   derivatives of the basis functions. ! !   Currently only zero-th and first order derivatives are supported. Second !   order derivatives need to be reduced to first order derivatives in the !   problem formulation using Green's Theorem integer , intent ( in ) :: dii !! Derivative of the first basis function integer , intent ( in ) :: djj !! Derivative of the second basis function real ( wp ), intent ( in ), dimension (:) :: xcoords !! Coordinates of the 1D line element real ( wp ), intent ( out ), dimension (:,:) :: Ie !! Output elemental matrix integer :: ii , jj , order order = size ( xcoords ) - 1 do ii = 1 , size ( xcoords ) Ie ( ii , :) = [( integrate_basis_1d_Ie ( order , ii , jj , dii , djj , xcoords ), jj = 1 , order + 1 )] enddo return end subroutine getIe function integrate_basis_1d_Ie ( N , ii , jj , dii , djj , xcoords ) result ( integral ) integer , intent ( in ) :: N , ii , jj , dii , djj real ( wp ), intent ( in ), dimension (:) :: xcoords real ( wp ) :: integral integer :: kk integer :: order , basis_num1 , basis_num2 real ( wp ), dimension ( N + 1 , N + 1 ) :: Vinv order = N basis_num1 = ii basis_num2 = jj Vinv = getAlpha_ ( order + 1 ) ! Check to make sure xcoords is an array of size (N+1) if ( size ( xcoords ) /= order + 1 ) then write ( * , * ) 'The shape of `xcoords` is outside the acceptable range for a' write ( * , * ) '1D basis function.' write ( * , * ) 'Shape(xcoords) should be [' , 2 , order + 1 , '], not ' , shape ( xcoords ) endif call integrate ( local_wrapper , - 1.0_wp , 1.0_wp , integral ) return contains subroutine XorJ ( s , dx , out ) integer , intent ( in ) :: dx real ( wp ), intent ( in ), dimension (:) :: s real ( wp ), intent ( out ), dimension (:) :: out integer :: ii out = 0.0_wp do ii = 1 , size ( xcoords ) out = out + basis_1D ( s , Vinv (:, ii ), dx ) * xcoords ( ii ) enddo end subroutine XorJ subroutine local_wrapper ( s , y ) real ( wp ), intent ( in ), dimension (:) :: s real ( wp ), intent ( out ), dimension (:) :: y real ( wp ), dimension (:), allocatable :: J allocate ( J ( size ( s ))) call XorJ ( s , 1 , J ) ! write(*,*) dii, djj y = 1.0_wp ! Here we have to be careful because J is not always needed in the first ! two function calls. Instead of using if statements, we can use an exponent so that when dx_ == 0, J is 1 y = y * basis_1D ( s , Vinv (:, basis_num1 ), dii ) / ( J ** real ( dii , wp )) y = y * basis_1D ( s , Vinv (:, basis_num2 ), djj ) / ( J ** real ( djj , wp )) y = y * J deallocate ( J ) return end subroutine local_wrapper end function integrate_basis_1d_Ie function basis_1D ( x , alpha , dx ) result ( y ) ! Input/output variables integer , intent ( in ) :: dx real ( wp ), intent ( in ), dimension (:) :: x real ( wp ), intent ( in ), dimension (:) :: alpha real ( wp ), dimension (:), allocatable :: y , yx ! Local variables integer :: ii , N allocate ( y ( size ( x )), yx ( size ( x ))) N = size ( alpha ) y = 0._wp do ii = 1 + dx , N if ( dx == 0 ) then yx = alpha ( ii ) * x ** real ( ii - 1 , wp ) else ! Hoping for the best that dx == 1 yx = real ( ii - 1 , wp ) * alpha ( ii ) * ( x ) ** ( real ( ii - 1 - dx , wp )) endif y = y + yx enddo return end function basis_1D ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! ! !!!!!! Elemental Matrix Routines 2-D !!!!!!! ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! end module legendre","tags":"","title":"legendre_mod.f90 – learn_dg","loc":"sourcefile/legendre_mod.f90.html"},{"text":"Files Dependent On This One sourcefile~~linalg_mod.f90~~AfferentGraph sourcefile~linalg_mod.f90 linalg_mod.f90 sourcefile~legendre_mod.f90 legendre_mod.f90 sourcefile~linalg_mod.f90->sourcefile~legendre_mod.f90 sourcefile~main.f90 main.f90 sourcefile~linalg_mod.f90->sourcefile~main.f90 sourcefile~doubleint.f90 doubleint.f90 sourcefile~linalg_mod.f90->sourcefile~doubleint.f90 sourcefile~legendre_mod.f90->sourcefile~doubleint.f90 sourcefile~pascal_2d_smod.f90 pascal_2D_smod.f90 sourcefile~legendre_mod.f90->sourcefile~pascal_2d_smod.f90 sourcefile~assembly_mod.f90 assembly_mod.f90 sourcefile~legendre_mod.f90->sourcefile~assembly_mod.f90 sourcefile~pascal_1d_smod.f90 pascal_1D_smod.f90 sourcefile~legendre_mod.f90->sourcefile~pascal_1d_smod.f90 sourcefile~assembly_mod.f90->sourcefile~main.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Modules linalg Source Code linalg_mod.f90 Source Code ! Learn_dg - A quick and dirty project to deploy a working DG solver ! Copyright (c) 2017, Chris Coutinho ! All rights reserved. ! ! Licensed under the BSD-2 clause license. See LICENSE for details. module linalg use , intrinsic :: iso_fortran_env , only : wp => real64 implicit none private public :: linsolve_quick , linsolve , inv2 , det2 , eye contains pure function eye ( N ) integer , intent ( in ) :: N real ( wp ), dimension ( N , N ) :: eye integer :: ii eye = 0._wp ; forall ( ii = 1 : N ) eye ( ii , ii ) = 1._wp return end function eye pure function inv2 ( J ) result ( invJ ) real ( wp ), dimension ( 2 , 2 ), intent ( in ) :: J real ( wp ), dimension ( 2 , 2 ) :: invJ invJ = reshape ( [ J ( 2 , 2 ), - J ( 2 , 1 ), - J ( 1 , 2 ), J ( 1 , 1 )], [ 2 , 2 ] ) invJ = invJ / det2 ( J ) return end function inv2 pure function det2 ( A ) result ( det ) ! Computes the determinant of a 2x2 matrix real ( wp ), dimension ( 2 , 2 ), intent ( in ) :: A real ( wp ) :: det det = A ( 1 , 1 ) * A ( 2 , 2 ) - A ( 1 , 2 ) * A ( 2 , 1 ) return end function det2 subroutine linsolve_quick ( n , a , nrhs , b , x ) ! Quick wrapper around linsolve integer , intent ( in ) :: n , nrhs real ( wp ), intent ( in ), dimension ( n , n ) :: a real ( wp ), intent ( in ), dimension ( n , nrhs ) :: b real ( wp ), intent ( out ), dimension ( n , nrhs ) :: x integer , dimension ( n ) :: P real ( wp ), dimension ( n , n ) :: LU call linsolve ( n , a , nrhs , b , x , LU , P , . False .) return end subroutine linsolve_quick subroutine linsolve ( n , a , nrhs , b , x , LU , P , toggle ) ! This routine is a wrapper dgesv, splitting it into its two primary ! components: !             dgetrf - Decomposes A into P*L*U !             dgetrs - Uses P*L*U to solve for x (Ax=b => (P*L*U)x=b) ! ! Splitting these two up like this allows you to save the decomposed ! version of 'a' so that you don't have to do it again. If 'toggle' is ! equal to true, then the decomposition has already occured and LU can be ! trusted - OK to skip dgetrf ! Dummy variables integer , intent ( in ) :: n , nrhs integer , intent ( inout ), dimension ( n ) :: P real ( wp ), intent ( in ), dimension ( n , nrhs ) :: b real ( wp ), intent ( in ), dimension ( n , n ) :: a real ( wp ), intent ( out ), dimension ( n , nrhs ) :: x real ( wp ), intent ( inout ), dimension ( n , n ) :: LU logical , intent ( in ) :: toggle ! Local variables integer :: info integer , dimension ( n ) :: my_P real ( wp ), dimension ( n , n ) :: my_a real ( wp ), dimension ( n , nrhs ) :: my_b my_a = a my_b = b if ( . not . toggle ) then call dgetrf ( n , n , my_a , n , my_P , info ) if ( info /= 0 ) then write ( * , '(a)' ) ' ' write ( * , '(a)' ) 'DGETRF' write ( * , '(a,i8)' ) '  Factorization failed, INFO = ' , info stop endif LU = my_a P = my_P endif call dgetrs ( 'No transpose' , n , nrhs , LU , n , P , my_b , n , info ) if ( info /= 0 ) then write ( * , '(a)' ) ' ' write ( * , '(a)' ) 'DGETRS' write ( * , '(a,i8)' ) '  Back substitution failed, INFO = ' , info stop endif x = my_b return end subroutine linsolve end module linalg","tags":"","title":"linalg_mod.f90 – learn_dg","loc":"sourcefile/linalg_mod.f90.html"},{"text":"This File Depends On sourcefile~~main.f90~~EfferentGraph sourcefile~main.f90 main.f90 sourcefile~io_mod.f90 io_mod.f90 sourcefile~io_mod.f90->sourcefile~main.f90 sourcefile~linalg_mod.f90 linalg_mod.f90 sourcefile~linalg_mod.f90->sourcefile~main.f90 sourcefile~legendre_mod.f90 legendre_mod.f90 sourcefile~linalg_mod.f90->sourcefile~legendre_mod.f90 sourcefile~assembly_mod.f90 assembly_mod.f90 sourcefile~assembly_mod.f90->sourcefile~main.f90 sourcefile~misc_mod.f90 misc_mod.f90 sourcefile~misc_mod.f90->sourcefile~main.f90 sourcefile~misc_mod.f90->sourcefile~legendre_mod.f90 sourcefile~legendre_mod.f90->sourcefile~assembly_mod.f90 sourcefile~integration_mod.f90 integration_mod.f90 sourcefile~integration_mod.f90->sourcefile~legendre_mod.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Programs main Source Code main.f90 Source Code ! Learn_dg - A quick and dirty project to deploy a working DG solver ! Copyright (c) 2017, Chris Coutinho ! All rights reserved. ! ! Licensed under the BSD-2 clause license. See LICENSE for details. program main use , intrinsic :: iso_fortran_env , only : wp => real64 use :: linalg , only : linsolve_quick use :: misc , only : r8mat_print use :: io , only : read_gmsh_file_1D , write_out_solution use :: assembly , only : initialize_global_mats , assemble , set_BCs implicit none real ( wp ), parameter :: diff = 0.1_wp , vel = - 5._wp integer :: num_nodes integer , dimension (:), allocatable :: order , nodes2vertex integer , dimension (:,:), allocatable :: elem_conn real ( wp ), dimension (:), allocatable :: xcoords , GlobalB , GlobalX real ( wp ), dimension (:,:), allocatable :: GlobalA logical :: dg ! dg = .true. dg = . false . call read_gmsh_file_1D ( num_nodes , order , nodes2vertex , elem_conn , xcoords , dg ) ! stop call initialize_global_mats ( num_nodes , GlobalA , GlobalB , GlobalX ) call assemble ( order , xcoords , elem_conn , GlobalA , diff , vel ) call set_BCs ( xcoords , GlobalB , GlobalA ) ! call r8mat_print(num_nodes, num_nodes, GlobalA, 'Global Stiffness matrix:') ! stop call linsolve_quick ( num_nodes , GlobalA , 1 , GlobalB , GlobalX ) ! call r8mat_print(num_nodes, 1, GlobalB, 'Global RHS:') ! call r8mat_print(num_nodes, 1, GlobalX, 'Global Solution Vector:') call write_out_solution ( num_nodes , xcoords , GlobalX ) end program main","tags":"","title":"main.f90 – learn_dg","loc":"sourcefile/main.f90.html"},{"text":"Files Dependent On This One sourcefile~~misc_mod.f90~~AfferentGraph sourcefile~misc_mod.f90 misc_mod.f90 sourcefile~legendre_mod.f90 legendre_mod.f90 sourcefile~misc_mod.f90->sourcefile~legendre_mod.f90 sourcefile~main.f90 main.f90 sourcefile~misc_mod.f90->sourcefile~main.f90 sourcefile~doubleint.f90 doubleint.f90 sourcefile~misc_mod.f90->sourcefile~doubleint.f90 sourcefile~legendre_mod.f90->sourcefile~doubleint.f90 sourcefile~pascal_2d_smod.f90 pascal_2D_smod.f90 sourcefile~legendre_mod.f90->sourcefile~pascal_2d_smod.f90 sourcefile~assembly_mod.f90 assembly_mod.f90 sourcefile~legendre_mod.f90->sourcefile~assembly_mod.f90 sourcefile~pascal_1d_smod.f90 pascal_1D_smod.f90 sourcefile~legendre_mod.f90->sourcefile~pascal_1d_smod.f90 sourcefile~assembly_mod.f90->sourcefile~main.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Modules misc Source Code misc_mod.f90 Source Code ! Learn_dg - A quick and dirty project to deploy a working DG solver ! Copyright (c) 2017, Chris Coutinho ! All rights reserved. ! ! Licensed under the BSD-2 clause license. See LICENSE for details. module misc use , intrinsic :: iso_fortran_env , only : wp => real64 implicit none private public :: r8mat_print contains subroutine r8mat_print ( m , n , a , title ) ! ************************************************************************** ! !* R8MAT_PRINT prints an R8MAT. ! !  Discussion: ! !    An R8MAT is a two dimensional matrix of double precision real values. ! !  Licensing: ! !    This code is distributed under the GNU LGPL license. ! !  Modified: ! !    12 September 2004 ! !  Author: ! !    John Burkardt ! !  Parameters: ! !    Input, integer M, the number of rows in A. ! !    Input, integer N, the number of columns in A. ! !    Input, real ( kind = 8 ) A(M,N), the matrix. ! !    Input, character ( len = * ) TITLE, a title to be printed. implicit none integer ( kind = 4 ) m integer ( kind = 4 ) n real ( kind = 8 ) a ( m , n ) character ( len = * ) title call r8mat_print_some ( m , n , a , 1 , 1 , m , n , title ) return end subroutine r8mat_print subroutine r8mat_print_some ( m , n , a , ilo , jlo , ihi , jhi , title ) ! ************************************************************************** ! !* R8MAT_PRINT_SOME prints some of an R8MAT. ! !  Discussion: ! !    An R8MAT is a two dimensional matrix of double precision real values. ! !  Licensing: ! !    This code is distributed under the GNU LGPL license. ! !  Modified: ! !    26 March 2005 ! !  Author: ! !    John Burkardt ! !  Parameters: ! !    Input, integer M, N, the number of rows and columns. ! !    Input, real ( kind = 8 ) A(M,N), an M by N matrix to be printed. ! !    Input, integer ILO, JLO, the first row and column to print. ! !    Input, integer IHI, JHI, the last row and column to print. ! !    Input, character ( len = * ) TITLE, an optional title. implicit none integer ( kind = 4 ), parameter :: incx = 5 integer ( kind = 4 ) m integer ( kind = 4 ) n real ( kind = 8 ) a ( m , n ) character ( len = 14 ) ctemp ( incx ) integer ( kind = 4 ) i integer ( kind = 4 ) i2hi integer ( kind = 4 ) i2lo integer ( kind = 4 ) ihi integer ( kind = 4 ) ilo integer ( kind = 4 ) inc integer ( kind = 4 ) j integer ( kind = 4 ) j2 integer ( kind = 4 ) j2hi integer ( kind = 4 ) j2lo integer ( kind = 4 ) jhi integer ( kind = 4 ) jlo character ( len = * ) title if ( 0 < len_trim ( title ) ) then write ( * , '(a)' ) ' ' write ( * , '(a)' ) trim ( title ) endif do j2lo = max ( jlo , 1 ), min ( jhi , n ), incx j2hi = j2lo + incx - 1 j2hi = min ( j2hi , n ) j2hi = min ( j2hi , jhi ) inc = j2hi + 1 - j2lo write ( * , '(a)' ) ' ' do j = j2lo , j2hi j2 = j + 1 - j2lo write ( ctemp ( j2 ), '(i8,6x)' ) j enddo write ( * , '(''  Col   '',5a14)' ) ctemp ( 1 : inc ) write ( * , '(a)' ) '  Row' write ( * , '(a)' ) ' ' i2lo = max ( ilo , 1 ) i2hi = min ( ihi , m ) do i = i2lo , i2hi do j2 = 1 , inc j = j2lo - 1 + j2 if ( a ( i , j ) == real ( int ( a ( i , j ) ), kind = 8 ) ) then write ( ctemp ( j2 ), '(f8.0,6x)' ) a ( i , j ) else write ( ctemp ( j2 ), '(g14.6)' ) a ( i , j ) endif enddo write ( * , '(i5,1x,5a14)' ) i , ( ctemp ( j ), j = 1 , inc ) enddo enddo write ( * , '(a)' ) ' ' return end subroutine r8mat_print_some end module misc","tags":"","title":"misc_mod.f90 – learn_dg","loc":"sourcefile/misc_mod.f90.html"},{"text":"This File Depends On sourcefile~~pascal_1d_smod.f90~~EfferentGraph sourcefile~pascal_1d_smod.f90 pascal_1D_smod.f90 sourcefile~legendre_mod.f90 legendre_mod.f90 sourcefile~legendre_mod.f90->sourcefile~pascal_1d_smod.f90 sourcefile~integration_mod.f90 integration_mod.f90 sourcefile~integration_mod.f90->sourcefile~legendre_mod.f90 sourcefile~linalg_mod.f90 linalg_mod.f90 sourcefile~linalg_mod.f90->sourcefile~legendre_mod.f90 sourcefile~misc_mod.f90 misc_mod.f90 sourcefile~misc_mod.f90->sourcefile~legendre_mod.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Submodules pascal_1D Source Code pascal_1D_smod.f90 Source Code ! Learn_dg - A quick and dirty project to deploy a working DG solver ! Copyright (c) 2017, Chris Coutinho ! All rights reserved. ! ! Licensed under the BSD-2 clause license. See LICENSE for details. submodule ( legendre ) pascal_1D !* ! Pascal_1D is a submodule used to generate arrays of coeffiecents used for ! developing finite element basis functions in 1D. Finite element basis ! functions are defined at internal nodes and used to iterpolate some value ! between those nodes. ! ! ! calculate the coeffiecents associated with a univarate Lagrangian polynomial ! !  1, x, x&#94;2, ..., x&#94;N  ! ! ! In the end you end up with a group of basis functions similar to this: ! ! ![Quadratic Basis Functions catption](|media|/quadratic_basis.png \"Quadratic Basis Functions\"){: width=\"500\" } ! {: style=\"text-align: center\" } use , intrinsic :: iso_fortran_env , only : wp => real64 implicit none contains module function assembleElementalMatrix1D ( N , d1 , d2 , xy ) result ( Ie ) integer , intent ( in ) :: N , d1 , d2 real ( wp ), dimension ( N ), intent ( in ) :: xy real ( wp ), dimension ( N , N ) :: Ie integer :: node1 , node2 return end function assembleElementalMatrix1D pure module function getArow_ ( N , xi ) result ( row ) integer , intent ( in ) :: N real ( wp ), intent ( in ) :: xi real ( wp ), dimension ( N ) :: row row = pascal_row ( N - 1 , xi ) return end function getArow_ module function getx ( N ) result ( x ) integer , intent ( in ) :: N real ( wp ), dimension ( N ) :: x call linspace ( - 1.d0 , 1.d0 , x ) ! Gmsh orders all their lines as endpoint1, endpoint2, internal... ! Therefore, need to reorder if numpts is more than 2 if ( N > 2 ) x = [ x ( 1 ), x ( N ), x ( 2 : N - 1 )] return end function getx module function getAlpha1D ( N ) result ( alpha ) integer , intent ( in ) :: N real ( wp ), dimension ( N , N ) :: alpha real ( wp ), dimension ( N , N ) :: A , B A = getA ( N ) B = eye ( N ) call linsolve_quick ( N , A , N , B , alpha ) return contains function getA ( N ) result ( A ) integer , intent ( in ) :: N real ( wp ), dimension ( N , N ) :: A integer :: ii real ( wp ), dimension ( N ) :: x x = getx ( N ) do ii = 1 , N A ( ii ,:) = getArow_ ( N , x ( ii )) enddo return end function getA end function getAlpha1D ! module procedure pascal_1D_line pure module function pascal_1D_line ( N , x ) result ( row ) !* ! Generates the elements of an array associated with a univarate ! Lagrange polynomial. integer , intent ( in ) :: N real ( wp ), intent ( in ) :: x real ( wp ), dimension ( N + 1 ) :: row integer :: ii row = [( x ** ( ii - 1 ), ii = 1 , N + 1 )] return end function pascal_1D_line ! end procedure pascal_1D_line end submodule pascal_1D","tags":"","title":"pascal_1D_smod.f90 – learn_dg","loc":"sourcefile/pascal_1d_smod.f90.html"},{"text":"This File Depends On sourcefile~~pascal_2d_smod.f90~~EfferentGraph sourcefile~pascal_2d_smod.f90 pascal_2D_smod.f90 sourcefile~legendre_mod.f90 legendre_mod.f90 sourcefile~legendre_mod.f90->sourcefile~pascal_2d_smod.f90 sourcefile~integration_mod.f90 integration_mod.f90 sourcefile~integration_mod.f90->sourcefile~legendre_mod.f90 sourcefile~linalg_mod.f90 linalg_mod.f90 sourcefile~linalg_mod.f90->sourcefile~legendre_mod.f90 sourcefile~misc_mod.f90 misc_mod.f90 sourcefile~misc_mod.f90->sourcefile~legendre_mod.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Submodules pascal_2D Source Code pascal_2D_smod.f90 Source Code ! Learn_dg - A quick and dirty project to deploy a working DG solver ! Copyright (c) 2017, Chris Coutinho ! All rights reserved. ! ! Licensed under the BSD-2 clause license. See LICENSE for details. submodule ( legendre ) pascal_2D use , intrinsic :: iso_fortran_env , only : wp => real64 implicit none contains module function assembleElementalMatrix2D ( N , d1 , d2 , xy ) result ( Ie ) ! Dummy variables integer , intent ( in ) :: N , d1 , d2 real ( wp ), dimension ( N , 2 ), intent ( in ) :: xy real ( wp ), dimension ( N , N ) :: Ie ! Local variables integer :: node1 , node2 ! Get the coefficients of the basis functions (alpha). Both bi-linear (N=4) ! and bi-quadratic (N=9) quadrilaterals are supported. if ( . not . allocated ( alpha ) ) alpha = getAlpha ( N ) Ie = 0._wp do node1 = 1 , N do node2 = 1 , N ! fun is now implicitly defined using the following: node1, node2, d1, and d2 Ie ( node1 , node2 ) = Ie ( node1 , node2 ) + integrate2D ( fun ) enddo enddo contains function fun ( xi , eta ) result ( out ) ! Dummy variables real ( wp ), dimension (:,:), intent ( in ) :: xi , eta real ( wp ), dimension (:,:), allocatable :: out ! Local variables integer :: ii , jj , num_pts real ( wp ), parameter :: eps = epsilon ( 0 e0 ) real ( wp ) :: fun1 , fun2 real ( wp ), dimension ( 2 ) :: dfun1 , dfun2 real ( wp ) :: detJ real ( wp ), dimension ( 2 , 2 ) :: J , invJ ! Initialize function output. Actual number of pts is num_pts*num_pts, ! because the meshgrid goes in both x and y directions. Only need one. num_pts = size ( xi , 1 ) allocate ( out ( num_pts , num_pts )) out = 0._wp do ii = 1 , num_pts do jj = 1 , num_pts ! Calculate Jacobian, inverse Jacobian, and determinant of finite ! element at (xi,eta) J = getJacobian ( N , xi ( ii , jj ), eta ( ii , jj ), xy , alpha ) invJ = inv2 ( J ) detJ = det2 ( J ) ! If fun1 is just N_i, use dot_product to determine N_i if ( d1 == 0 ) then fun1 = dot_product ( alpha (:, node1 ), getArow ( N , xi ( ii , jj ), eta ( ii , jj ))) else ! If fun1 contains a derivative, need to calc N_i,xi and N_i,eta dfun1 ( 1 ) = ( & dot_product ( alpha (:, node1 ), getArow ( N , xi ( ii , jj ) + eps , eta ( ii , jj ))) - & dot_product ( alpha (:, node1 ), getArow ( N , xi ( ii , jj ) - eps , eta ( ii , jj ))) & ) / ( 2._wp * eps ) dfun1 ( 2 ) = ( & dot_product ( alpha (:, node1 ), getArow ( N , xi ( ii , jj ), eta ( ii , jj ) + eps )) - & dot_product ( alpha (:, node1 ), getArow ( N , xi ( ii , jj ), eta ( ii , jj ) - eps )) & ) / ( 2._wp * eps ) ! N_i,x = dxi/dx * N_i,xi + deta/dx * N_i,eta fun1 = dot_product ( invJ ( d1 ,:), dfun1 ) endif ! If fun2 is just N_i, use dot_product to determine N_i if ( d2 == 0 ) then fun2 = dot_product ( alpha (:, node2 ), getArow ( N , xi ( ii , jj ), eta ( ii , jj ))) else ! If fun2 contains a derivative, need to calc N_i,xi and N_i,eta dfun2 ( 1 ) = ( & dot_product ( alpha (:, node2 ), & getArow ( N , xi ( ii , jj ) + eps , eta ( ii , jj ))) - & dot_product ( alpha (:, node2 ), & getArow ( N , xi ( ii , jj ) - eps , eta ( ii , jj ))) & ) / ( 2._wp * eps ) dfun2 ( 2 ) = ( & dot_product ( alpha (:, node2 ), getArow ( N , xi ( ii , jj ), eta ( ii , jj ) + eps )) - & dot_product ( alpha (:, node2 ), getArow ( N , xi ( ii , jj ), eta ( ii , jj ) - eps )) & ) / ( 2._wp * eps ) ! N_i,y = dxi/dy * N_i,xi + deta/dy * N_i,eta fun2 = dot_product ( invJ ( d2 ,:), dfun2 ) endif out ( ii , jj ) = fun1 * fun2 * detJ enddo enddo return end function fun end function assembleElementalMatrix2D pure function getxy ( N ) result ( xy ) integer , intent ( in ) :: N real ( wp ), dimension ( N , 2 ) :: xy ! Keep a copy of 0, 1, and 1/3 handy so no need to retype it all the time real ( wp ), parameter :: zero = 0._wp real ( wp ), parameter :: one = 1._wp real ( wp ), parameter :: third = 1._wp / 3._wp select case ( N ) case ( 4 ) xy ( 1 ,:) = [ - one , - one ] ! Node 1 xy ( 2 ,:) = [ one , - one ] ! Node 2 xy ( 3 ,:) = [ one , one ] ! Node 3 xy ( 4 ,:) = [ - one , one ] ! Node 4 case ( 9 ) xy ( 1 ,:) = [ - one , - one ] ! Node 1 xy ( 2 ,:) = [ one , - one ] ! Node 2 xy ( 3 ,:) = [ one , one ] ! Node 3 xy ( 4 ,:) = [ - one , one ] ! Node 4 xy ( 5 ,:) = [ zero , - one ] ! Node 5 xy ( 6 ,:) = [ one , zero ] ! Node 6 xy ( 7 ,:) = [ zero , one ] ! Node 7 xy ( 8 ,:) = [ - one , zero ] ! Node 8 xy ( 9 ,:) = [ zero , zero ] ! Node 9 case ( 16 ) xy ( 1 ,:) = [ - one , - one ] ! Node 1 xy ( 2 ,:) = [ one , - one ] ! Node 2 xy ( 3 ,:) = [ one , one ] ! Node 3 xy ( 4 ,:) = [ - one , one ] ! Node 4 xy ( 5 ,:) = [ - third , - one ] ! Node 5 xy ( 6 ,:) = [ third , - one ] ! Node 6 xy ( 7 ,:) = [ one , - third ] ! Node 7 xy ( 8 ,:) = [ one , third ] ! Node 8 xy ( 9 ,:) = [ third , one ] ! Node 9 xy ( 10 ,:) = [ - third , one ] ! Node 10 xy ( 11 ,:) = [ - one , third ] ! Node 11 xy ( 12 ,:) = [ - one , - third ] ! Node 12 xy ( 13 ,:) = [ - third , - third ] ! Node 13 xy ( 14 ,:) = [ third , - third ] ! Node 14 xy ( 15 ,:) = [ third , third ] ! Node 15 xy ( 16 ,:) = [ - third , third ] ! Node 16 case default ! I should probably changed this to a subroutine and include an output ! error variable xy = 0.d0 end select return end function getxy pure module function getArow ( N , xi , eta ) result ( row ) integer , intent ( in ) :: N real ( wp ), intent ( in ) :: xi , eta real ( wp ), dimension ( N ) :: row select case ( N ) case ( 4 ) ! row = pascal_2D_quad(1, xi, eta) row = pascal_row ( 1 , xi , eta ) case ( 9 ) ! row = pascal_2D_quad(2, xi, eta) row = pascal_row ( 2 , xi , eta ) case ( 16 ) ! row = pascal_2D_quad(3, xi, eta) row = pascal_row ( 3 , xi , eta ) case default row = 0.d0 end select return end function getArow module function getAlpha2D ( N ) result ( alpha ) integer , intent ( in ) :: N real ( wp ), dimension ( N , N ) :: alpha integer :: ii real ( wp ), dimension ( N , N ) :: A , B A = getA ( N ) B = eye ( N ) call linsolve_quick ( N , A , N , B , alpha ) return contains function getA ( N ) result ( A ) integer , intent ( in ) :: N real ( wp ), dimension ( N , N ) :: A integer :: ii real ( wp ), dimension ( N , 2 ) :: xy xy = getxy ( N ) do ii = 1 , N A ( ii ,:) = getArow ( N , xy ( ii , 1 ), xy ( ii , 2 )) enddo return end function getA end function getAlpha2D pure module function pascal_2D_quad ( N , x , y ) result ( row ) !* ! Generates an array of points related to a quadrilateral using Pascal's ! triangle in 2D, where rows are 0-indexed ! ! Pascal's triangle in 2D looks like this, with points used in bi-quadratic quadrilateral in bold: !    [\\mathbf{1}]  !    [\\mathbf{x},~ \\mathbf{y}]  !    [\\mathbf{x&#94;2},~ \\mathbf{x y},~ \\mathbf{y&#94;2}]  !    [x&#94;3,~ \\mathbf{x&#94;2y},~ \\mathbf{xy&#94;2},~ y&#94;3]  !    [x&#94;4,~ x&#94;3y,~ \\mathbf{x&#94;2y&#94;2},~ xy&#94;3, y&#94;4]  !    \\vdots  !    [x&#94;N,~ x&#94;{N-1}y,~ \\cdots ~,~ xy&#94;{N-1},~ y&#94;N]  integer , intent ( in ) :: N !! Order of the qaudrilateral real ( wp ), intent ( in ) :: x !! X-coordinate of node used in calculation real ( wp ), intent ( in ) :: y !! Y-coordinate of node used in calculation real ( wp ), dimension (( N + 1 ) ** 2 ) :: row !! Output row integer :: ii real ( wp ), dimension (:), allocatable :: temp_pre , temp_post row = 0.d0 ! Collects the first N rows of a 2D pascal triangle as function of x and y temp_pre = [( pascal_2D_row ( ii , x , y ), ii = 0 , N )] temp_post = [( pascal_2D_quad_post ( N , ii , x , y ), ii = N + 1 , 2 * N )] row = [ temp_pre , temp_post ] return contains pure function pascal_2D_quad_post ( N , ii , x , y ) result ( row ) integer , intent ( in ) :: N , ii real ( wp ), intent ( in ) :: x , y real ( wp ), dimension ( 2 * N - ii + 1 ) :: row integer :: start , finish real ( wp ), dimension (:), allocatable :: temp temp = pascal_2D_row ( ii , x , y ) start = ii - N + 1 finish = ii - ( ii - N ) + 1 row = temp ( start : finish ) return end function pascal_2D_quad_post end function pascal_2D_quad pure function pascal_2D_row ( N , x , y ) result ( row ) !* ! Generates a row of Pascal's triangle in 2D, where rows are 0-indexed ! ! Pascal's triangle in 2D looks like this: !    [1]  !    [x,~ y]  !    [x&#94;2,~ x y,~ y&#94;2]  !    [x&#94;3,~ x&#94;2y,~ xy&#94;2,~ y&#94;3]  !    [x&#94;4,~ x&#94;3y,~ x&#94;2y&#94;2,~ xy&#94;3, y&#94;4]  !    \\vdots  !    [x&#94;N,~ x&#94;{N-1}y,~ \\cdots,~ xy&#94;{N-1},~ y&#94;N]  ! ! Therefore, the third row (index=2) would be x&#94;2, x\\cdot y, y&#94;2 integer , intent ( in ) :: N !! Row number of pascal's 2D triange (0-indexed) real ( wp ), intent ( in ) :: x !! X-value used in triange real ( wp ), intent ( in ) :: y !! Y-Value used in triange real ( wp ), dimension ( N + 1 ) :: row !! Output row of triange integer :: ii ! Produces the elements of an array: [x&#94;N, x&#94;(N-1)*y, x&#94;(N-2)*y&#94;2, ..., y&#94;N] row = [( x ** ( N - ii ) * y ** ( ii ), ii = 0 , N )] return end function pascal_2D_row module function getJacobian ( N , xi , eta , xy , alpha ) result ( J ) !* ! Calculates the Jacobian of a quadrilateral element ! ! The Jacobian of an element is defined as: !  \\boldsymbol{J} = \\boldsymbol{P} \\boldsymbol{X}  ! ! Where: !  \\boldsymbol{P} = \\left[ \\begin{array}{cc} !     \\frac{\\partial H_1}{\\partial \\xi} & \\frac{\\partial H_2}{\\partial \\xi} \\\\ !     \\frac{\\partial H_1}{\\partial \\eta} & \\frac{\\partial H_2}{\\partial \\eta} \\end{array} !       \\cdots !     \\begin{array}{cc} !     \\frac{\\partial H_{N-1}}{\\partial \\xi} & \\frac{\\partial H_{N}}{\\partial \\xi} \\\\ !     \\frac{\\partial H_{N-1}}{\\partial \\eta} & \\frac{\\partial H_{N}}{\\partial \\eta} \\end{array} ! \\right] ! !  \\boldsymbol{X} = \\left[ \\begin{array}{c} !      \\begin{array}{cc} !        x_1 & y_1 \\\\ !        x_2 & y_2 !      \\end{array} \\\\\\\\ !      \\vdots \\\\\\\\ !      \\begin{array}{cc} !        x_{N-1} & y_{N-1} \\\\ !        x_N & y_N !      \\end{array} \\\\ !    \\end{array} \\right] ! ! Thus: ! !  \\boldsymbol{J} =  \\left[ \\begin{array}{cc} !           \\boldsymbol{H}_{\\xi} \\cdot \\boldsymbol{x} & \\boldsymbol{H}_{\\xi} \\cdot \\boldsymbol{y} \\\\ !           \\boldsymbol{H}_{\\eta} \\cdot \\boldsymbol{x} & \\boldsymbol{H}_{\\eta} \\cdot \\boldsymbol{y} \\\\ !         \\end{array} \\right] = \\left[ \\begin{array}{cc} !           \\frac{\\partial \\xi}{\\partial x} & \\frac{\\partial \\xi}{\\partial y} \\\\ !           \\frac{\\partial \\eta}{\\partial x} & \\frac{\\partial \\eta}{\\partial y} \\\\ !         \\end{array} \\right]  ! ! *  \\boldsymbol{H}  : Vector of basis functions ! *  \\boldsymbol{x}  : Vector of X-coordinates for all element nodes ! *  \\boldsymbol{y}  : Vector of Y-coordinates for all element nodes ! *  H_i  : Basis function i ! *  x_i  : X-coordinate of node i ! *  y_i  : Y-coordinate of node i integer , intent ( in ) :: N !! Number of points in element real ( wp ), intent ( in ) :: xi !! real ( wp ), intent ( in ) :: eta !! real ( wp ), dimension ( N , 2 ), intent ( in ) :: xy !! real ( wp ), dimension ( N , N ), intent ( in ) :: alpha !! real ( wp ), dimension ( 2 , 2 ) :: J !! integer :: ii !! real ( wp ), parameter :: eps = epsilon ( 0 e0 ) real ( wp ), dimension ( 2 , N ) :: P !! Array of real ( wp ), dimension ( N ) :: x !! Row in element coefficient matrix ! P is a matrix containing derivatives of each basis function at (xi,eta) ! P = [dN_1/dxi, dN_2/dxi, dN_3/dxi, ... !      dN_1/deta, dN_2/deta, dN_3/deta, ...] do ii = 1 , N x = alpha (:, ii ) P ( 1 , ii ) = dot_product ( x , getArow ( N , xi + eps , eta )) - & dot_product ( x , getArow ( N , xi - eps , eta )) P ( 2 , ii ) = dot_product ( x , getArow ( N , xi , eta + eps )) - & dot_product ( x , getArow ( N , xi , eta - eps )) enddo P = P / ( 2._wp * eps ) J = matmul ( P , xy ) return end function getJacobian end submodule pascal_2D","tags":"","title":"pascal_2D_smod.f90 – learn_dg","loc":"sourcefile/pascal_2d_smod.f90.html"},{"text":"public subroutine initialize_global_mats(num_nodes, GlobalA, GlobalB, GlobalX) This routine initalizes the global stiffness matrix, global rhs vector,\n  and global solution vector based on the number of nodes in the system This is a bullet point Another bullet point This might be a number Also a number? Some  \\LaTeX :\n  \\frac{\\partial u}{\\partial t} = 0  Arguments Type Intent Optional Attributes Name integer, intent(in) :: num_nodes The number of nodes in the system real(kind=wp), intent(out), dimension(:,:), allocatable :: GlobalA Global mass matrix real(kind=wp), intent(out), dimension(:), allocatable :: GlobalB Global RHS Vector real(kind=wp), intent(out), dimension(:), allocatable :: GlobalX Global solution vector Called By proc~~initialize_global_mats~~CalledByGraph proc~initialize_global_mats initialize_global_mats program~main main program~main->proc~initialize_global_mats Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code initialize_global_mats Source Code subroutine initialize_global_mats ( num_nodes , & GlobalA , & GlobalB , & GlobalX ) !* This routine initalizes the global stiffness matrix, global rhs vector, !  and global solution vector based on the number of nodes in the system ! ! * This is a bullet point ! * Another bullet point ! ! 1. This might be a number ! 2. Also a number? ! ! Some  \\LaTeX : !  \\frac{\\partial u}{\\partial t} = 0  integer , intent ( in ) :: num_nodes !! The number of nodes in the system real ( wp ), intent ( out ), dimension (:), allocatable :: GlobalB !! Global RHS Vector real ( wp ), intent ( out ), dimension (:), allocatable :: GlobalX !! Global solution vector real ( wp ), intent ( out ), dimension (:,:), allocatable :: GlobalA !! Global mass matrix allocate ( GlobalA ( num_nodes , num_nodes )) allocate ( GlobalB ( num_nodes )) allocate ( GlobalX ( num_nodes )) ! Intial Conditions GlobalA = 0._wp GlobalX = 0._wp GlobalB = 0._wp return end subroutine initialize_global_mats","tags":"","title":"initialize_global_mats – learn_dg","loc":"proc/initialize_global_mats.html"},{"text":"public subroutine assemble(order, xcoords, elem_conn, GlobalA, diff, vel) Assemble the global stiffness matrix based on element connectivity Arguments Type Intent Optional Attributes Name integer, intent(in), dimension(:) :: order Order of element(s) real(kind=wp), intent(in), dimension(:) :: xcoords Array of nodal coordinates integer, intent(in), dimension(:,:) :: elem_conn Element connectivity real(kind=wp), intent(out), dimension(:,:) :: GlobalA Global Stiffness matrix real(kind=wp), intent(in) :: diff Diffusivity coefficient [m/s&#94;2] real(kind=wp), intent(in) :: vel Velocity [m/s] Calls proc~~assemble~~CallsGraph proc~assemble assemble getie getie proc~assemble->getie Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called By proc~~assemble~~CalledByGraph proc~assemble assemble program~main main program~main->proc~assemble Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code assemble Source Code subroutine assemble ( order , xcoords , elem_conn , GlobalA , diff , vel ) !* Assemble the global stiffness matrix based on element connectivity integer , intent ( in ), dimension (:) :: order !! Order of element(s) integer , intent ( in ), dimension (:,:) :: elem_conn !! Element connectivity real ( wp ), intent ( in ) :: diff !! Diffusivity coefficient [m/s&#94;2] real ( wp ), intent ( in ) :: vel !! Velocity [m/s] real ( wp ), intent ( in ), dimension (:) :: xcoords !! Array of nodal coordinates real ( wp ), intent ( out ), dimension (:,:) :: GlobalA !! Global Stiffness matrix integer :: ii real ( wp ), dimension (:,:), allocatable :: Ie ! Add elemental stiffness matrices to Global Stiffness Matrix do ii = 1 , size ( order ) ! Reallocate elemental stiffness matrix allocate ( Ie ( order ( ii ) + 1 , order ( ii ) + 1 )) call getIe ( 1 , 1 , xcoords ( elem_conn ( ii ,:)), Ie ) ! call r8mat_print(order(ii)+1, order(ii)+1, Ie, 'Elemental Stiffness Matrix:') GlobalA ( elem_conn ( ii ,:), elem_conn ( ii ,:)) = & GlobalA ( elem_conn ( ii ,:), elem_conn ( ii ,:)) - diff * Ie call getIe ( 0 , 1 , xcoords ( elem_conn ( ii ,:)), Ie ) ! call r8mat_print(order(ii)+1, order(ii)+1, Ie, 'Elemental Stiffness Matrix:') GlobalA ( elem_conn ( ii ,:), elem_conn ( ii ,:)) = & GlobalA ( elem_conn ( ii ,:), elem_conn ( ii ,:)) - vel * Ie ! Deallocate elemental stiffness matrix after every loop deallocate ( Ie ) ! stop enddo ! call r8mat_print(num_nodes, num_nodes, GlobalA, 'Global Stiffness Matrix:') ! stop return end subroutine assemble","tags":"","title":"assemble – learn_dg","loc":"proc/assemble.html"},{"text":"public subroutine set_BCs(xcoords, GlobalB, GlobalA) Set boundary conditions in GlobalA and GlobalB using two Dirchlet\n   boundaries Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: xcoords Array of nodal coordinates real(kind=wp), intent(out), dimension(:) :: GlobalB Global RHS Vector real(kind=wp), intent(out), dimension(:,:) :: GlobalA Global Mass Matrix Source Code set_BCs Source Code subroutine set_BCs ( xcoords , GlobalB , GlobalA ) !*  Set boundary conditions in GlobalA and GlobalB using two Dirchlet !   boundaries real ( wp ), intent ( in ), dimension (:) :: xcoords !! Array of nodal coordinates real ( wp ), intent ( out ), dimension (:) :: GlobalB !! Global RHS Vector real ( wp ), intent ( out ), dimension (:,:) :: GlobalA !! Global Mass Matrix integer , dimension ( 1 ) :: iloc !! Index variable to locate node numbers based on xcoords ! Left Boundary Dirchlet BC iloc = minloc ( xcoords ) GlobalA ( iloc ,:) = 0._wp GlobalA ( iloc , iloc ) = 1._wp GlobalB ( iloc ) = 0._wp ! Right Boundary Dirchlet BC iloc = maxloc ( xcoords ) GlobalA ( iloc ,:) = 0._wp GlobalA ( iloc , iloc ) = 1._wp GlobalB ( iloc ) = 1._wp ! call r8mat_print(num_nodes, 1, GlobalB, 'Global RHS:') ! stop return end subroutine set_BCs","tags":"","title":"set_BCs – learn_dg","loc":"proc/set_bcs.html"},{"text":"public function integrate2D(fun) result(out) Arguments Type Intent Optional Attributes Name procedure( fun2d_interf ) :: fun Return Value real(kind=wp) Calls proc~~integrate2d~~CallsGraph proc~integrate2d integrate2D proc~gaussquad gaussquad proc~integrate2d->proc~gaussquad proc~gaussquad_rosetta gaussquad_rosetta proc~gaussquad->proc~gaussquad_rosetta Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs.","tags":"","title":"integrate2D – learn_dg","loc":"proc/integrate2d.html"},{"text":"public subroutine integrate(sub, a, b, result) Arguments Type Intent Optional Attributes Name procedure( sub1d_interf ) :: sub real(kind=wp), intent(in) :: a real(kind=wp), intent(in) :: b real(kind=wp), intent(out) :: result Calls proc~~integrate~~CallsGraph proc~integrate integrate proc~gaussquad gaussquad proc~integrate->proc~gaussquad proc~gaussquad_rosetta gaussquad_rosetta proc~gaussquad->proc~gaussquad_rosetta Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called By proc~~integrate~~CalledByGraph proc~integrate integrate proc~integrate_basis_1d_ie integrate_basis_1d_Ie proc~integrate_basis_1d_ie->proc~integrate proc~getie getIe proc~getie->proc~integrate_basis_1d_ie Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code integrate Source Code subroutine integrate ( sub , a , b , result ) ! This routine uses gauss-legendre quadrature to integrate a 1D function ! Input/Output variables real ( wp ), intent ( in ) :: a , b real ( wp ), intent ( out ) :: result procedure ( sub1d_interf ) :: sub ! Local variables integer :: N real ( wp ) :: result_old , error real ( wp ), parameter :: eps = sqrt ( epsilon ( 1.0_wp )) real ( wp ), dimension (:), allocatable :: x , w , y N = 3 result = 0.0_wp error = 1.0_wp do result_old = result allocate ( x ( N ), w ( N ), y ( N )) call gaussquad ( N , x , w ) call sub ( x , y ) result = sum ( y * w ) deallocate ( x , w , y ) ! error = norm2([result, result_old]) error = sqrt (( result - result_old ) ** 2.0_wp ) ! error = abs((result-result_old)/(result_old+eps)) ! print*, N, result, error ! print*, N, result, result_old, error, eps ! Check if error is acceptable, as well as whether the loop was gone ! through at least twice (N = 3, 4, 5...) if ( ( error < eps . or . abs ( result ) < eps ) & . and . N > 5 ) then exit else N = N + 1 endif enddo return end subroutine integrate","tags":"","title":"integrate – learn_dg","loc":"proc/integrate.html"},{"text":"private subroutine gaussquad(N, x, w) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N real(kind=wp), intent(out), dimension(N) :: x real(kind=wp), intent(out), dimension(N) :: w Calls proc~~gaussquad~~CallsGraph proc~gaussquad gaussquad proc~gaussquad_rosetta gaussquad_rosetta proc~gaussquad->proc~gaussquad_rosetta Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called By proc~~gaussquad~~CalledByGraph proc~gaussquad gaussquad proc~integrate integrate proc~integrate->proc~gaussquad proc~integrate2d integrate2D proc~integrate2d->proc~gaussquad proc~integrate_basis_1d_ie integrate_basis_1d_Ie proc~integrate_basis_1d_ie->proc~integrate proc~getie getIe proc~getie->proc~integrate_basis_1d_ie Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code gaussquad Source Code subroutine gaussquad ( N , x , w ) integer , intent ( in ) :: N real ( wp ), intent ( out ), dimension ( N ) :: x , w select case ( N ) case ( 1 ) x = [ 0._wp ] w = [ 2._wp ] case ( 2 ) x = [ - 0.5773502691896257_wp , & 0.5773502691896257_wp ] w = [ 1._wp , & 1._wp ] case ( 3 ) x = [ - 0.7745966692414834_wp , & 0._wp , & 0.7745966692414834_wp ] w = [ 0.5555555555555556_wp , & 0.8888888888888888_wp , & 0.5555555555555556_wp ] case ( 4 ) x = [ - 0.8611363115940526_wp , & - 0.3399810435848563_wp , & 0.3399810435848563_wp , & 0.8611363115940526_wp ] w = [ 0.3478548451374538_wp , & 0.6521451548625461_wp , & 0.6521451548625461_wp , & 0.3478548451374538_wp ] case ( 5 ) x = [ - 0.9061798459386640_wp , & - 0.5384693101056831_wp , & 0._wp , & 0.5384693101056831_wp , & 0.9061798459386640_wp ] w = [ 0.2369268850561891_wp , & 0.4786286704993665_wp , & 0.5688888888888889_wp , & 0.4786286704993665_wp , & 0.2369268850561891_wp ] case default ! call lgwt(-1._wp, 1._wp, N, x, w) ! call cgwt(N, x, w) call gaussquad_rosetta ( N , x , w ) end select return end subroutine gaussquad","tags":"","title":"gaussquad – learn_dg","loc":"proc/gaussquad.html"},{"text":"private subroutine lgwt(a, b, num_pts, x, w) This function is a fortran90 port of the matlab function, lgwt.m\n   The source code of lgwt.m was originally found at:\n     http://www.mathworks.com/matlabcentral/fileexchange/4540 Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a real(kind=wp), intent(in) :: b integer, intent(in) :: num_pts real(kind=wp), intent(out), dimension(:) :: x real(kind=wp), intent(out), dimension(:) :: w Calls proc~~lgwt~~CallsGraph proc~lgwt lgwt linspace linspace proc~lgwt->linspace Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code lgwt Source Code subroutine lgwt ( a , b , num_pts , x , w ) !*  This function is a fortran90 port of the matlab function, lgwt.m !   The source code of lgwt.m was originally found at: !     http://www.mathworks.com/matlabcentral/fileexchange/4540 ! Variables in/out integer , intent ( in ) :: num_pts real ( wp ), intent ( in ) :: a , b real ( wp ), intent ( out ), dimension (:) :: x , w ! Local variables integer :: ii , jj , N , N1 , N2 ! real(wp), parameter:: eps=sqrt(epsilon(1.0_wp)) real ( wp ), parameter :: eps = 1 d - 10 real ( wp ), dimension (:), allocatable :: xu , array1 , y , y0 , Lpp real ( wp ), dimension (:, :), allocatable :: L , Lp real ( wp ), parameter :: pi = 4.0_wp * datan ( 1.0_wp ) N = num_pts - 1 N1 = N + 1 N2 = N + 2 ! Allocate and initialize arrays allocate ( xu ( N1 ), array1 ( N1 ), y ( N1 ), y0 ( N1 )) allocate ( L ( N1 , N2 ), Lp ( N1 , N2 ), Lpp ( N1 )) L = 0.0_wp Lp = 0.0_wp call linspace ( - 1.0_wp , 1.0_wp , xu ) array1 = [ ( ii , ii = 0 , N ) ] ! Initial guess of the roots of the Legendre polynomial of order N y = cos (( 2.0_wp * real ( array1 , wp ) + 1.0_wp ) * & pi / ( 2.0_wp * real ( N , wp ) + 2.0_wp )) + & ( 0.27_wp / real ( N1 , wp )) * sin ( pi * xu * real ( N , wp ) / real ( N2 , wp )) y0 = 2.0_wp do L (:, 1 ) = 1.0_wp Lp (:, 1 ) = 0.0_wp L (:, 2 ) = y Lp (:, 2 ) = 1.0_wp do jj = 2 , N1 L (:, jj + 1 ) = ( ( 2.0_wp * real ( jj , wp ) - 1.0_wp ) * y * L (:, jj ) - & real ( jj - 1 , wp ) * L (:, jj - 1 )) / real ( jj , wp ) enddo Lpp = real ( N2 , wp ) * ( L (:, N1 ) - y * L (:, N2 )) / ( 1.0_wp - y ** 2.0_wp ) y0 = y y = y0 - L (:, N2 ) / Lpp if ( norm2 ( y - y0 ) < eps ) then exit endif enddo x = ( a * ( 1.0_wp - y ) + b * ( 1.0_wp + y ) ) / 2.0_wp w = ( b - a ) / (( 1.0_wp - y ** 2.0_wp ) * Lpp ** 2.0_wp ) * & ( real ( N2 , wp ) / real ( N1 , wp )) ** 2.0_wp return end subroutine lgwt","tags":"","title":"lgwt – learn_dg","loc":"proc/lgwt.html"},{"text":"private subroutine cgwt(num_pts, x, w) Arguments Type Intent Optional Attributes Name integer, intent(in) :: num_pts real(kind=wp), intent(out), dimension(:) :: x real(kind=wp), intent(out), dimension(:) :: w Source Code cgwt Source Code subroutine cgwt ( num_pts , x , w ) ! This function  determines the points and weights associated with Chebyshev-Gauss quadrature ! Variables in/out integer , intent ( in ) :: num_pts real ( wp ), intent ( out ), dimension (:) :: x , w ! Local variables integer :: ii real ( wp ), parameter :: pi = 4._wp * datan ( 1._wp ) x = cos ( ( real ( 2 * [( ii , ii = 1 , num_pts )] - 1 , wp ) ) / real ( 2 * num_pts , wp ) * pi ) w = pi / real ( num_pts , wp ) / (( 1.0_wp - x ** 2._wp ) ** ( - 0.5_wp )) ! print*, x ! print*, w ! stop return end subroutine cgwt","tags":"","title":"cgwt – learn_dg","loc":"proc/cgwt.html"},{"text":"private subroutine gaussquad_rosetta(n, r1, r2) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=wp), intent(out) :: r1 (n) real(kind=wp), intent(out) :: r2 (n) Called By proc~~gaussquad_rosetta~~CalledByGraph proc~gaussquad_rosetta gaussquad_rosetta proc~gaussquad gaussquad proc~gaussquad->proc~gaussquad_rosetta proc~integrate integrate proc~integrate->proc~gaussquad proc~integrate2d integrate2D proc~integrate2d->proc~gaussquad proc~integrate_basis_1d_ie integrate_basis_1d_Ie proc~integrate_basis_1d_ie->proc~integrate proc~getie getIe proc~getie->proc~integrate_basis_1d_ie Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code gaussquad_rosetta Source Code subroutine gaussquad_rosetta ( n , r1 , r2 ) ! This code was originally found at the following website: !  http://rosettacode.org/wiki/Numerical_integration/Gauss-Legendre_Quadrature#Fortran integer , intent ( in ) :: n real ( wp ), intent ( out ) :: r1 ( n ), r2 ( n ) integer :: k real ( wp ), parameter :: pi = 4._wp * atan ( 1._wp ) real ( wp ) :: x , f , df , dx integer :: i , iter real ( wp ), allocatable :: p0 (:), p1 (:), tmp (:) p0 = [ 1._wp ] p1 = [ 1._wp , 0._wp ] do k = 2 , n tmp = (( 2 * k - 1 ) * [ p1 , 0._wp ] - ( k - 1 ) * [ 0._wp , 0._wp , p0 ]) / k p0 = p1 ; p1 = tmp enddo do i = 1 , n x = cos ( pi * ( i - 0.25_wp ) / ( n + 0.5_wp )) do iter = 1 , 10 f = p1 ( 1 ); df = 0._wp do k = 2 , size ( p1 ) df = f + x * df f = p1 ( k ) + x * f enddo dx = f / df x = x - dx if ( abs ( dx ) < 10 * epsilon ( dx )) exit enddo r1 ( i ) = x r2 ( i ) = 2 / (( 1 - x ** 2 ) * df ** 2 ) enddo return end subroutine gaussquad_rosetta","tags":"","title":"gaussquad_rosetta – learn_dg","loc":"proc/gaussquad_rosetta.html"},{"text":"interface private function fun2d_interf(x, y) result(z) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:,:) :: x real(kind=wp), intent(in), dimension(:,:) :: y Return Value real(kind=wp),\n  dimension(:,:),allocatable","tags":"","title":"fun2d_interf – learn_dg","loc":"interface/fun2d_interf.html"},{"text":"interface private subroutine sub1d_interf(xx, yy) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: xx real(kind=wp), intent(out), dimension(:) :: yy","tags":"","title":"sub1d_interf – learn_dg","loc":"interface/sub1d_interf.html"},{"text":"public subroutine read_gmsh_file_1D(num_nodes, order, nodes2vertex, elem_conn, xcoords, dg) Reads the input mesh file (gmsh .msh format) and returns the number of\n   nodes, the order of each element, element connectivity, and the\n   coordinates of the nodes (nx1 for 1D, nx2 for 2D, etc.) Arguments Type Intent Optional Attributes Name integer, intent(out) :: num_nodes Number of nodes in mesh integer, intent(out), dimension(:), allocatable :: order Array containing order of each element integer, intent(out), dimension(:), allocatable :: nodes2vertex Array containing node to vertex connectivity (only interesting w.r.t discontinuous galerkin) integer, intent(out), dimension(:,:), allocatable :: elem_conn Array containing node connectivity of each element real(kind=wp), intent(out), dimension(:), allocatable :: xcoords Array containing node coordinates logical, intent(in) :: dg Logical switch is continuous galerkin or discontinuous galerkin Source Code read_gmsh_file_1D Source Code subroutine read_gmsh_file_1D ( num_nodes , & order , & nodes2vertex , & elem_conn , & xcoords , & dg ) ! !*  Reads the input mesh file (gmsh .msh format) and returns the number of !   nodes, the order of each element, element connectivity, and the !   coordinates of the nodes (nx1 for 1D, nx2 for 2D, etc.) integer , intent ( out ) :: num_nodes !! Number of nodes in mesh integer , intent ( out ), dimension (:), allocatable :: order !! Array containing order of each element integer , intent ( out ), dimension (:), allocatable :: nodes2vertex !! Array containing node to vertex connectivity (only interesting w.r.t discontinuous galerkin) integer , intent ( out ), dimension (:,:), allocatable :: elem_conn !! Array containing node connectivity of each element real ( wp ), intent ( out ), dimension (:), allocatable :: xcoords !! Array containing node coordinates logical , intent ( in ) :: dg !! Logical switch is continuous galerkin or discontinuous galerkin integer :: ii , ios , vertex , num_elements , num_vertexes , d_int integer , dimension (:,:), allocatable :: vertex_conn real ( wp ) :: d_real character ( 80 ) :: filename character ( 80 ) :: blank_string call get_command_argument ( 1 , filename ) ! print*, filename open ( unit = 21 , file = filename , iostat = ios , status = \"old\" , action = \"read\" ) if ( ios /= 0 ) then print * , filename print * , ios stop \"Error opening file \" endif ! Read initial header information - assuming file is in the correct format do read ( 21 , * ) blank_string if ( trim ( blank_string ) == '$Nodes' ) exit enddo ! Read number of nodes read ( 21 , * ) num_vertexes allocate ( xcoords ( num_vertexes )) if ( . not . dg ) then num_nodes = num_vertexes else num_nodes = 2 * num_vertexes - 2 endif ! Read coordinate information for each vertex do ii = 1 , num_vertexes read ( 21 , * ) d_int , xcoords ( ii ), d_real , d_real enddo allocate ( nodes2vertex ( num_nodes )) nodes2vertex = 0 if ( dg ) then vertex = 1 do ii = 1 , num_nodes nodes2vertex ( ii ) = vertex if ( ii == 1 . or . ii == num_nodes ) then vertex = vertex + 1 elseif ( mod ( ii , 2 ) == 0 ) then vertex = vertex + 1 endif enddo else nodes2vertex = [( ii , ii = 1 , num_nodes )] endif do ii = 1 , num_nodes print * , ii , nodes2vertex ( ii ), xcoords ( nodes2vertex ( ii )) enddo print * , ! stop ! Two dummy lines : !   $EndNodes !   $Elements read ( 21 , * ) read ( 21 , * ) read ( 21 , * ) num_elements num_elements = num_elements - 2 allocate ( order ( num_elements )) allocate ( elem_conn ( num_elements , 2 )) allocate ( vertex_conn ( num_elements , 2 )) ! Initialize all elements as first order linear elements order = 1 ! Two dummy lines - Associated with 'point' elements read ( 21 , * ) read ( 21 , * ) do ii = 1 , num_elements read ( 21 , * ) d_int , d_int , d_int , d_int , d_int , vertex_conn ( ii , 1 : 2 ) ! print*, pack(vertex_conn, vertex_conn == nodes2vertex) enddo ! print*, pack([( ii, ii = 1, num_nodes )], & !         nodes2vertex == nodes2vertex(3) & !         .or. nodes2vertex == nodes2vertex(5)) ! stop if ( . not . dg ) then elem_conn = vertex_conn else do ii = 1 , num_elements ! elem_conn(ii,:) = pack([( ii, ii = 1, num_nodes )], & !   nodes2vertex == vertex_conn(ii,1)) ! print*, loc(2._wp) ! print*, loc(nodes2vertex == vertex_conn(ii,2)) print * , order ( ii ), vertex_conn ( ii ,:), elem_conn ( ii ,:) print * , enddo endif print * , do ii = 1 , size ( xcoords ) print * , xcoords ( ii ) enddo print * , close ( unit = 21 , iostat = ios ) if ( ios /= 0 ) stop \"Error closing file unit 21\" return end subroutine read_gmsh_file_1D","tags":"","title":"read_gmsh_file_1D – learn_dg","loc":"proc/read_gmsh_file_1d.html"},{"text":"public subroutine write_out_solution(num_nodes, xcoords, GlobalX) Arguments Type Intent Optional Attributes Name integer, intent(in) :: num_nodes real(kind=wp), intent(in), dimension(:) :: xcoords real(kind=wp), intent(in), dimension(:) :: GlobalX Called By proc~~write_out_solution~~CalledByGraph proc~write_out_solution write_out_solution program~main main program~main->proc~write_out_solution Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code write_out_solution Source Code subroutine write_out_solution ( num_nodes , xcoords , GlobalX ) integer , intent ( in ) :: num_nodes real ( wp ), intent ( in ), dimension (:) :: xcoords , GlobalX integer :: ii , ios open ( unit = 21 , file = 'data.out' , iostat = ios , status = \"replace\" , action = \"write\" ) if ( ios /= 0 ) then print * , ios stop \"Error opening file data.out\" endif do ii = 1 , num_nodes write ( 21 , * ) xcoords ( ii ), GlobalX ( ii ) enddo close ( unit = 21 , iostat = ios ) if ( ios /= 0 ) then print * , ios stop \"Error closing file unit data.out\" endif return end subroutine write_out_solution","tags":"","title":"write_out_solution – learn_dg","loc":"proc/write_out_solution.html"},{"text":"private function integrate_basis_1d_Ie(N, ii, jj, dii, djj, xcoords) result(integral) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N integer, intent(in) :: ii integer, intent(in) :: jj integer, intent(in) :: dii integer, intent(in) :: djj real(kind=wp), intent(in), dimension(:) :: xcoords Return Value real(kind=wp) Calls proc~~integrate_basis_1d_ie~~CallsGraph proc~integrate_basis_1d_ie integrate_basis_1d_Ie proc~integrate integrate proc~integrate_basis_1d_ie->proc~integrate interface~getalpha_ getAlpha_ proc~integrate_basis_1d_ie->interface~getalpha_ proc~gaussquad gaussquad proc~integrate->proc~gaussquad proc~gaussquad_rosetta gaussquad_rosetta proc~gaussquad->proc~gaussquad_rosetta Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called By proc~~integrate_basis_1d_ie~~CalledByGraph proc~integrate_basis_1d_ie integrate_basis_1d_Ie proc~getie getIe proc~getie->proc~integrate_basis_1d_ie Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code integrate_basis_1d_Ie Source Code function integrate_basis_1d_Ie ( N , ii , jj , dii , djj , xcoords ) result ( integral ) integer , intent ( in ) :: N , ii , jj , dii , djj real ( wp ), intent ( in ), dimension (:) :: xcoords real ( wp ) :: integral integer :: kk integer :: order , basis_num1 , basis_num2 real ( wp ), dimension ( N + 1 , N + 1 ) :: Vinv order = N basis_num1 = ii basis_num2 = jj Vinv = getAlpha_ ( order + 1 ) ! Check to make sure xcoords is an array of size (N+1) if ( size ( xcoords ) /= order + 1 ) then write ( * , * ) 'The shape of `xcoords` is outside the acceptable range for a' write ( * , * ) '1D basis function.' write ( * , * ) 'Shape(xcoords) should be [' , 2 , order + 1 , '], not ' , shape ( xcoords ) endif call integrate ( local_wrapper , - 1.0_wp , 1.0_wp , integral ) return contains subroutine XorJ ( s , dx , out ) integer , intent ( in ) :: dx real ( wp ), intent ( in ), dimension (:) :: s real ( wp ), intent ( out ), dimension (:) :: out integer :: ii out = 0.0_wp do ii = 1 , size ( xcoords ) out = out + basis_1D ( s , Vinv (:, ii ), dx ) * xcoords ( ii ) enddo end subroutine XorJ subroutine local_wrapper ( s , y ) real ( wp ), intent ( in ), dimension (:) :: s real ( wp ), intent ( out ), dimension (:) :: y real ( wp ), dimension (:), allocatable :: J allocate ( J ( size ( s ))) call XorJ ( s , 1 , J ) ! write(*,*) dii, djj y = 1.0_wp ! Here we have to be careful because J is not always needed in the first ! two function calls. Instead of using if statements, we can use an exponent so that when dx_ == 0, J is 1 y = y * basis_1D ( s , Vinv (:, basis_num1 ), dii ) / ( J ** real ( dii , wp )) y = y * basis_1D ( s , Vinv (:, basis_num2 ), djj ) / ( J ** real ( djj , wp )) y = y * J deallocate ( J ) return end subroutine local_wrapper end function integrate_basis_1d_Ie","tags":"","title":"integrate_basis_1d_Ie – learn_dg","loc":"proc/integrate_basis_1d_ie.html"},{"text":"private function basis_1D(x, alpha, dx) result(y) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: x real(kind=wp), intent(in), dimension(:) :: alpha integer, intent(in) :: dx Return Value real(kind=wp),\n  dimension(:),allocatable Source Code basis_1D Source Code function basis_1D ( x , alpha , dx ) result ( y ) ! Input/output variables integer , intent ( in ) :: dx real ( wp ), intent ( in ), dimension (:) :: x real ( wp ), intent ( in ), dimension (:) :: alpha real ( wp ), dimension (:), allocatable :: y , yx ! Local variables integer :: ii , N allocate ( y ( size ( x )), yx ( size ( x ))) N = size ( alpha ) y = 0._wp do ii = 1 + dx , N if ( dx == 0 ) then yx = alpha ( ii ) * x ** real ( ii - 1 , wp ) else ! Hoping for the best that dx == 1 yx = real ( ii - 1 , wp ) * alpha ( ii ) * ( x ) ** ( real ( ii - 1 - dx , wp )) endif y = y + yx enddo return end function basis_1D","tags":"","title":"basis_1D – learn_dg","loc":"proc/basis_1d.html"},{"text":"public subroutine getIe(dii, djj, xcoords, Ie) Routine to calculate the elemental mass/stiffness matrix based on the\n   derivatives of the basis functions. Currently only zero-th and first order derivatives are supported. Second\n   order derivatives need to be reduced to first order derivatives in the\n   problem formulation using Green's Theorem Arguments Type Intent Optional Attributes Name integer, intent(in) :: dii Derivative of the first basis function integer, intent(in) :: djj Derivative of the second basis function real(kind=wp), intent(in), dimension(:) :: xcoords Coordinates of the 1D line element real(kind=wp), intent(out), dimension(:,:) :: Ie Output elemental matrix Calls proc~~getie~~CallsGraph proc~getie getIe proc~integrate_basis_1d_ie integrate_basis_1d_Ie proc~getie->proc~integrate_basis_1d_ie proc~integrate integrate proc~integrate_basis_1d_ie->proc~integrate interface~getalpha_ getAlpha_ proc~integrate_basis_1d_ie->interface~getalpha_ proc~gaussquad gaussquad proc~integrate->proc~gaussquad proc~gaussquad_rosetta gaussquad_rosetta proc~gaussquad->proc~gaussquad_rosetta Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code getIe Source Code subroutine getIe ( dii , djj , xcoords , Ie ) !*  Routine to calculate the elemental mass/stiffness matrix based on the !   derivatives of the basis functions. ! !   Currently only zero-th and first order derivatives are supported. Second !   order derivatives need to be reduced to first order derivatives in the !   problem formulation using Green's Theorem integer , intent ( in ) :: dii !! Derivative of the first basis function integer , intent ( in ) :: djj !! Derivative of the second basis function real ( wp ), intent ( in ), dimension (:) :: xcoords !! Coordinates of the 1D line element real ( wp ), intent ( out ), dimension (:,:) :: Ie !! Output elemental matrix integer :: ii , jj , order order = size ( xcoords ) - 1 do ii = 1 , size ( xcoords ) Ie ( ii , :) = [( integrate_basis_1d_Ie ( order , ii , jj , dii , djj , xcoords ), jj = 1 , order + 1 )] enddo return end subroutine getIe","tags":"","title":"getIe – learn_dg","loc":"proc/getie.html"},{"text":"public interface getxy Called By interface~~getxy~~CalledByGraph interface~getxy getxy program~doubleint doubleint program~doubleint->interface~getxy Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Functions getxy Functions public pure function getxy(N) result(xy) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N Return Value real(kind=wp),\n  dimension(N,2)","tags":"","title":"getxy – learn_dg","loc":"interface/getxy.html"},{"text":"public interface assembleElementalMatrix Functions assembleElementalMatrix1D assembleElementalMatrix2D Functions public function assembleElementalMatrix1D(N, d1, d2, xy) result(Ie) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N integer, intent(in) :: d1 integer, intent(in) :: d2 real(kind=wp), intent(in), dimension(N) :: xy Return Value real(kind=wp),\n  dimension(N,N) public function assembleElementalMatrix2D(N, d1, d2, xy) result(Ie) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N integer, intent(in) :: d1 integer, intent(in) :: d2 real(kind=wp), intent(in), dimension(N,2) :: xy Return Value real(kind=wp),\n  dimension(N,N)","tags":"","title":"assembleElementalMatrix – learn_dg","loc":"interface/assembleelementalmatrix.html"},{"text":"private interface pascal_row Called By interface~~pascal_row~~CalledByGraph interface~pascal_row pascal_row proc~getarow_ getArow_ proc~getarow_->interface~pascal_row proc~getarow getArow proc~getarow->interface~pascal_row Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Functions pascal_1D_line pascal_2D_quad Functions public pure function pascal_1D_line(N, x) result(row) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N real(kind=wp), intent(in) :: x Return Value real(kind=wp),\n  dimension(N+1) public pure function pascal_2D_quad(N, x, y) result(row) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N real(kind=wp), intent(in) :: x real(kind=wp), intent(in) :: y Return Value real(kind=wp),\n  dimension((N+1)**2)","tags":"","title":"pascal_row – learn_dg","loc":"interface/pascal_row.html"},{"text":"private interface getArow Called By interface~~getarow~~CalledByGraph interface~getarow getArow proc~getjacobian getJacobian proc~getjacobian->interface~getarow Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Functions getArow Functions public pure function getArow(N, xi, eta) result(row) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N real(kind=wp), intent(in) :: xi real(kind=wp), intent(in) :: eta Return Value real(kind=wp),\n  dimension(N)","tags":"","title":"getArow – learn_dg","loc":"interface/getarow.html"},{"text":"private interface getAlpha Called By interface~~getalpha~~CalledByGraph interface~getalpha getAlpha proc~assembleelementalmatrix2d assembleElementalMatrix2D proc~assembleelementalmatrix2d->interface~getalpha Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Functions getAlpha2D Functions public function getAlpha2D(N) result(alpha) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N Return Value real(kind=wp),\n  dimension(N,N)","tags":"","title":"getAlpha – learn_dg","loc":"interface/getalpha.html"},{"text":"private interface getAlpha_ Called By interface~~getalpha_~~CalledByGraph interface~getalpha_ getAlpha_ proc~integrate_basis_1d_ie integrate_basis_1d_Ie proc~integrate_basis_1d_ie->interface~getalpha_ proc~getie getIe proc~getie->proc~integrate_basis_1d_ie Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Functions getAlpha1D Functions public function getAlpha1D(N) result(alpha) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N Return Value real(kind=wp),\n  dimension(N,N)","tags":"","title":"getAlpha_ – learn_dg","loc":"interface/getalpha_.html"},{"text":"private interface getJacobian Functions getJacobian Functions public function getJacobian(N, xi, eta, xy, alpha) result(J) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N Number of points in element real(kind=wp), intent(in) :: xi real(kind=wp), intent(in) :: eta real(kind=wp), intent(in), dimension(N,2) :: xy real(kind=wp), intent(in), dimension(N,N) :: alpha Return Value real(kind=wp),\n  dimension(2,2)","tags":"","title":"getJacobian – learn_dg","loc":"interface/getjacobian.html"},{"text":"public pure function eye(N) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N Return Value real(kind=wp),\n  dimension(N,N) Called By proc~~eye~~CalledByGraph proc~eye eye proc~getalpha1d getAlpha1D proc~getalpha1d->proc~eye proc~getalpha2d getAlpha2D proc~getalpha2d->proc~eye program~doubleint doubleint program~doubleint->proc~eye Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code eye Source Code pure function eye ( N ) integer , intent ( in ) :: N real ( wp ), dimension ( N , N ) :: eye integer :: ii eye = 0._wp ; forall ( ii = 1 : N ) eye ( ii , ii ) = 1._wp return end function eye","tags":"","title":"eye – learn_dg","loc":"proc/eye.html"},{"text":"public pure function inv2(J) result(invJ) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(2,2) :: J Return Value real(kind=wp),\n  dimension(2,2) Calls proc~~inv2~~CallsGraph proc~inv2 inv2 proc~det2 det2 proc~inv2->proc~det2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code inv2 Source Code pure function inv2 ( J ) result ( invJ ) real ( wp ), dimension ( 2 , 2 ), intent ( in ) :: J real ( wp ), dimension ( 2 , 2 ) :: invJ invJ = reshape ( [ J ( 2 , 2 ), - J ( 2 , 1 ), - J ( 1 , 2 ), J ( 1 , 1 )], [ 2 , 2 ] ) invJ = invJ / det2 ( J ) return end function inv2","tags":"","title":"inv2 – learn_dg","loc":"proc/inv2.html"},{"text":"public pure function det2(A) result(det) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(2,2) :: A Return Value real(kind=wp) Called By proc~~det2~~CalledByGraph proc~det2 det2 proc~inv2 inv2 proc~inv2->proc~det2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code det2 Source Code pure function det2 ( A ) result ( det ) ! Computes the determinant of a 2x2 matrix real ( wp ), dimension ( 2 , 2 ), intent ( in ) :: A real ( wp ) :: det det = A ( 1 , 1 ) * A ( 2 , 2 ) - A ( 1 , 2 ) * A ( 2 , 1 ) return end function det2","tags":"","title":"det2 – learn_dg","loc":"proc/det2.html"},{"text":"public subroutine linsolve_quick(n, a, nrhs, b, x) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=wp), intent(in), dimension(n, n) :: a integer, intent(in) :: nrhs real(kind=wp), intent(in), dimension(n, nrhs) :: b real(kind=wp), intent(out), dimension(n, nrhs) :: x Calls proc~~linsolve_quick~~CallsGraph proc~linsolve_quick linsolve_quick proc~linsolve linsolve proc~linsolve_quick->proc~linsolve dgetrf dgetrf proc~linsolve->dgetrf dgetrs dgetrs proc~linsolve->dgetrs Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called By proc~~linsolve_quick~~CalledByGraph proc~linsolve_quick linsolve_quick proc~getalpha1d getAlpha1D proc~getalpha1d->proc~linsolve_quick program~main main program~main->proc~linsolve_quick proc~getalpha2d getAlpha2D proc~getalpha2d->proc~linsolve_quick program~doubleint doubleint program~doubleint->proc~linsolve_quick Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code linsolve_quick Source Code subroutine linsolve_quick ( n , a , nrhs , b , x ) ! Quick wrapper around linsolve integer , intent ( in ) :: n , nrhs real ( wp ), intent ( in ), dimension ( n , n ) :: a real ( wp ), intent ( in ), dimension ( n , nrhs ) :: b real ( wp ), intent ( out ), dimension ( n , nrhs ) :: x integer , dimension ( n ) :: P real ( wp ), dimension ( n , n ) :: LU call linsolve ( n , a , nrhs , b , x , LU , P , . False .) return end subroutine linsolve_quick","tags":"","title":"linsolve_quick – learn_dg","loc":"proc/linsolve_quick.html"},{"text":"public subroutine linsolve(n, a, nrhs, b, x, LU, P, toggle) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=wp), intent(in), dimension(n, n) :: a integer, intent(in) :: nrhs real(kind=wp), intent(in), dimension(n, nrhs) :: b real(kind=wp), intent(out), dimension(n, nrhs) :: x real(kind=wp), intent(inout), dimension(n, n) :: LU integer, intent(inout), dimension(n) :: P logical, intent(in) :: toggle Calls proc~~linsolve~~CallsGraph proc~linsolve linsolve dgetrf dgetrf proc~linsolve->dgetrf dgetrs dgetrs proc~linsolve->dgetrs Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called By proc~~linsolve~~CalledByGraph proc~linsolve linsolve proc~linsolve_quick linsolve_quick proc~linsolve_quick->proc~linsolve proc~getalpha1d getAlpha1D proc~getalpha1d->proc~linsolve_quick program~main main program~main->proc~linsolve_quick proc~getalpha2d getAlpha2D proc~getalpha2d->proc~linsolve_quick program~doubleint doubleint program~doubleint->proc~linsolve_quick Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code linsolve Source Code subroutine linsolve ( n , a , nrhs , b , x , LU , P , toggle ) ! This routine is a wrapper dgesv, splitting it into its two primary ! components: !             dgetrf - Decomposes A into P*L*U !             dgetrs - Uses P*L*U to solve for x (Ax=b => (P*L*U)x=b) ! ! Splitting these two up like this allows you to save the decomposed ! version of 'a' so that you don't have to do it again. If 'toggle' is ! equal to true, then the decomposition has already occured and LU can be ! trusted - OK to skip dgetrf ! Dummy variables integer , intent ( in ) :: n , nrhs integer , intent ( inout ), dimension ( n ) :: P real ( wp ), intent ( in ), dimension ( n , nrhs ) :: b real ( wp ), intent ( in ), dimension ( n , n ) :: a real ( wp ), intent ( out ), dimension ( n , nrhs ) :: x real ( wp ), intent ( inout ), dimension ( n , n ) :: LU logical , intent ( in ) :: toggle ! Local variables integer :: info integer , dimension ( n ) :: my_P real ( wp ), dimension ( n , n ) :: my_a real ( wp ), dimension ( n , nrhs ) :: my_b my_a = a my_b = b if ( . not . toggle ) then call dgetrf ( n , n , my_a , n , my_P , info ) if ( info /= 0 ) then write ( * , '(a)' ) ' ' write ( * , '(a)' ) 'DGETRF' write ( * , '(a,i8)' ) '  Factorization failed, INFO = ' , info stop endif LU = my_a P = my_P endif call dgetrs ( 'No transpose' , n , nrhs , LU , n , P , my_b , n , info ) if ( info /= 0 ) then write ( * , '(a)' ) ' ' write ( * , '(a)' ) 'DGETRS' write ( * , '(a,i8)' ) '  Back substitution failed, INFO = ' , info stop endif x = my_b return end subroutine linsolve","tags":"","title":"linsolve – learn_dg","loc":"proc/linsolve.html"},{"text":"public subroutine r8mat_print(m, n, a, title) R8MAT_PRINT prints an R8MAT. Discussion: An R8MAT is a two dimensional matrix of double precision real values. Licensing: This code is distributed under the GNU LGPL license. Modified: 12 September 2004 Author: John Burkardt Parameters: Input, integer M, the number of rows in A.\n\nInput, integer N, the number of columns in A.\n\nInput, real ( kind = 8 ) A(M,N), the matrix.\n\nInput, character ( len = * ) TITLE, a title to be printed. Arguments Type Intent Optional Attributes Name integer(kind=4) :: m integer(kind=4) :: n real(kind=8) :: a (m,n) character(len=*) :: title Calls proc~~r8mat_print~~CallsGraph proc~r8mat_print r8mat_print proc~r8mat_print_some r8mat_print_some proc~r8mat_print->proc~r8mat_print_some Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called By proc~~r8mat_print~~CalledByGraph proc~r8mat_print r8mat_print program~doubleint doubleint program~doubleint->proc~r8mat_print Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code r8mat_print Source Code subroutine r8mat_print ( m , n , a , title ) ! ************************************************************************** ! !* R8MAT_PRINT prints an R8MAT. ! !  Discussion: ! !    An R8MAT is a two dimensional matrix of double precision real values. ! !  Licensing: ! !    This code is distributed under the GNU LGPL license. ! !  Modified: ! !    12 September 2004 ! !  Author: ! !    John Burkardt ! !  Parameters: ! !    Input, integer M, the number of rows in A. ! !    Input, integer N, the number of columns in A. ! !    Input, real ( kind = 8 ) A(M,N), the matrix. ! !    Input, character ( len = * ) TITLE, a title to be printed. implicit none integer ( kind = 4 ) m integer ( kind = 4 ) n real ( kind = 8 ) a ( m , n ) character ( len = * ) title call r8mat_print_some ( m , n , a , 1 , 1 , m , n , title ) return end subroutine r8mat_print","tags":"","title":"r8mat_print – learn_dg","loc":"proc/r8mat_print.html"},{"text":"private subroutine r8mat_print_some(m, n, a, ilo, jlo, ihi, jhi, title) R8MAT_PRINT_SOME prints some of an R8MAT. Discussion: An R8MAT is a two dimensional matrix of double precision real values. Licensing: This code is distributed under the GNU LGPL license. Modified: 26 March 2005 Author: John Burkardt Parameters: Input, integer M, N, the number of rows and columns.\n\nInput, real ( kind = 8 ) A(M,N), an M by N matrix to be printed.\n\nInput, integer ILO, JLO, the first row and column to print.\n\nInput, integer IHI, JHI, the last row and column to print.\n\nInput, character ( len = * ) TITLE, an optional title. Arguments Type Intent Optional Attributes Name integer(kind=4) :: m integer(kind=4) :: n real(kind=8) :: a (m,n) integer(kind=4) :: ilo integer(kind=4) :: jlo integer(kind=4) :: ihi integer(kind=4) :: jhi character(len=*) :: title Called By proc~~r8mat_print_some~~CalledByGraph proc~r8mat_print_some r8mat_print_some proc~r8mat_print r8mat_print proc~r8mat_print->proc~r8mat_print_some program~doubleint doubleint program~doubleint->proc~r8mat_print Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code r8mat_print_some Source Code subroutine r8mat_print_some ( m , n , a , ilo , jlo , ihi , jhi , title ) ! ************************************************************************** ! !* R8MAT_PRINT_SOME prints some of an R8MAT. ! !  Discussion: ! !    An R8MAT is a two dimensional matrix of double precision real values. ! !  Licensing: ! !    This code is distributed under the GNU LGPL license. ! !  Modified: ! !    26 March 2005 ! !  Author: ! !    John Burkardt ! !  Parameters: ! !    Input, integer M, N, the number of rows and columns. ! !    Input, real ( kind = 8 ) A(M,N), an M by N matrix to be printed. ! !    Input, integer ILO, JLO, the first row and column to print. ! !    Input, integer IHI, JHI, the last row and column to print. ! !    Input, character ( len = * ) TITLE, an optional title. implicit none integer ( kind = 4 ), parameter :: incx = 5 integer ( kind = 4 ) m integer ( kind = 4 ) n real ( kind = 8 ) a ( m , n ) character ( len = 14 ) ctemp ( incx ) integer ( kind = 4 ) i integer ( kind = 4 ) i2hi integer ( kind = 4 ) i2lo integer ( kind = 4 ) ihi integer ( kind = 4 ) ilo integer ( kind = 4 ) inc integer ( kind = 4 ) j integer ( kind = 4 ) j2 integer ( kind = 4 ) j2hi integer ( kind = 4 ) j2lo integer ( kind = 4 ) jhi integer ( kind = 4 ) jlo character ( len = * ) title if ( 0 < len_trim ( title ) ) then write ( * , '(a)' ) ' ' write ( * , '(a)' ) trim ( title ) endif do j2lo = max ( jlo , 1 ), min ( jhi , n ), incx j2hi = j2lo + incx - 1 j2hi = min ( j2hi , n ) j2hi = min ( j2hi , jhi ) inc = j2hi + 1 - j2lo write ( * , '(a)' ) ' ' do j = j2lo , j2hi j2 = j + 1 - j2lo write ( ctemp ( j2 ), '(i8,6x)' ) j enddo write ( * , '(''  Col   '',5a14)' ) ctemp ( 1 : inc ) write ( * , '(a)' ) '  Row' write ( * , '(a)' ) ' ' i2lo = max ( ilo , 1 ) i2hi = min ( ihi , m ) do i = i2lo , i2hi do j2 = 1 , inc j = j2lo - 1 + j2 if ( a ( i , j ) == real ( int ( a ( i , j ) ), kind = 8 ) ) then write ( ctemp ( j2 ), '(f8.0,6x)' ) a ( i , j ) else write ( ctemp ( j2 ), '(g14.6)' ) a ( i , j ) endif enddo write ( * , '(i5,1x,5a14)' ) i , ( ctemp ( j ), j = 1 , inc ) enddo enddo write ( * , '(a)' ) ' ' return end subroutine r8mat_print_some","tags":"","title":"r8mat_print_some – learn_dg","loc":"proc/r8mat_print_some.html"},{"text":"pure function getxy(N) result(xy) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N Return Value real(kind=wp),\n  dimension(N,2) Source Code getxy Source Code pure function getxy ( N ) result ( xy ) integer , intent ( in ) :: N real ( wp ), dimension ( N , 2 ) :: xy ! Keep a copy of 0, 1, and 1/3 handy so no need to retype it all the time real ( wp ), parameter :: zero = 0._wp real ( wp ), parameter :: one = 1._wp real ( wp ), parameter :: third = 1._wp / 3._wp select case ( N ) case ( 4 ) xy ( 1 ,:) = [ - one , - one ] ! Node 1 xy ( 2 ,:) = [ one , - one ] ! Node 2 xy ( 3 ,:) = [ one , one ] ! Node 3 xy ( 4 ,:) = [ - one , one ] ! Node 4 case ( 9 ) xy ( 1 ,:) = [ - one , - one ] ! Node 1 xy ( 2 ,:) = [ one , - one ] ! Node 2 xy ( 3 ,:) = [ one , one ] ! Node 3 xy ( 4 ,:) = [ - one , one ] ! Node 4 xy ( 5 ,:) = [ zero , - one ] ! Node 5 xy ( 6 ,:) = [ one , zero ] ! Node 6 xy ( 7 ,:) = [ zero , one ] ! Node 7 xy ( 8 ,:) = [ - one , zero ] ! Node 8 xy ( 9 ,:) = [ zero , zero ] ! Node 9 case ( 16 ) xy ( 1 ,:) = [ - one , - one ] ! Node 1 xy ( 2 ,:) = [ one , - one ] ! Node 2 xy ( 3 ,:) = [ one , one ] ! Node 3 xy ( 4 ,:) = [ - one , one ] ! Node 4 xy ( 5 ,:) = [ - third , - one ] ! Node 5 xy ( 6 ,:) = [ third , - one ] ! Node 6 xy ( 7 ,:) = [ one , - third ] ! Node 7 xy ( 8 ,:) = [ one , third ] ! Node 8 xy ( 9 ,:) = [ third , one ] ! Node 9 xy ( 10 ,:) = [ - third , one ] ! Node 10 xy ( 11 ,:) = [ - one , third ] ! Node 11 xy ( 12 ,:) = [ - one , - third ] ! Node 12 xy ( 13 ,:) = [ - third , - third ] ! Node 13 xy ( 14 ,:) = [ third , - third ] ! Node 14 xy ( 15 ,:) = [ third , third ] ! Node 15 xy ( 16 ,:) = [ - third , third ] ! Node 16 case default ! I should probably changed this to a subroutine and include an output ! error variable xy = 0.d0 end select return end function getxy","tags":"","title":"getxy – learn_dg","loc":"proc/getxy.html"},{"text":"pure function pascal_2D_row(N, x, y) result(row) Generates a row of Pascal's triangle in 2D, where rows are 0-indexed Pascal's triangle in 2D looks like this:\n    [1] \n    [x,~ y] \n    [x&#94;2,~ x y,~ y&#94;2] \n    [x&#94;3,~ x&#94;2y,~ xy&#94;2,~ y&#94;3] \n    [x&#94;4,~ x&#94;3y,~ x&#94;2y&#94;2,~ xy&#94;3, y&#94;4] \n    \\vdots \n    [x&#94;N,~ x&#94;{N-1}y,~ \\cdots,~ xy&#94;{N-1},~ y&#94;N]  Therefore, the third row (index=2) would be x&#94;2, x\\cdot y, y&#94;2 Arguments Type Intent Optional Attributes Name integer, intent(in) :: N Row number of pascal's 2D triange (0-indexed) real(kind=wp), intent(in) :: x X-value used in triange real(kind=wp), intent(in) :: y Y-Value used in triange Return Value real(kind=wp),\n  dimension(N+1) Output row of triange Called By proc~~pascal_2d_row~~CalledByGraph proc~pascal_2d_row pascal_2D_row proc~pascal_2d_quad pascal_2D_quad proc~pascal_2d_quad->proc~pascal_2d_row Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code pascal_2D_row Source Code pure function pascal_2D_row ( N , x , y ) result ( row ) !* ! Generates a row of Pascal's triangle in 2D, where rows are 0-indexed ! ! Pascal's triangle in 2D looks like this: !    [1]  !    [x,~ y]  !    [x&#94;2,~ x y,~ y&#94;2]  !    [x&#94;3,~ x&#94;2y,~ xy&#94;2,~ y&#94;3]  !    [x&#94;4,~ x&#94;3y,~ x&#94;2y&#94;2,~ xy&#94;3, y&#94;4]  !    \\vdots  !    [x&#94;N,~ x&#94;{N-1}y,~ \\cdots,~ xy&#94;{N-1},~ y&#94;N]  ! ! Therefore, the third row (index=2) would be x&#94;2, x\\cdot y, y&#94;2 integer , intent ( in ) :: N !! Row number of pascal's 2D triange (0-indexed) real ( wp ), intent ( in ) :: x !! X-value used in triange real ( wp ), intent ( in ) :: y !! Y-Value used in triange real ( wp ), dimension ( N + 1 ) :: row !! Output row of triange integer :: ii ! Produces the elements of an array: [x&#94;N, x&#94;(N-1)*y, x&#94;(N-2)*y&#94;2, ..., y&#94;N] row = [( x ** ( N - ii ) * y ** ( ii ), ii = 0 , N )] return end function pascal_2D_row","tags":"","title":"pascal_2D_row – learn_dg","loc":"proc/pascal_2d_row.html"},{"text":"function assembleElementalMatrix1D(N, d1, d2, xy) result(Ie) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N integer, intent(in) :: d1 integer, intent(in) :: d2 real(kind=wp), intent(in), dimension(N) :: xy Return Value real(kind=wp),\n  dimension(N,N) Source Code assembleElementalMatrix1D Source Code module function assembleElementalMatrix1D ( N , d1 , d2 , xy ) result ( Ie ) integer , intent ( in ) :: N , d1 , d2 real ( wp ), dimension ( N ), intent ( in ) :: xy real ( wp ), dimension ( N , N ) :: Ie integer :: node1 , node2 return end function assembleElementalMatrix1D","tags":"","title":"assembleElementalMatrix1D – learn_dg","loc":"proc/assembleelementalmatrix1d.html"},{"text":"pure function getArow_(N, xi) result(row) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N real(kind=wp), intent(in) :: xi Return Value real(kind=wp),\n  dimension(N) Calls proc~~getarow_~~CallsGraph proc~getarow_ getArow_ interface~pascal_row pascal_row proc~getarow_->interface~pascal_row Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code getArow_ Source Code pure module function getArow_ ( N , xi ) result ( row ) integer , intent ( in ) :: N real ( wp ), intent ( in ) :: xi real ( wp ), dimension ( N ) :: row row = pascal_row ( N - 1 , xi ) return end function getArow_","tags":"","title":"getArow_ – learn_dg","loc":"proc/getarow_.html"},{"text":"function getx(N) result(x) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N Return Value real(kind=wp),\n  dimension(N) Calls proc~~getx~~CallsGraph proc~getx getx linspace linspace proc~getx->linspace Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code getx Source Code module function getx ( N ) result ( x ) integer , intent ( in ) :: N real ( wp ), dimension ( N ) :: x call linspace ( - 1.d0 , 1.d0 , x ) ! Gmsh orders all their lines as endpoint1, endpoint2, internal... ! Therefore, need to reorder if numpts is more than 2 if ( N > 2 ) x = [ x ( 1 ), x ( N ), x ( 2 : N - 1 )] return end function getx","tags":"","title":"getx – learn_dg","loc":"proc/getx.html"},{"text":"function getAlpha1D(N) result(alpha) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N Return Value real(kind=wp),\n  dimension(N,N) Calls proc~~getalpha1d~~CallsGraph proc~getalpha1d getAlpha1D proc~linsolve_quick linsolve_quick proc~getalpha1d->proc~linsolve_quick proc~eye eye proc~getalpha1d->proc~eye proc~linsolve linsolve proc~linsolve_quick->proc~linsolve dgetrf dgetrf proc~linsolve->dgetrf dgetrs dgetrs proc~linsolve->dgetrs Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code getAlpha1D Source Code module function getAlpha1D ( N ) result ( alpha ) integer , intent ( in ) :: N real ( wp ), dimension ( N , N ) :: alpha real ( wp ), dimension ( N , N ) :: A , B A = getA ( N ) B = eye ( N ) call linsolve_quick ( N , A , N , B , alpha ) return contains function getA ( N ) result ( A ) integer , intent ( in ) :: N real ( wp ), dimension ( N , N ) :: A integer :: ii real ( wp ), dimension ( N ) :: x x = getx ( N ) do ii = 1 , N A ( ii ,:) = getArow_ ( N , x ( ii )) enddo return end function getA end function getAlpha1D","tags":"","title":"getAlpha1D – learn_dg","loc":"proc/getalpha1d.html"},{"text":"pure function pascal_1D_line(N, x) result(row) Generates the elements of an array associated with a univarate\n Lagrange polynomial. Arguments Type Intent Optional Attributes Name integer, intent(in) :: N real(kind=wp), intent(in) :: x Return Value real(kind=wp),\n  dimension(N+1) Source Code pascal_1D_line Source Code pure module function pascal_1D_line ( N , x ) result ( row ) !* ! Generates the elements of an array associated with a univarate ! Lagrange polynomial. integer , intent ( in ) :: N real ( wp ), intent ( in ) :: x real ( wp ), dimension ( N + 1 ) :: row integer :: ii row = [( x ** ( ii - 1 ), ii = 1 , N + 1 )] return end function pascal_1D_line","tags":"","title":"pascal_1D_line – learn_dg","loc":"proc/pascal_1d_line.html"},{"text":"function assembleElementalMatrix2D(N, d1, d2, xy) result(Ie) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N integer, intent(in) :: d1 integer, intent(in) :: d2 real(kind=wp), intent(in), dimension(N,2) :: xy Return Value real(kind=wp),\n  dimension(N,N) Calls proc~~assembleelementalmatrix2d~~CallsGraph proc~assembleelementalmatrix2d assembleElementalMatrix2D interface~getalpha getAlpha proc~assembleelementalmatrix2d->interface~getalpha integrate2d integrate2d proc~assembleelementalmatrix2d->integrate2d Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code assembleElementalMatrix2D Source Code module function assembleElementalMatrix2D ( N , d1 , d2 , xy ) result ( Ie ) ! Dummy variables integer , intent ( in ) :: N , d1 , d2 real ( wp ), dimension ( N , 2 ), intent ( in ) :: xy real ( wp ), dimension ( N , N ) :: Ie ! Local variables integer :: node1 , node2 ! Get the coefficients of the basis functions (alpha). Both bi-linear (N=4) ! and bi-quadratic (N=9) quadrilaterals are supported. if ( . not . allocated ( alpha ) ) alpha = getAlpha ( N ) Ie = 0._wp do node1 = 1 , N do node2 = 1 , N ! fun is now implicitly defined using the following: node1, node2, d1, and d2 Ie ( node1 , node2 ) = Ie ( node1 , node2 ) + integrate2D ( fun ) enddo enddo contains function fun ( xi , eta ) result ( out ) ! Dummy variables real ( wp ), dimension (:,:), intent ( in ) :: xi , eta real ( wp ), dimension (:,:), allocatable :: out ! Local variables integer :: ii , jj , num_pts real ( wp ), parameter :: eps = epsilon ( 0 e0 ) real ( wp ) :: fun1 , fun2 real ( wp ), dimension ( 2 ) :: dfun1 , dfun2 real ( wp ) :: detJ real ( wp ), dimension ( 2 , 2 ) :: J , invJ ! Initialize function output. Actual number of pts is num_pts*num_pts, ! because the meshgrid goes in both x and y directions. Only need one. num_pts = size ( xi , 1 ) allocate ( out ( num_pts , num_pts )) out = 0._wp do ii = 1 , num_pts do jj = 1 , num_pts ! Calculate Jacobian, inverse Jacobian, and determinant of finite ! element at (xi,eta) J = getJacobian ( N , xi ( ii , jj ), eta ( ii , jj ), xy , alpha ) invJ = inv2 ( J ) detJ = det2 ( J ) ! If fun1 is just N_i, use dot_product to determine N_i if ( d1 == 0 ) then fun1 = dot_product ( alpha (:, node1 ), getArow ( N , xi ( ii , jj ), eta ( ii , jj ))) else ! If fun1 contains a derivative, need to calc N_i,xi and N_i,eta dfun1 ( 1 ) = ( & dot_product ( alpha (:, node1 ), getArow ( N , xi ( ii , jj ) + eps , eta ( ii , jj ))) - & dot_product ( alpha (:, node1 ), getArow ( N , xi ( ii , jj ) - eps , eta ( ii , jj ))) & ) / ( 2._wp * eps ) dfun1 ( 2 ) = ( & dot_product ( alpha (:, node1 ), getArow ( N , xi ( ii , jj ), eta ( ii , jj ) + eps )) - & dot_product ( alpha (:, node1 ), getArow ( N , xi ( ii , jj ), eta ( ii , jj ) - eps )) & ) / ( 2._wp * eps ) ! N_i,x = dxi/dx * N_i,xi + deta/dx * N_i,eta fun1 = dot_product ( invJ ( d1 ,:), dfun1 ) endif ! If fun2 is just N_i, use dot_product to determine N_i if ( d2 == 0 ) then fun2 = dot_product ( alpha (:, node2 ), getArow ( N , xi ( ii , jj ), eta ( ii , jj ))) else ! If fun2 contains a derivative, need to calc N_i,xi and N_i,eta dfun2 ( 1 ) = ( & dot_product ( alpha (:, node2 ), & getArow ( N , xi ( ii , jj ) + eps , eta ( ii , jj ))) - & dot_product ( alpha (:, node2 ), & getArow ( N , xi ( ii , jj ) - eps , eta ( ii , jj ))) & ) / ( 2._wp * eps ) dfun2 ( 2 ) = ( & dot_product ( alpha (:, node2 ), getArow ( N , xi ( ii , jj ), eta ( ii , jj ) + eps )) - & dot_product ( alpha (:, node2 ), getArow ( N , xi ( ii , jj ), eta ( ii , jj ) - eps )) & ) / ( 2._wp * eps ) ! N_i,y = dxi/dy * N_i,xi + deta/dy * N_i,eta fun2 = dot_product ( invJ ( d2 ,:), dfun2 ) endif out ( ii , jj ) = fun1 * fun2 * detJ enddo enddo return end function fun end function assembleElementalMatrix2D","tags":"","title":"assembleElementalMatrix2D – learn_dg","loc":"proc/assembleelementalmatrix2d.html"},{"text":"pure function getArow(N, xi, eta) result(row) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N real(kind=wp), intent(in) :: xi real(kind=wp), intent(in) :: eta Return Value real(kind=wp),\n  dimension(N) Calls proc~~getarow~~CallsGraph proc~getarow getArow interface~pascal_row pascal_row proc~getarow->interface~pascal_row Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code getArow Source Code pure module function getArow ( N , xi , eta ) result ( row ) integer , intent ( in ) :: N real ( wp ), intent ( in ) :: xi , eta real ( wp ), dimension ( N ) :: row select case ( N ) case ( 4 ) ! row = pascal_2D_quad(1, xi, eta) row = pascal_row ( 1 , xi , eta ) case ( 9 ) ! row = pascal_2D_quad(2, xi, eta) row = pascal_row ( 2 , xi , eta ) case ( 16 ) ! row = pascal_2D_quad(3, xi, eta) row = pascal_row ( 3 , xi , eta ) case default row = 0.d0 end select return end function getArow","tags":"","title":"getArow – learn_dg","loc":"proc/getarow.html"},{"text":"function getAlpha2D(N) result(alpha) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N Return Value real(kind=wp),\n  dimension(N,N) Calls proc~~getalpha2d~~CallsGraph proc~getalpha2d getAlpha2D proc~linsolve_quick linsolve_quick proc~getalpha2d->proc~linsolve_quick proc~eye eye proc~getalpha2d->proc~eye proc~linsolve linsolve proc~linsolve_quick->proc~linsolve dgetrf dgetrf proc~linsolve->dgetrf dgetrs dgetrs proc~linsolve->dgetrs Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code getAlpha2D Source Code module function getAlpha2D ( N ) result ( alpha ) integer , intent ( in ) :: N real ( wp ), dimension ( N , N ) :: alpha integer :: ii real ( wp ), dimension ( N , N ) :: A , B A = getA ( N ) B = eye ( N ) call linsolve_quick ( N , A , N , B , alpha ) return contains function getA ( N ) result ( A ) integer , intent ( in ) :: N real ( wp ), dimension ( N , N ) :: A integer :: ii real ( wp ), dimension ( N , 2 ) :: xy xy = getxy ( N ) do ii = 1 , N A ( ii ,:) = getArow ( N , xy ( ii , 1 ), xy ( ii , 2 )) enddo return end function getA end function getAlpha2D","tags":"","title":"getAlpha2D – learn_dg","loc":"proc/getalpha2d.html"},{"text":"pure function pascal_2D_quad(N, x, y) result(row) Generates an array of points related to a quadrilateral using Pascal's\n triangle in 2D, where rows are 0-indexed Pascal's triangle in 2D looks like this, with points used in bi-quadratic quadrilateral in bold:\n    [\\mathbf{1}] \n    [\\mathbf{x},~ \\mathbf{y}] \n    [\\mathbf{x&#94;2},~ \\mathbf{x y},~ \\mathbf{y&#94;2}] \n    [x&#94;3,~ \\mathbf{x&#94;2y},~ \\mathbf{xy&#94;2},~ y&#94;3] \n    [x&#94;4,~ x&#94;3y,~ \\mathbf{x&#94;2y&#94;2},~ xy&#94;3, y&#94;4] \n    \\vdots \n    [x&#94;N,~ x&#94;{N-1}y,~ \\cdots ~,~ xy&#94;{N-1},~ y&#94;N]  Arguments Type Intent Optional Attributes Name integer, intent(in) :: N Order of the qaudrilateral real(kind=wp), intent(in) :: x X-coordinate of node used in calculation real(kind=wp), intent(in) :: y Y-coordinate of node used in calculation Return Value real(kind=wp),\n  dimension((N+1)**2) Output row Calls proc~~pascal_2d_quad~~CallsGraph proc~pascal_2d_quad pascal_2D_quad proc~pascal_2d_row pascal_2D_row proc~pascal_2d_quad->proc~pascal_2d_row Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code pascal_2D_quad Source Code pure module function pascal_2D_quad ( N , x , y ) result ( row ) !* ! Generates an array of points related to a quadrilateral using Pascal's ! triangle in 2D, where rows are 0-indexed ! ! Pascal's triangle in 2D looks like this, with points used in bi-quadratic quadrilateral in bold: !    [\\mathbf{1}]  !    [\\mathbf{x},~ \\mathbf{y}]  !    [\\mathbf{x&#94;2},~ \\mathbf{x y},~ \\mathbf{y&#94;2}]  !    [x&#94;3,~ \\mathbf{x&#94;2y},~ \\mathbf{xy&#94;2},~ y&#94;3]  !    [x&#94;4,~ x&#94;3y,~ \\mathbf{x&#94;2y&#94;2},~ xy&#94;3, y&#94;4]  !    \\vdots  !    [x&#94;N,~ x&#94;{N-1}y,~ \\cdots ~,~ xy&#94;{N-1},~ y&#94;N]  integer , intent ( in ) :: N !! Order of the qaudrilateral real ( wp ), intent ( in ) :: x !! X-coordinate of node used in calculation real ( wp ), intent ( in ) :: y !! Y-coordinate of node used in calculation real ( wp ), dimension (( N + 1 ) ** 2 ) :: row !! Output row integer :: ii real ( wp ), dimension (:), allocatable :: temp_pre , temp_post row = 0.d0 ! Collects the first N rows of a 2D pascal triangle as function of x and y temp_pre = [( pascal_2D_row ( ii , x , y ), ii = 0 , N )] temp_post = [( pascal_2D_quad_post ( N , ii , x , y ), ii = N + 1 , 2 * N )] row = [ temp_pre , temp_post ] return contains pure function pascal_2D_quad_post ( N , ii , x , y ) result ( row ) integer , intent ( in ) :: N , ii real ( wp ), intent ( in ) :: x , y real ( wp ), dimension ( 2 * N - ii + 1 ) :: row integer :: start , finish real ( wp ), dimension (:), allocatable :: temp temp = pascal_2D_row ( ii , x , y ) start = ii - N + 1 finish = ii - ( ii - N ) + 1 row = temp ( start : finish ) return end function pascal_2D_quad_post end function pascal_2D_quad","tags":"","title":"pascal_2D_quad – learn_dg","loc":"proc/pascal_2d_quad.html"},{"text":"function getJacobian(N, xi, eta, xy, alpha) result(J) Calculates the Jacobian of a quadrilateral element The Jacobian of an element is defined as:\n  \\boldsymbol{J} = \\boldsymbol{P} \\boldsymbol{X}  Where:\n  \\boldsymbol{P} = \\left[ \\begin{array}{cc}\n     \\frac{\\partial H_1}{\\partial \\xi} & \\frac{\\partial H_2}{\\partial \\xi} \\\\\n     \\frac{\\partial H_1}{\\partial \\eta} & \\frac{\\partial H_2}{\\partial \\eta} \\end{array}\n       \\cdots\n     \\begin{array}{cc}\n     \\frac{\\partial H_{N-1}}{\\partial \\xi} & \\frac{\\partial H_{N}}{\\partial \\xi} \\\\\n     \\frac{\\partial H_{N-1}}{\\partial \\eta} & \\frac{\\partial H_{N}}{\\partial \\eta} \\end{array}\n \\right]  \\boldsymbol{X} = \\left[ \\begin{array}{c}\n      \\begin{array}{cc}\n        x_1 & y_1 \\\\\n        x_2 & y_2\n      \\end{array} \\\\\n      \\vdots \\\\\n      \\begin{array}{cc}\n        x_{N-1} & y_{N-1} \\\\\n        x_N & y_N\n      \\end{array} \\\\\n    \\end{array} \\right] Thus:  \\boldsymbol{J} =  \\left[ \\begin{array}{cc}\n           \\boldsymbol{H}_{\\xi} \\cdot \\boldsymbol{x} & \\boldsymbol{H}_{\\xi} \\cdot \\boldsymbol{y} \\\\\n           \\boldsymbol{H}_{\\eta} \\cdot \\boldsymbol{x} & \\boldsymbol{H}_{\\eta} \\cdot \\boldsymbol{y} \\\\\n         \\end{array} \\right] = \\left[ \\begin{array}{cc}\n           \\frac{\\partial \\xi}{\\partial x} & \\frac{\\partial \\xi}{\\partial y} \\\\\n           \\frac{\\partial \\eta}{\\partial x} & \\frac{\\partial \\eta}{\\partial y} \\\\\n         \\end{array} \\right]   \\boldsymbol{H}  : Vector of basis functions  \\boldsymbol{x}  : Vector of X-coordinates for all element nodes  \\boldsymbol{y}  : Vector of Y-coordinates for all element nodes Arguments Type Intent Optional Attributes Name integer, intent(in) :: N Number of points in element real(kind=wp), intent(in) :: xi real(kind=wp), intent(in) :: eta real(kind=wp), intent(in), dimension(N,2) :: xy real(kind=wp), intent(in), dimension(N,N) :: alpha Return Value real(kind=wp),\n  dimension(2,2) Calls proc~~getjacobian~~CallsGraph proc~getjacobian getJacobian interface~getarow getArow proc~getjacobian->interface~getarow Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code getJacobian Source Code module function getJacobian ( N , xi , eta , xy , alpha ) result ( J ) !* ! Calculates the Jacobian of a quadrilateral element ! ! The Jacobian of an element is defined as: !  \\boldsymbol{J} = \\boldsymbol{P} \\boldsymbol{X}  ! ! Where: !  \\boldsymbol{P} = \\left[ \\begin{array}{cc} !     \\frac{\\partial H_1}{\\partial \\xi} & \\frac{\\partial H_2}{\\partial \\xi} \\\\ !     \\frac{\\partial H_1}{\\partial \\eta} & \\frac{\\partial H_2}{\\partial \\eta} \\end{array} !       \\cdots !     \\begin{array}{cc} !     \\frac{\\partial H_{N-1}}{\\partial \\xi} & \\frac{\\partial H_{N}}{\\partial \\xi} \\\\ !     \\frac{\\partial H_{N-1}}{\\partial \\eta} & \\frac{\\partial H_{N}}{\\partial \\eta} \\end{array} ! \\right] ! !  \\boldsymbol{X} = \\left[ \\begin{array}{c} !      \\begin{array}{cc} !        x_1 & y_1 \\\\ !        x_2 & y_2 !      \\end{array} \\\\\\\\ !      \\vdots \\\\\\\\ !      \\begin{array}{cc} !        x_{N-1} & y_{N-1} \\\\ !        x_N & y_N !      \\end{array} \\\\ !    \\end{array} \\right] ! ! Thus: ! !  \\boldsymbol{J} =  \\left[ \\begin{array}{cc} !           \\boldsymbol{H}_{\\xi} \\cdot \\boldsymbol{x} & \\boldsymbol{H}_{\\xi} \\cdot \\boldsymbol{y} \\\\ !           \\boldsymbol{H}_{\\eta} \\cdot \\boldsymbol{x} & \\boldsymbol{H}_{\\eta} \\cdot \\boldsymbol{y} \\\\ !         \\end{array} \\right] = \\left[ \\begin{array}{cc} !           \\frac{\\partial \\xi}{\\partial x} & \\frac{\\partial \\xi}{\\partial y} \\\\ !           \\frac{\\partial \\eta}{\\partial x} & \\frac{\\partial \\eta}{\\partial y} \\\\ !         \\end{array} \\right]  ! ! *  \\boldsymbol{H}  : Vector of basis functions ! *  \\boldsymbol{x}  : Vector of X-coordinates for all element nodes ! *  \\boldsymbol{y}  : Vector of Y-coordinates for all element nodes ! *  H_i  : Basis function i ! *  x_i  : X-coordinate of node i ! *  y_i  : Y-coordinate of node i integer , intent ( in ) :: N !! Number of points in element real ( wp ), intent ( in ) :: xi !! real ( wp ), intent ( in ) :: eta !! real ( wp ), dimension ( N , 2 ), intent ( in ) :: xy !! real ( wp ), dimension ( N , N ), intent ( in ) :: alpha !! real ( wp ), dimension ( 2 , 2 ) :: J !! integer :: ii !! real ( wp ), parameter :: eps = epsilon ( 0 e0 ) real ( wp ), dimension ( 2 , N ) :: P !! Array of real ( wp ), dimension ( N ) :: x !! Row in element coefficient matrix ! P is a matrix containing derivatives of each basis function at (xi,eta) ! P = [dN_1/dxi, dN_2/dxi, dN_3/dxi, ... !      dN_1/deta, dN_2/deta, dN_3/deta, ...] do ii = 1 , N x = alpha (:, ii ) P ( 1 , ii ) = dot_product ( x , getArow ( N , xi + eps , eta )) - & dot_product ( x , getArow ( N , xi - eps , eta )) P ( 2 , ii ) = dot_product ( x , getArow ( N , xi , eta + eps )) - & dot_product ( x , getArow ( N , xi , eta - eps )) enddo P = P / ( 2._wp * eps ) J = matmul ( P , xy ) return end function getJacobian","tags":"","title":"getJacobian – learn_dg","loc":"proc/getjacobian.html"},{"text":"Uses: iso_fortran_env legendre module~~assembly~~UsesGraph module~assembly assembly iso_fortran_env iso_fortran_env iso_fortran_env->module~assembly module~legendre legendre iso_fortran_env->module~legendre module~misc misc iso_fortran_env->module~misc module~linalg linalg iso_fortran_env->module~linalg module~integration integration iso_fortran_env->module~integration module~legendre->module~assembly lib_array lib_array lib_array->module~legendre lib_array->module~integration module~misc->module~legendre module~linalg->module~legendre module~integration->module~legendre Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used By module~~assembly~~UsedByGraph module~assembly assembly program~main main module~assembly->program~main Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Subroutines initialize_global_mats assemble set_BCs Subroutines public subroutine initialize_global_mats (num_nodes, GlobalA, GlobalB, GlobalX) This routine initalizes the global stiffness matrix, global rhs vector,\n  and global solution vector based on the number of nodes in the system Arguments Type Intent Optional Attributes Name integer, intent(in) :: num_nodes The number of nodes in the system real(kind=wp), intent(out), dimension(:,:), allocatable :: GlobalA Global mass matrix real(kind=wp), intent(out), dimension(:), allocatable :: GlobalB Global RHS Vector real(kind=wp), intent(out), dimension(:), allocatable :: GlobalX Global solution vector public subroutine assemble (order, xcoords, elem_conn, GlobalA, diff, vel) Assemble the global stiffness matrix based on element connectivity Arguments Type Intent Optional Attributes Name integer, intent(in), dimension(:) :: order Order of element(s) real(kind=wp), intent(in), dimension(:) :: xcoords Array of nodal coordinates integer, intent(in), dimension(:,:) :: elem_conn Element connectivity real(kind=wp), intent(out), dimension(:,:) :: GlobalA Global Stiffness matrix real(kind=wp), intent(in) :: diff Diffusivity coefficient [m/s&#94;2] real(kind=wp), intent(in) :: vel Velocity [m/s] public subroutine set_BCs (xcoords, GlobalB, GlobalA) Set boundary conditions in GlobalA and GlobalB using two Dirchlet\n   boundaries Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: xcoords Array of nodal coordinates real(kind=wp), intent(out), dimension(:) :: GlobalB Global RHS Vector real(kind=wp), intent(out), dimension(:,:) :: GlobalA Global Mass Matrix","tags":"","title":"assembly – learn_dg","loc":"module/assembly.html"},{"text":"Uses: iso_fortran_env lib_array module~~integration~~UsesGraph module~integration integration lib_array lib_array lib_array->module~integration iso_fortran_env iso_fortran_env iso_fortran_env->module~integration Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used By module~~integration~~UsedByGraph module~integration integration module~legendre legendre module~integration->module~legendre program~doubleint doubleint module~legendre->program~doubleint module~assembly assembly module~legendre->module~assembly module~pascal_1d pascal_1D module~legendre->module~pascal_1d module~pascal_2d pascal_2D module~legendre->module~pascal_2d program~main main module~assembly->program~main Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Interfaces fun2d_interf sub1d_interf Functions integrate2D Subroutines integrate gaussquad lgwt cgwt gaussquad_rosetta Interfaces interface private function fun2d_interf (x, y) result(z) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:,:) :: x real(kind=wp), intent(in), dimension(:,:) :: y Return Value real(kind=wp),\n  dimension(:,:), allocatable interface private subroutine sub1d_interf (xx, yy) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: xx real(kind=wp), intent(out), dimension(:) :: yy Functions public function integrate2D (fun) result(out) Arguments Type Intent Optional Attributes Name procedure( fun2d_interf ) :: fun Return Value real(kind=wp) Subroutines public subroutine integrate (sub, a, b, result) Arguments Type Intent Optional Attributes Name procedure( sub1d_interf ) :: sub real(kind=wp), intent(in) :: a real(kind=wp), intent(in) :: b real(kind=wp), intent(out) :: result private subroutine gaussquad (N, x, w) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N real(kind=wp), intent(out), dimension(N) :: x real(kind=wp), intent(out), dimension(N) :: w private subroutine lgwt (a, b, num_pts, x, w) This function is a fortran90 port of the matlab function, lgwt.m\n   The source code of lgwt.m was originally found at:\n     http://www.mathworks.com/matlabcentral/fileexchange/4540 Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a real(kind=wp), intent(in) :: b integer, intent(in) :: num_pts real(kind=wp), intent(out), dimension(:) :: x real(kind=wp), intent(out), dimension(:) :: w private subroutine cgwt (num_pts, x, w) Arguments Type Intent Optional Attributes Name integer, intent(in) :: num_pts real(kind=wp), intent(out), dimension(:) :: x real(kind=wp), intent(out), dimension(:) :: w private subroutine gaussquad_rosetta (n, r1, r2) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=wp), intent(out) :: r1 (n) real(kind=wp), intent(out) :: r2 (n)","tags":"","title":"integration – learn_dg","loc":"module/integration.html"},{"text":"Uses: iso_fortran_env lib_array module~~io~~UsesGraph module~io io lib_array lib_array lib_array->module~io iso_fortran_env iso_fortran_env iso_fortran_env->module~io Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used By module~~io~~UsedByGraph module~io io program~main main module~io->program~main Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Subroutines read_gmsh_file_1D write_out_solution Subroutines public subroutine read_gmsh_file_1D (num_nodes, order, nodes2vertex, elem_conn, xcoords, dg) Reads the input mesh file (gmsh .msh format) and returns the number of\n   nodes, the order of each element, element connectivity, and the\n   coordinates of the nodes (nx1 for 1D, nx2 for 2D, etc.) Arguments Type Intent Optional Attributes Name integer, intent(out) :: num_nodes Number of nodes in mesh integer, intent(out), dimension(:), allocatable :: order Array containing order of each element integer, intent(out), dimension(:), allocatable :: nodes2vertex Array containing node to vertex connectivity (only interesting w.r.t discontinuous galerkin) integer, intent(out), dimension(:,:), allocatable :: elem_conn Array containing node connectivity of each element real(kind=wp), intent(out), dimension(:), allocatable :: xcoords Array containing node coordinates logical, intent(in) :: dg Logical switch is continuous galerkin or discontinuous galerkin public subroutine write_out_solution (num_nodes, xcoords, GlobalX) Arguments Type Intent Optional Attributes Name integer, intent(in) :: num_nodes real(kind=wp), intent(in), dimension(:) :: xcoords real(kind=wp), intent(in), dimension(:) :: GlobalX","tags":"","title":"io – learn_dg","loc":"module/io.html"},{"text":"Uses: iso_fortran_env misc lib_array integration linalg module~~legendre~~UsesGraph module~legendre legendre lib_array lib_array lib_array->module~legendre module~integration integration lib_array->module~integration iso_fortran_env iso_fortran_env iso_fortran_env->module~legendre module~misc misc iso_fortran_env->module~misc module~linalg linalg iso_fortran_env->module~linalg iso_fortran_env->module~integration module~misc->module~legendre module~linalg->module~legendre module~integration->module~legendre Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Descendants: pascal_1D pascal_2D Used By module~~legendre~~UsedByGraph module~legendre legendre program~doubleint doubleint module~legendre->program~doubleint module~assembly assembly module~legendre->module~assembly module~pascal_1d pascal_1D module~legendre->module~pascal_1d module~pascal_2d pascal_2D module~legendre->module~pascal_2d program~main main module~assembly->program~main Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Variables alpha Interfaces getxy assembleElementalMatrix pascal_row getArow getAlpha getAlpha_ getJacobian Functions integrate_basis_1d_Ie basis_1D Subroutines getIe Variables Type Visibility Attributes Name Initial real(kind=wp), public, dimension(:,:), allocatable :: alpha Interfaces public interface getxy public pure function getxy(N) result(xy) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N Return Value real(kind=wp),\n  dimension(N,2) public interface assembleElementalMatrix public function assembleElementalMatrix1D(N, d1, d2, xy) result(Ie) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N integer, intent(in) :: d1 integer, intent(in) :: d2 real(kind=wp), intent(in), dimension(N) :: xy Return Value real(kind=wp),\n  dimension(N,N) public function assembleElementalMatrix2D(N, d1, d2, xy) result(Ie) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N integer, intent(in) :: d1 integer, intent(in) :: d2 real(kind=wp), intent(in), dimension(N,2) :: xy Return Value real(kind=wp),\n  dimension(N,N) private interface pascal_row public pure function pascal_1D_line(N, x) result(row) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N real(kind=wp), intent(in) :: x Return Value real(kind=wp),\n  dimension(N+1) public pure function pascal_2D_quad(N, x, y) result(row) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N real(kind=wp), intent(in) :: x real(kind=wp), intent(in) :: y Return Value real(kind=wp),\n  dimension((N+1)**2) private interface getArow public pure function getArow(N, xi, eta) result(row) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N real(kind=wp), intent(in) :: xi real(kind=wp), intent(in) :: eta Return Value real(kind=wp),\n  dimension(N) private interface getAlpha public function getAlpha2D(N) result(alpha) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N Return Value real(kind=wp),\n  dimension(N,N) private interface getAlpha_ public function getAlpha1D(N) result(alpha) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N Return Value real(kind=wp),\n  dimension(N,N) private interface getJacobian public function getJacobian(N, xi, eta, xy, alpha) result(J) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N Number of points in element real(kind=wp), intent(in) :: xi real(kind=wp), intent(in) :: eta real(kind=wp), intent(in), dimension(N,2) :: xy real(kind=wp), intent(in), dimension(N,N) :: alpha Return Value real(kind=wp),\n  dimension(2,2) Functions private function integrate_basis_1d_Ie (N, ii, jj, dii, djj, xcoords) result(integral) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N integer, intent(in) :: ii integer, intent(in) :: jj integer, intent(in) :: dii integer, intent(in) :: djj real(kind=wp), intent(in), dimension(:) :: xcoords Return Value real(kind=wp) private function basis_1D (x, alpha, dx) result(y) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: x real(kind=wp), intent(in), dimension(:) :: alpha integer, intent(in) :: dx Return Value real(kind=wp),\n  dimension(:), allocatable Subroutines public subroutine getIe (dii, djj, xcoords, Ie) Routine to calculate the elemental mass/stiffness matrix based on the\n   derivatives of the basis functions. Arguments Type Intent Optional Attributes Name integer, intent(in) :: dii Derivative of the first basis function integer, intent(in) :: djj Derivative of the second basis function real(kind=wp), intent(in), dimension(:) :: xcoords Coordinates of the 1D line element real(kind=wp), intent(out), dimension(:,:) :: Ie Output elemental matrix","tags":"","title":"legendre – learn_dg","loc":"module/legendre.html"},{"text":"Uses: iso_fortran_env module~~linalg~~UsesGraph module~linalg linalg iso_fortran_env iso_fortran_env iso_fortran_env->module~linalg Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used By module~~linalg~~UsedByGraph module~linalg linalg module~legendre legendre module~linalg->module~legendre program~main main module~linalg->program~main program~doubleint doubleint module~linalg->program~doubleint module~legendre->program~doubleint module~assembly assembly module~legendre->module~assembly module~pascal_1d pascal_1D module~legendre->module~pascal_1d module~pascal_2d pascal_2D module~legendre->module~pascal_2d module~assembly->program~main Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Functions eye inv2 det2 Subroutines linsolve_quick linsolve Functions public pure function eye (N) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N Return Value real(kind=wp),\n  dimension(N,N) public pure function inv2 (J) result(invJ) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(2,2) :: J Return Value real(kind=wp),\n  dimension(2,2) public pure function det2 (A) result(det) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(2,2) :: A Return Value real(kind=wp) Subroutines public subroutine linsolve_quick (n, a, nrhs, b, x) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=wp), intent(in), dimension(n, n) :: a integer, intent(in) :: nrhs real(kind=wp), intent(in), dimension(n, nrhs) :: b real(kind=wp), intent(out), dimension(n, nrhs) :: x public subroutine linsolve (n, a, nrhs, b, x, LU, P, toggle) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=wp), intent(in), dimension(n, n) :: a integer, intent(in) :: nrhs real(kind=wp), intent(in), dimension(n, nrhs) :: b real(kind=wp), intent(out), dimension(n, nrhs) :: x real(kind=wp), intent(inout), dimension(n, n) :: LU integer, intent(inout), dimension(n) :: P logical, intent(in) :: toggle","tags":"","title":"linalg – learn_dg","loc":"module/linalg.html"},{"text":"Uses: iso_fortran_env module~~misc~~UsesGraph module~misc misc iso_fortran_env iso_fortran_env iso_fortran_env->module~misc Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used By module~~misc~~UsedByGraph module~misc misc module~legendre legendre module~misc->module~legendre program~main main module~misc->program~main program~doubleint doubleint module~misc->program~doubleint module~legendre->program~doubleint module~assembly assembly module~legendre->module~assembly module~pascal_1d pascal_1D module~legendre->module~pascal_1d module~pascal_2d pascal_2D module~legendre->module~pascal_2d module~assembly->program~main Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Subroutines r8mat_print r8mat_print_some Subroutines public subroutine r8mat_print (m, n, a, title) R8MAT_PRINT prints an R8MAT. Arguments Type Intent Optional Attributes Name integer(kind=4) :: m integer(kind=4) :: n real(kind=8) :: a (m,n) character(len=*) :: title private subroutine r8mat_print_some (m, n, a, ilo, jlo, ihi, jhi, title) R8MAT_PRINT_SOME prints some of an R8MAT. Arguments Type Intent Optional Attributes Name integer(kind=4) :: m integer(kind=4) :: n real(kind=8) :: a (m,n) integer(kind=4) :: ilo integer(kind=4) :: jlo integer(kind=4) :: ihi integer(kind=4) :: jhi character(len=*) :: title","tags":"","title":"misc – learn_dg","loc":"module/misc.html"},{"text":"Ancestors: legendre Uses: iso_fortran_env module~~pascal_1d~~UsesGraph module~pascal_1d pascal_1D iso_fortran_env iso_fortran_env iso_fortran_env->module~pascal_1d module~legendre legendre iso_fortran_env->module~legendre module~misc misc iso_fortran_env->module~misc module~linalg linalg iso_fortran_env->module~linalg module~integration integration iso_fortran_env->module~integration module~legendre->module~pascal_1d lib_array lib_array lib_array->module~legendre lib_array->module~integration module~misc->module~legendre module~linalg->module~legendre module~integration->module~legendre Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Pascal_1D is a submodule used to generate arrays of coeffiecents used for\n developing finite element basis functions in 1D. Finite element basis\n functions are defined at internal nodes and used to iterpolate some value\n between those nodes. calculate the coeffiecents associated with a univarate Lagrangian polynomial  1, x, x&#94;2, ..., x&#94;N  In the end you end up with a group of basis functions similar to this: Module Functions assembleElementalMatrix1D getArow_ getx getAlpha1D pascal_1D_line Module Functions function assembleElementalMatrix1D (N, d1, d2, xy) result(Ie) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N integer, intent(in) :: d1 integer, intent(in) :: d2 real(kind=wp), intent(in), dimension(N) :: xy Return Value real(kind=wp),\n  dimension(N,N) pure function getArow_ (N, xi) result(row) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N real(kind=wp), intent(in) :: xi Return Value real(kind=wp),\n  dimension(N) function getx (N) result(x) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N Return Value real(kind=wp),\n  dimension(N) function getAlpha1D (N) result(alpha) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N Return Value real(kind=wp),\n  dimension(N,N) pure function pascal_1D_line (N, x) result(row) Generates the elements of an array associated with a univarate\n Lagrange polynomial. Arguments Type Intent Optional Attributes Name integer, intent(in) :: N real(kind=wp), intent(in) :: x Return Value real(kind=wp),\n  dimension(N+1)","tags":"","title":"pascal_1D – learn_dg","loc":"module/pascal_1d.html"},{"text":"Ancestors: legendre Uses: iso_fortran_env module~~pascal_2d~~UsesGraph module~pascal_2d pascal_2D iso_fortran_env iso_fortran_env iso_fortran_env->module~pascal_2d module~legendre legendre iso_fortran_env->module~legendre module~misc misc iso_fortran_env->module~misc module~linalg linalg iso_fortran_env->module~linalg module~integration integration iso_fortran_env->module~integration module~legendre->module~pascal_2d lib_array lib_array lib_array->module~legendre lib_array->module~integration module~misc->module~legendre module~linalg->module~legendre module~integration->module~legendre Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Functions getxy pascal_2D_row Module Functions assembleElementalMatrix2D getArow getAlpha2D pascal_2D_quad getJacobian Functions pure function getxy (N) result(xy) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N Return Value real(kind=wp),\n  dimension(N,2) pure function pascal_2D_row (N, x, y) result(row) Generates a row of Pascal's triangle in 2D, where rows are 0-indexed Arguments Type Intent Optional Attributes Name integer, intent(in) :: N Row number of pascal's 2D triange (0-indexed) real(kind=wp), intent(in) :: x X-value used in triange real(kind=wp), intent(in) :: y Y-Value used in triange Return Value real(kind=wp),\n  dimension(N+1) Output row of triange Module Functions function assembleElementalMatrix2D (N, d1, d2, xy) result(Ie) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N integer, intent(in) :: d1 integer, intent(in) :: d2 real(kind=wp), intent(in), dimension(N,2) :: xy Return Value real(kind=wp),\n  dimension(N,N) pure function getArow (N, xi, eta) result(row) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N real(kind=wp), intent(in) :: xi real(kind=wp), intent(in) :: eta Return Value real(kind=wp),\n  dimension(N) function getAlpha2D (N) result(alpha) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N Return Value real(kind=wp),\n  dimension(N,N) pure function pascal_2D_quad (N, x, y) result(row) Generates an array of points related to a quadrilateral using Pascal's\n triangle in 2D, where rows are 0-indexed Arguments Type Intent Optional Attributes Name integer, intent(in) :: N Order of the qaudrilateral real(kind=wp), intent(in) :: x X-coordinate of node used in calculation real(kind=wp), intent(in) :: y Y-coordinate of node used in calculation Return Value real(kind=wp),\n  dimension((N+1)**2) Output row function getJacobian (N, xi, eta, xy, alpha) result(J) Calculates the Jacobian of a quadrilateral element Arguments Type Intent Optional Attributes Name integer, intent(in) :: N Number of points in element real(kind=wp), intent(in) :: xi real(kind=wp), intent(in) :: eta real(kind=wp), intent(in), dimension(N,2) :: xy real(kind=wp), intent(in), dimension(N,N) :: alpha Return Value real(kind=wp),\n  dimension(2,2)","tags":"","title":"pascal_2D – learn_dg","loc":"module/pascal_2d.html"},{"text":"Uses: iso_fortran_env linalg misc legendre program~~doubleint~~UsesGraph program~doubleint doubleint iso_fortran_env iso_fortran_env iso_fortran_env->program~doubleint module~misc misc iso_fortran_env->module~misc module~legendre legendre iso_fortran_env->module~legendre module~linalg linalg iso_fortran_env->module~linalg module~integration integration iso_fortran_env->module~integration module~misc->program~doubleint module~misc->module~legendre module~legendre->program~doubleint module~linalg->program~doubleint module~linalg->module~legendre lib_array lib_array lib_array->module~legendre lib_array->module~integration module~integration->module~legendre Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Calls program~~doubleint~~CallsGraph program~doubleint doubleint proc~eye eye program~doubleint->proc~eye proc~r8mat_print r8mat_print program~doubleint->proc~r8mat_print proc~linsolve_quick linsolve_quick program~doubleint->proc~linsolve_quick interface~getxy getxy program~doubleint->interface~getxy assembleelementalmatrix assembleelementalmatrix program~doubleint->assembleelementalmatrix proc~r8mat_print_some r8mat_print_some proc~r8mat_print->proc~r8mat_print_some proc~linsolve linsolve proc~linsolve_quick->proc~linsolve dgetrf dgetrf proc~linsolve->dgetrf dgetrs dgetrs proc~linsolve->dgetrs Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Variables ii N xy Ie GlobalB GlobalX GlobalA elem Source Code doubleint Variables Type Attributes Name Initial integer :: ii integer, parameter :: N = 9 real(kind=wp), dimension(N,2) :: xy real(kind=wp), dimension(N,N) :: Ie real(kind=wp), dimension(15) :: GlobalB real(kind=wp), dimension(15) :: GlobalX real(kind=wp), dimension(15,15) :: GlobalA integer, dimension(2,9) :: elem Source Code program doubleint use , intrinsic :: iso_fortran_env , only : wp => real64 use :: linalg , only : linsolve_quick , eye use :: misc , only : r8mat_print use :: legendre , only : assembleElementalMatrix , getxy implicit none integer :: ii ! integer, parameter :: N = 4 integer , parameter :: N = 9 ! integer, parameter :: N = 16 real ( wp ), dimension ( N , 2 ) :: xy real ( wp ), dimension ( N , N ) :: Ie ! real(wp), dimension(10)    :: GlobalB, GlobalX ! real(wp), dimension(10,10)  :: GlobalA real ( wp ), dimension ( 15 ) :: GlobalB , GlobalX real ( wp ), dimension ( 15 , 15 ) :: GlobalA ! real(wp), dimension(16)    :: GlobalB, GlobalX ! real(wp), dimension(16,16)  :: GlobalA ! integer,  dimension(4,4)  :: elem integer , dimension ( 2 , 9 ) :: elem ! integer, dimension(1, 16) :: elem ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!! ! !!!!!! Bi-linear quads !!!!!!! ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!! ! Element connection(s) for 3 bi-linear quadrilaterals ! elem(1,:) = [1, 2, 3, 4] ! elem(2,:) = [2, 5, 6, 3] ! elem(3,:) = [5, 7, 8, 6] ! elem(4,:) = [7, 9, 10, 8] ! Get base xi/eta coordinates for bi-linear quadrilateral ! xy = getxy(N) ! Adjust for bi-linear quad ! xy(:,1) = [0._wp, 1._wp, 1.6_wp, 0._wp] ! xy(:,2) = [-1._wp, -2._wp, 5._wp, 3._wp] ! xy(:,1) = [0._wp, 0.03333_wp, 0.03333_wp, 0._wp] ! xy(:,2) = [0._wp, 0._wp, 0.03333_wp, 0.03333_wp] ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!! ! !!!!!! Bi-linear quads !!!!!!! ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!! ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! ! !!!!!! Bi-quadratic quads !!!!!!! ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! ! Element connection(s) for 2 bi-quadratic quadrilaterals elem ( 1 ,:) = [ 1 , 2 , 5 , 6 , 7 , 8 , 9 , 10 , 11 ] elem ( 2 ,:) = [ 2 , 3 , 4 , 5 , 12 , 13 , 14 , 8 , 15 ] ! Get base xi/eta coordinates for bi-quadratic quadrilateral xy = getxy ( N ) ! Adjust for bi-quadratic quad ! xy(:,1) = [0._wp, 0.03333_wp, 0.03333_wp, 0._wp, 0.016667_wp, 0.03333_wp, 0.016667_wp, 0._wp, 0.016667_wp] ! xy(:,2) = [0._wp, 0._wp, 0.03333_wp, 0.03333_wp, 0._wp, 0.016667_wp, 0.03333_wp, 0.016667_wp, 0.016667_wp] ! xy(1,:) = [-1.25_wp, -0.8_wp] ! xy(6,:) = [0.75_wp, 0.1_wp] ! xy(9,:) = [-0.25_wp, 0.25_wp] ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! ! !!!!!! Bi-quadratic quads !!!!!!! ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!! ! !!!!!! Bi-cubic quads !!!!!!! ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!! ! Element connection(s) for 2 bi-cubic quadrilaterals ! elem(1,:) = [(ii, ii=1,16)] ! Get base xi/eta coordinates for bi-cubic quadrilateral ! xy = getxy(N) ! Adjust for bi-cubic quad ! xy(:,1) = [0._wp, 0.03333_wp, 0.03333_wp, 0._wp, 0.016667_wp, 0.03333_wp, 0.016667_wp, 0._wp, 0.016667_wp] ! xy(:,2) = [0._wp, 0._wp, 0.03333_wp, 0.03333_wp, 0._wp, 0.016667_wp, 0.03333_wp, 0.016667_wp, 0.016667_wp] ! xy(1,:) = [-1.25_wp, -0.8_wp] ! xy(6,:) = [0.75_wp, 0.1_wp] ! xy(9,:) = [-0.25_wp, 0.25_wp] ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!! ! !!!!!! Bi-cubic quads !!!!!!! ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!! GlobalA = 0._wp do ii = 1 , size ( elem , 1 ) Ie = - assembleElementalMatrix ( N , 1 , 1 , xy ) - assembleElementalMatrix ( N , 2 , 2 , xy ) GlobalA ( elem ( ii ,:), elem ( ii ,:)) = GlobalA ( elem ( ii ,:), elem ( ii ,:)) + Ie enddo ! Zero-out the row corresponding with BCs and set A(ii,ii) to 1.0 forall ii ! GlobalA( [1, 4, 9, 10], : ) = 0._wp ! GlobalA( [1, 4, 9, 10], [1, 4, 9, 10] ) = eye(4) GlobalA ( [ 1 , 6 , 10 , 3 , 4 , 13 ], : ) = 0._wp GlobalA ( [ 1 , 6 , 10 , 3 , 4 , 13 ], [ 1 , 6 , 10 , 3 , 4 , 13 ] ) = eye ( 6 ) ! GlobalA( [1, 2, 7, 8, 3, 4, 11, 12], : ) = 0._wp ! GlobalA( [1, 2, 7, 8, 3, 4, 11, 12], [1, 2, 7, 8, 3, 4, 11, 12] ) = eye(8) call r8mat_print ( size ( GlobalA , 1 ), size ( GlobalA , 2 ), GlobalA , \"Global Stiffness Matrix:\" ) ! Set BCs (zero everywhere, 1 on left boundary) GlobalB = 0._wp ! GlobalB( [1, 4] ) = 1._wp GlobalB ( [ 1 , 6 , 10 ] ) = 1._wp ! GlobalB ( [1, 4, 11, 12] ) = 1._wp ! Solve linear system call linsolve_quick ( size ( GlobalA , 1 ), GlobalA , size ( GlobalB , 1 ), GlobalB , GlobalX ) call r8mat_print ( size ( GlobalX , 1 ), 1 , GlobalX , \"Solution Vector:\" ) end program doubleint","tags":"","title":"doubleint – learn_dg","loc":"program/doubleint.html"},{"text":"Uses: iso_fortran_env linalg misc io assembly program~~main~~UsesGraph program~main main iso_fortran_env iso_fortran_env iso_fortran_env->program~main module~misc misc iso_fortran_env->module~misc module~io io iso_fortran_env->module~io module~linalg linalg iso_fortran_env->module~linalg module~assembly assembly iso_fortran_env->module~assembly module~legendre legendre iso_fortran_env->module~legendre module~integration integration iso_fortran_env->module~integration module~misc->program~main module~misc->module~legendre module~io->program~main module~linalg->program~main module~linalg->module~legendre module~assembly->program~main lib_array lib_array lib_array->module~io lib_array->module~legendre lib_array->module~integration module~legendre->module~assembly module~integration->module~legendre Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Calls program~~main~~CallsGraph program~main main proc~initialize_global_mats initialize_global_mats program~main->proc~initialize_global_mats proc~write_out_solution write_out_solution program~main->proc~write_out_solution read_gmsh_file_1d read_gmsh_file_1d program~main->read_gmsh_file_1d proc~assemble assemble program~main->proc~assemble set_bcs set_bcs program~main->set_bcs proc~linsolve_quick linsolve_quick program~main->proc~linsolve_quick getie getie proc~assemble->getie proc~linsolve linsolve proc~linsolve_quick->proc~linsolve dgetrf dgetrf proc~linsolve->dgetrf dgetrs dgetrs proc~linsolve->dgetrs Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Variables diff vel num_nodes order nodes2vertex elem_conn xcoords GlobalB GlobalX GlobalA dg Source Code main Variables Type Attributes Name Initial real(kind=wp), parameter :: diff = 0.1_wp real(kind=wp), parameter :: vel = -5._wp integer :: num_nodes integer, dimension(:), allocatable :: order integer, dimension(:), allocatable :: nodes2vertex integer, dimension(:,:), allocatable :: elem_conn real(kind=wp), dimension(:), allocatable :: xcoords real(kind=wp), dimension(:), allocatable :: GlobalB real(kind=wp), dimension(:), allocatable :: GlobalX real(kind=wp), dimension(:,:), allocatable :: GlobalA logical :: dg Source Code program main use , intrinsic :: iso_fortran_env , only : wp => real64 use :: linalg , only : linsolve_quick use :: misc , only : r8mat_print use :: io , only : read_gmsh_file_1D , write_out_solution use :: assembly , only : initialize_global_mats , assemble , set_BCs implicit none real ( wp ), parameter :: diff = 0.1_wp , vel = - 5._wp integer :: num_nodes integer , dimension (:), allocatable :: order , nodes2vertex integer , dimension (:,:), allocatable :: elem_conn real ( wp ), dimension (:), allocatable :: xcoords , GlobalB , GlobalX real ( wp ), dimension (:,:), allocatable :: GlobalA logical :: dg ! dg = .true. dg = . false . call read_gmsh_file_1D ( num_nodes , order , nodes2vertex , elem_conn , xcoords , dg ) ! stop call initialize_global_mats ( num_nodes , GlobalA , GlobalB , GlobalX ) call assemble ( order , xcoords , elem_conn , GlobalA , diff , vel ) call set_BCs ( xcoords , GlobalB , GlobalA ) ! call r8mat_print(num_nodes, num_nodes, GlobalA, 'Global Stiffness matrix:') ! stop call linsolve_quick ( num_nodes , GlobalA , 1 , GlobalB , GlobalX ) ! call r8mat_print(num_nodes, 1, GlobalB, 'Global RHS:') ! call r8mat_print(num_nodes, 1, GlobalX, 'Global Solution Vector:') call write_out_solution ( num_nodes , xcoords , GlobalX ) end program main","tags":"","title":"main – learn_dg","loc":"program/main.html"},{"text":"Introduction This is an introduction","tags":"","title":"User Guide – learn_dg","loc":"page//index.html"},{"text":"Finite Element Theory Finite Element Theory Introduction Basis functions Partial Differential Equations Introduction This is the intro Basis functions Basis functions in 1D: Linear line (2 pts) Quadratic line (3 pts) Cubic line (4 pts) Basis functions in 2D: Bi-linear quadrilateral (4 pts) Bi-quadratic quadrilateral (9 pts) Bi-cubic quadrilateral (16 pts) Partial Differential Equations Example adv-diff equation  \\frac{\\partial u}{\\partial t} = \\Delta \\left( u \\right) - \\nabla \\cdot \\left( \\vec{c} u \\right)  Example","tags":"","title":"Finite Element Theory – learn_dg","loc":"page/finite-element-theory/index.html"},{"text":"Examples Examples Example Advection-Diffusion Problem Example Advection-Diffusion Problem Here goes the example","tags":"","title":"Example – learn_dg","loc":"page/finite-element-theory/01_example.html"}]}