var tipuesearch = {"pages":[{"text":"learn_dg Note Watch out, none of this code works More information can be found in the user guide . Dependencies This project uses lapack/blas as the numerical backend. Linking to these\nlibraries was no problem on Linux, but on Windows you need to build lapack/blas\nfrom scratch. First download lapack/blas from Netlib Install using cmake , and then move the libblas.dll.a and liblapack.dll.a libraries into wherever mingw expects to find them: On my machine, I use the following target directory: C:\\Development\\MinGW\\lib Documentation The documentation is built using FORD , a python package that produces documentation from source code similar to Doxygen, but specifically designed for Fortran.\nFORD takes inline documentation, prefixed by !! , and the markdown files located in docs/user_guide , and wraps them all up into an attractive website, available here .\nThe documentation website is automatically updated whenever a commit is added to the master branch. This is done through Travis-CI. To build the documentation locally run make docs This will build the documentation website in the ./docs/html directory. The organization of this project was heavily influenced by FIDASIM Developer Info Chris Coutinho","tags":"","loc":"index.html","title":" learn_dg "},{"text":"This File Depends On sourcefile~~assembly.f90~~EfferentGraph sourcefile~assembly.f90 assembly.f90 sourcefile~legendre.f90 legendre.f90 sourcefile~legendre.f90->sourcefile~assembly.f90 sourcefile~misc.f90 misc.f90 sourcefile~misc.f90->sourcefile~legendre.f90 sourcefile~linalg.f90 linalg.f90 sourcefile~linalg.f90->sourcefile~legendre.f90 sourcefile~integration.f90 integration.f90 sourcefile~integration.f90->sourcefile~legendre.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files Dependent On This One sourcefile~~assembly.f90~~AfferentGraph sourcefile~assembly.f90 assembly.f90 sourcefile~main.f90 main.f90 sourcefile~assembly.f90->sourcefile~main.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Modules assembly Source Code assembly.f90 Source Code module assembly use iso_fortran_env , only : wp => real64 use legendre , only : getIe , assembleElementalMatrix , getxy implicit none private public :: initialize_global_mats , assemble , set_BCs contains subroutine initialize_global_mats ( num_nodes , & GlobalA , & GlobalB , & GlobalX ) !* This routine initalizes the global stiffness matrix, global rhs vector, !  and global solution vector based on the number of nodes in the system ! ! * This is a bullet point ! * Another bullet point ! ! 1. This might be a number ! 2. Also a number? ! ! Some  \\LaTeX : !  \\frac{\\partial u}{\\partial t} = 0  integer , intent ( in ) :: num_nodes !! The number of nodes in the system real ( wp ), intent ( out ), dimension (:), allocatable :: GlobalB !! Global RHS Vector real ( wp ), intent ( out ), dimension (:), allocatable :: GlobalX !! Global solution vector real ( wp ), intent ( out ), dimension (:,:), allocatable :: GlobalA !! Global mass matrix allocate ( GlobalA ( num_nodes , num_nodes )) allocate ( GlobalB ( num_nodes )) allocate ( GlobalX ( num_nodes )) ! Intial Conditions GlobalA = 0._wp GlobalX = 0._wp GlobalB = 0._wp return end subroutine initialize_global_mats subroutine assemble ( order , xcoords , elem_conn , GlobalA , diff , vel ) !* Assemble the global stiffness matrix based on element connectivity integer , intent ( in ), dimension (:) :: order !! Order of element(s) integer , intent ( in ), dimension (:,:) :: elem_conn !! Element connectivity real ( wp ), intent ( in ) :: diff !! Diffusivity coefficient [m/s&#94;2] real ( wp ), intent ( in ) :: vel !! Velocity [m/s] real ( wp ), intent ( in ), dimension (:) :: xcoords !! Array of nodal coordinates real ( wp ), intent ( out ), dimension (:,:) :: GlobalA !! Global Stiffness matrix integer :: ii real ( wp ), dimension (:,:), allocatable :: Ie ! Add elemental stiffness matrices to Global Stiffness Matrix do ii = 1 , size ( order ) ! Reallocate elemental stiffness matrix allocate ( Ie ( order ( ii ) + 1 , order ( ii ) + 1 )) call getIe ( 1 , 1 , xcoords ( elem_conn ( ii ,:)), Ie ) ! call r8mat_print(order(ii)+1, order(ii)+1, Ie, 'Elemental Stiffness Matrix:') GlobalA ( elem_conn ( ii ,:), elem_conn ( ii ,:)) = & GlobalA ( elem_conn ( ii ,:), elem_conn ( ii ,:)) - diff * Ie call getIe ( 0 , 1 , xcoords ( elem_conn ( ii ,:)), Ie ) ! call r8mat_print(order(ii)+1, order(ii)+1, Ie, 'Elemental Stiffness Matrix:') GlobalA ( elem_conn ( ii ,:), elem_conn ( ii ,:)) = & GlobalA ( elem_conn ( ii ,:), elem_conn ( ii ,:)) - vel * Ie ! Deallocate elemental stiffness matrix after every loop deallocate ( Ie ) ! stop enddo ! call r8mat_print(num_nodes, num_nodes, GlobalA, 'Global Stiffness Matrix:') ! stop return end subroutine assemble subroutine set_BCs ( xcoords , GlobalB , GlobalA ) !*  Set boundary conditions in GlobalA and GlobalB using two Dirchlet !   boundaries real ( wp ), intent ( in ), dimension (:) :: xcoords !! Array of nodal coordinates real ( wp ), intent ( out ), dimension (:) :: GlobalB !! Global RHS Vector real ( wp ), intent ( out ), dimension (:,:) :: GlobalA !! Global Mass Matrix integer , dimension ( 1 ) :: iloc !! Index variable to locate node numbers based on xcoords ! Left Boundary Dirchlet BC iloc = minloc ( xcoords ) GlobalA ( iloc ,:) = 0._wp GlobalA ( iloc , iloc ) = 1._wp GlobalB ( iloc ) = 0._wp ! Right Boundary Dirchlet BC iloc = maxloc ( xcoords ) GlobalA ( iloc ,:) = 0._wp GlobalA ( iloc , iloc ) = 1._wp GlobalB ( iloc ) = 1._wp ! call r8mat_print(num_nodes, 1, GlobalB, 'Global RHS:') ! stop return end subroutine set_BCs end module assembly","tags":"","loc":"sourcefile/assembly.f90.html","title":"assembly.f90 – learn_dg"},{"text":"This File Depends On sourcefile~~doubleint.f90~~EfferentGraph sourcefile~doubleint.f90 doubleint.f90 sourcefile~linalg.f90 linalg.f90 sourcefile~linalg.f90->sourcefile~doubleint.f90 sourcefile~legendre.f90 legendre.f90 sourcefile~linalg.f90->sourcefile~legendre.f90 sourcefile~legendre.f90->sourcefile~doubleint.f90 sourcefile~misc.f90 misc.f90 sourcefile~misc.f90->sourcefile~doubleint.f90 sourcefile~misc.f90->sourcefile~legendre.f90 sourcefile~integration.f90 integration.f90 sourcefile~integration.f90->sourcefile~legendre.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Programs doubleint Source Code doubleint.f90 Source Code program doubleint use iso_fortran_env , only : wp => real64 use linalg , only : linsolve_quick , eye use misc , only : r8mat_print use legendre , only : assembleElementalMatrix , getxy implicit none integer :: ii ! integer, parameter :: N = 4 ! integer, parameter :: N = 9 integer , parameter :: N = 16 real ( wp ), dimension ( N , 2 ) :: xy real ( wp ), dimension ( N , N ) :: Ie ! real(wp), dimension(10)    :: GlobalB, GlobalX ! real(wp), dimension(10,10)  :: GlobalA ! real(wp), dimension(15)    :: GlobalB, GlobalX ! real(wp), dimension(15,15)  :: GlobalA real ( wp ), dimension ( 16 ) :: GlobalB , GlobalX real ( wp ), dimension ( 16 , 16 ) :: GlobalA ! integer,  dimension(4,4)  :: elem ! integer,  dimension(2,9)  :: elem integer , dimension ( 1 , 16 ) :: elem ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!! ! !!!!!! Bi-linear quads !!!!!!! ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!! ! Element connection(s) for 3 bi-linear quadrilaterals ! elem(1,:) = [1, 2, 3, 4] ! elem(2,:) = [2, 5, 6, 3] ! elem(3,:) = [5, 7, 8, 6] ! elem(4,:) = [7, 9, 10, 8] ! Get base xi/eta coordinates for bi-linear quadrilateral ! xy(:,1) = [-1._wp, 1._wp, 1._wp, -1._wp] ! xy(:,2) = [-1._wp, -1._wp, 1._wp, 1._wp] ! Adjust for bi-linear quad ! xy(:,1) = [0._wp, 1._wp, 1.6_wp, 0._wp] ! xy(:,2) = [-1._wp, -2._wp, 5._wp, 3._wp] ! xy(:,1) = [0._wp, 0.03333_wp, 0.03333_wp, 0._wp] ! xy(:,2) = [0._wp, 0._wp, 0.03333_wp, 0.03333_wp] ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!! ! !!!!!! Bi-linear quads !!!!!!! ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!! ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! ! !!!!!! Bi-quadratic quads !!!!!!! ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! ! Element connection(s) for 2 bi-quadratic quadrilaterals ! elem(1,:) = [1, 2, 5, 6, 7, 8, 9, 10, 11] ! elem(2,:) = [2, 3, 4, 5, 12, 13, 14, 8, 15] ! Get base xi/eta coordinates for bi-quadratic quadrilateral ! xy(:,1) = [-1._wp, 1._wp, 1._wp, -1._wp, 0._wp, 1._wp, 0._wp, -1._wp, 0._wp] ! xy(:,2) = [-1._wp, -1._wp, 1._wp, 1._wp, -1._wp, 0._wp, 1._wp, 0._wp, 0._wp] ! Adjust for bi-quadratic quad ! xy(:,1) = [0._wp, 0.03333_wp, 0.03333_wp, 0._wp, 0.016667_wp, 0.03333_wp, 0.016667_wp, 0._wp, 0.016667_wp] ! xy(:,2) = [0._wp, 0._wp, 0.03333_wp, 0.03333_wp, 0._wp, 0.016667_wp, 0.03333_wp, 0.016667_wp, 0.016667_wp] ! xy(1,:) = [-1.25_wp, -0.8_wp] ! xy(6,:) = [0.75_wp, 0.1_wp] ! xy(9,:) = [-0.25_wp, 0.25_wp] ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! ! !!!!!! Bi-quadratic quads !!!!!!! ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!! ! !!!!!! Bi-cubic quads !!!!!!! ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!! ! Element connection(s) for 2 bi-cubic quadrilaterals elem ( 1 ,:) = [( ii , ii = 1 , 16 )] ! Get base xi/eta coordinates for bi-cubic quadrilateral xy = getxy ( N ) ! Adjust for bi-cubic quad ! xy(:,1) = [0._wp, 0.03333_wp, 0.03333_wp, 0._wp, 0.016667_wp, 0.03333_wp, 0.016667_wp, 0._wp, 0.016667_wp] ! xy(:,2) = [0._wp, 0._wp, 0.03333_wp, 0.03333_wp, 0._wp, 0.016667_wp, 0.03333_wp, 0.016667_wp, 0.016667_wp] ! xy(1,:) = [-1.25_wp, -0.8_wp] ! xy(6,:) = [0.75_wp, 0.1_wp] ! xy(9,:) = [-0.25_wp, 0.25_wp] ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!! ! !!!!!! Bi-cubic quads !!!!!!! ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!! GlobalA = 0._wp do ii = 1 , size ( elem , 1 ) Ie = - assembleElementalMatrix ( N , 1 , 1 , xy ) - assembleElementalMatrix ( N , 2 , 2 , xy ) GlobalA ( elem ( ii ,:), elem ( ii ,:)) = GlobalA ( elem ( ii ,:), elem ( ii ,:)) + Ie enddo ! Zero-out the row corresponding with BCs and set A(ii,ii) to 1.0 forall ii ! GlobalA( [1, 4, 9, 10], : ) = 0._wp ! GlobalA( [1, 4, 9, 10], [1, 4, 9, 10] ) = eye(4) ! GlobalA( [1, 6, 10, 3, 4, 13], : ) = 0._wp ! GlobalA( [1, 6, 10, 3, 4, 13], [1, 6, 10, 3, 4, 13] ) = eye(6) GlobalA ( [ 1 , 2 , 7 , 8 , 3 , 4 , 11 , 12 ], : ) = 0._wp GlobalA ( [ 1 , 2 , 7 , 8 , 3 , 4 , 11 , 12 ], [ 1 , 2 , 7 , 8 , 3 , 4 , 11 , 12 ] ) = eye ( 8 ) call r8mat_print ( size ( GlobalA , 1 ), size ( GlobalA , 2 ), GlobalA , \"Global Stiffness Matrix:\" ) ! Set BCs (zero everywhere, 1 on left boundary) GlobalB = 0._wp ! GlobalB( [1, 4] ) = 1._wp ! GlobalB( [1, 6, 10] ) = 1._wp GlobalB ( [ 1 , 4 , 11 , 12 ] ) = 1._wp ! Solve linear system call linsolve_quick ( size ( GlobalA , 1 ), GlobalA , size ( GlobalB , 1 ), GlobalB , GlobalX ) call r8mat_print ( size ( GlobalX , 1 ), 1 , GlobalX , \"Solution Vector:\" ) end program doubleint","tags":"","loc":"sourcefile/doubleint.f90.html","title":"doubleint.f90 – learn_dg"},{"text":"Files Dependent On This One sourcefile~~integration.f90~~AfferentGraph sourcefile~integration.f90 integration.f90 sourcefile~legendre.f90 legendre.f90 sourcefile~integration.f90->sourcefile~legendre.f90 sourcefile~assembly.f90 assembly.f90 sourcefile~legendre.f90->sourcefile~assembly.f90 sourcefile~pascal_smod.f90 pascal_smod.f90 sourcefile~legendre.f90->sourcefile~pascal_smod.f90 sourcefile~doubleint.f90 doubleint.f90 sourcefile~legendre.f90->sourcefile~doubleint.f90 sourcefile~main.f90 main.f90 sourcefile~assembly.f90->sourcefile~main.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Modules integration Source Code integration.f90 Source Code module integration use iso_fortran_env , only : wp => real64 use lib_array , only : linspace implicit none private public :: integrate , integrate2D interface function fun2d_interf ( x , y ) result ( z ) import wp real ( wp ), intent ( in ), dimension (:,:) :: x , y real ( wp ), dimension (:,:), allocatable :: z end function subroutine sub1d_interf ( xx , yy ) import wp real ( wp ), intent ( in ), dimension (:) :: xx real ( wp ), intent ( out ), dimension (:) :: yy end subroutine sub1d_interf end interface contains subroutine integrate ( sub , a , b , result ) ! This routine uses gauss-legendre quadrature to integrate a 1D function ! Input/Output variables real ( wp ), intent ( in ) :: a , b real ( wp ), intent ( out ) :: result procedure ( sub1d_interf ) :: sub ! Local variables integer :: N real ( wp ) :: result_old , error real ( wp ), parameter :: eps = sqrt ( epsilon ( 1.0_wp )) real ( wp ), dimension (:), allocatable :: x , w , y N = 3 result = 0.0_wp error = 1.0_wp do result_old = result allocate ( x ( N ), w ( N ), y ( N )) call gaussquad ( N , x , w ) call sub ( x , y ) result = sum ( y * w ) deallocate ( x , w , y ) ! error = norm2([result, result_old]) error = sqrt (( result - result_old ) ** 2.0_wp ) ! error = abs((result-result_old)/(result_old+eps)) ! print*, N, result, error ! print*, N, result, result_old, error, eps ! Check if error is acceptable, as well as whether the loop was gone ! through at least twice (N = 3, 4, 5...) if ( ( error < eps . or . abs ( result ) < eps ) & . and . N > 5 ) then exit else N = N + 1 endif enddo return end subroutine integrate function integrate2D ( fun ) result ( out ) procedure ( fun2d_interf ) :: fun real ( wp ) :: out integer :: ii , N real ( wp ) :: out_old , error real ( wp ), parameter :: eps = epsilon ( 0 e0 ) real ( wp ), dimension (:), allocatable :: x , w real ( wp ), dimension (:,:), allocatable :: xx , yy , wx , wy , out_spread ! Adaptive integration based on 2D Gauss-Legendre Quadrature ii = 1 ! Iteration number N = 2 ! Initial number of points to use error = 1._wp ! Initial estimate of error do ! Allocate x (positions) and w (weights) based on roots of the Legendre ! polynomial of order 'N' allocate ( x ( N ), w ( N )) allocate ( xx ( N , N ), yy ( N , N )) allocate ( wx ( N , N ), wy ( N , N )) allocate ( out_spread ( N , N )) call gaussquad ( N , x , w ) ! Copy the 'x' array along both the x and y axes xx = spread ( x , dim = 1 , ncopies = N ) yy = spread ( x , dim = 2 , ncopies = N ) ! Copy the weights along both the x and y axes as well wx = spread ( w , dim = 1 , ncopies = N ) wy = spread ( w , dim = 2 , ncopies = N ) ! Calculate the function at the xx and yy nodes, and multiply the result ! with the weights: wx and wy out_spread = fun ( xx , yy ) * wx * wy ! Sum up the resulting array into a single scalar output out = sum ( reshape ( out_spread , [ N * N , 1 ] )) ! print*, out ! Set error if ii > 1 if ( ii > 1 ) then error = out - out_old else error = 1._wp endif ! Deallocate all arrays no longer needed. They will change size in each ! iteration anyway deallocate ( x , w , xx , yy , wx , wy , out_spread ) ! If iteration counter is more than 1 then check exit criteria if ( norm2 ( [ error ] ) <= eps ) then ! print'(a,i3,a,e13.5)', 'Fun integrated in ', N, & !                        ' iterations. Error = ', error exit else out_old = out ii = ii + 1 N = N + 1 endif enddo return end function subroutine gaussquad ( N , x , w ) integer , intent ( in ) :: N real ( wp ), intent ( out ), dimension ( N ) :: x , w select case ( N ) case ( 1 ) x = [ 0._wp ] w = [ 2._wp ] case ( 2 ) x = [ - 0.5773502691896257_wp , & 0.5773502691896257_wp ] w = [ 1._wp , & 1._wp ] case ( 3 ) x = [ - 0.7745966692414834_wp , & 0._wp , & 0.7745966692414834_wp ] w = [ 0.5555555555555556_wp , & 0.8888888888888888_wp , & 0.5555555555555556_wp ] case ( 4 ) x = [ - 0.8611363115940526_wp , & - 0.3399810435848563_wp , & 0.3399810435848563_wp , & 0.8611363115940526_wp ] w = [ 0.3478548451374538_wp , & 0.6521451548625461_wp , & 0.6521451548625461_wp , & 0.3478548451374538_wp ] case ( 5 ) x = [ - 0.9061798459386640_wp , & - 0.5384693101056831_wp , & 0._wp , & 0.5384693101056831_wp , & 0.9061798459386640_wp ] w = [ 0.2369268850561891_wp , & 0.4786286704993665_wp , & 0.5688888888888889_wp , & 0.4786286704993665_wp , & 0.2369268850561891_wp ] case default ! call lgwt(-1._wp, 1._wp, N, x, w) ! call cgwt(N, x, w) call gaussquad_rosetta ( N , x , w ) end select return end subroutine gaussquad subroutine lgwt ( a , b , num_pts , x , w ) !*  This function is a fortran90 port of the matlab function, lgwt.m !   The source code of lgwt.m was originally found at: !     http://www.mathworks.com/matlabcentral/fileexchange/4540 ! Variables in/out integer , intent ( in ) :: num_pts real ( wp ), intent ( in ) :: a , b real ( wp ), intent ( out ), dimension (:) :: x , w ! Local variables integer :: ii , jj , N , N1 , N2 ! real(wp), parameter:: eps=sqrt(epsilon(1.0_wp)) real ( wp ), parameter :: eps = 1 d - 10 real ( wp ), dimension (:), allocatable :: xu , array1 , y , y0 , Lpp real ( wp ), dimension (:, :), allocatable :: L , Lp real ( wp ), parameter :: pi = 4.0_wp * datan ( 1.0_wp ) N = num_pts - 1 N1 = N + 1 N2 = N + 2 ! Allocate and initialize arrays allocate ( xu ( N1 ), array1 ( N1 ), y ( N1 ), y0 ( N1 )) allocate ( L ( N1 , N2 ), Lp ( N1 , N2 ), Lpp ( N1 )) L = 0.0_wp Lp = 0.0_wp call linspace ( - 1.0_wp , 1.0_wp , xu ) array1 = [ ( ii , ii = 0 , N ) ] ! Initial guess of the roots of the Legendre polynomial of order N y = cos (( 2.0_wp * real ( array1 , wp ) + 1.0_wp ) * & pi / ( 2.0_wp * real ( N , wp ) + 2.0_wp )) + & ( 0.27_wp / real ( N1 , wp )) * sin ( pi * xu * real ( N , wp ) / real ( N2 , wp )) y0 = 2.0_wp do L (:, 1 ) = 1.0_wp Lp (:, 1 ) = 0.0_wp L (:, 2 ) = y Lp (:, 2 ) = 1.0_wp do jj = 2 , N1 L (:, jj + 1 ) = ( ( 2.0_wp * real ( jj , wp ) - 1.0_wp ) * y * L (:, jj ) - & real ( jj - 1 , wp ) * L (:, jj - 1 )) / real ( jj , wp ) enddo Lpp = real ( N2 , wp ) * ( L (:, N1 ) - y * L (:, N2 )) / ( 1.0_wp - y ** 2.0_wp ) y0 = y y = y0 - L (:, N2 ) / Lpp if ( norm2 ( y - y0 ) < eps ) then exit endif enddo x = ( a * ( 1.0_wp - y ) + b * ( 1.0_wp + y ) ) / 2.0_wp w = ( b - a ) / (( 1.0_wp - y ** 2.0_wp ) * Lpp ** 2.0_wp ) * & ( real ( N2 , wp ) / real ( N1 , wp )) ** 2.0_wp return end subroutine lgwt subroutine cgwt ( num_pts , x , w ) ! This function  determines the points and weights associated with Chebyshev-Gauss quadrature ! Variables in/out integer , intent ( in ) :: num_pts real ( wp ), intent ( out ), dimension (:) :: x , w ! Local variables integer :: ii real ( wp ), parameter :: pi = 4._wp * datan ( 1._wp ) x = cos ( ( real ( 2 * [( ii , ii = 1 , num_pts )] - 1 , wp ) ) / real ( 2 * num_pts , wp ) * pi ) w = pi / real ( num_pts , wp ) / (( 1.0_wp - x ** 2._wp ) ** ( - 0.5_wp )) ! print*, x ! print*, w ! stop return end subroutine cgwt subroutine gaussquad_rosetta ( n , r1 , r2 ) ! This code was originally found at the following website: !  http://rosettacode.org/wiki/Numerical_integration/Gauss-Legendre_Quadrature#Fortran integer , intent ( in ) :: n real ( wp ), intent ( out ) :: r1 ( n ), r2 ( n ) integer :: k real ( wp ), parameter :: pi = 4._wp * atan ( 1._wp ) real ( wp ) :: x , f , df , dx integer :: i , iter real ( wp ), allocatable :: p0 (:), p1 (:), tmp (:) p0 = [ 1._wp ] p1 = [ 1._wp , 0._wp ] do k = 2 , n tmp = (( 2 * k - 1 ) * [ p1 , 0._wp ] - ( k - 1 ) * [ 0._wp , 0._wp , p0 ]) / k p0 = p1 ; p1 = tmp enddo do i = 1 , n x = cos ( pi * ( i - 0.25_wp ) / ( n + 0.5_wp )) do iter = 1 , 10 f = p1 ( 1 ); df = 0._wp do k = 2 , size ( p1 ) df = f + x * df f = p1 ( k ) + x * f enddo dx = f / df x = x - dx if ( abs ( dx ) < 10 * epsilon ( dx )) exit enddo r1 ( i ) = x r2 ( i ) = 2 / (( 1 - x ** 2 ) * df ** 2 ) enddo return end subroutine gaussquad_rosetta end module integration","tags":"","loc":"sourcefile/integration.f90.html","title":"integration.f90 – learn_dg"},{"text":"Files Dependent On This One sourcefile~~io.f90~~AfferentGraph sourcefile~io.f90 io.f90 sourcefile~main.f90 main.f90 sourcefile~io.f90->sourcefile~main.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Modules io Source Code io.f90 Source Code module io use iso_fortran_env , only : wp => real64 use lib_array , only : linspace implicit none private public :: read_gmsh_file_1D , & write_out_solution contains subroutine read_gmsh_file_1D ( num_nodes , & order , & nodes2vertex , & elem_conn , & xcoords , & dg ) ! !*  Reads the input mesh file (gmsh .msh format) and returns the number of !   nodes, the order of each element, element connectivity, and the !   coordinates of the nodes (nx1 for 1D, nx2 for 2D, etc.) integer , intent ( out ) :: num_nodes !! Number of nodes in mesh integer , intent ( out ), dimension (:), allocatable :: order !! Array containing order of each element integer , intent ( out ), dimension (:), allocatable :: nodes2vertex !! Array containing node to vertex connectivity (only interesting w.r.t discontinuous galerkin) integer , intent ( out ), dimension (:,:), allocatable :: elem_conn !! Array containing node connectivity of each element real ( wp ), intent ( out ), dimension (:), allocatable :: xcoords !! Array containing node coordinates logical , intent ( in ) :: dg !! Logical switch is continuous galerkin or discontinuous galerkin integer :: ii , ios , vertex , num_elements , num_vertexes , d_int integer , dimension (:,:), allocatable :: vertex_conn real ( wp ) :: d_real character ( 80 ) :: filename character ( 80 ) :: blank_string call get_command_argument ( 1 , filename ) ! print*, filename open ( unit = 21 , file = filename , iostat = ios , status = \"old\" , action = \"read\" ) if ( ios /= 0 ) then print * , filename print * , ios stop \"Error opening file \" endif ! Read initial header information - assuming file is in the correct format do read ( 21 , * ) blank_string if ( trim ( blank_string ) == '$Nodes' ) exit enddo ! Read number of nodes read ( 21 , * ) num_vertexes allocate ( xcoords ( num_vertexes )) if ( . not . dg ) then num_nodes = num_vertexes else num_nodes = 2 * num_vertexes - 2 endif ! Read coordinate information for each vertex do ii = 1 , num_vertexes read ( 21 , * ) d_int , xcoords ( ii ), d_real , d_real enddo allocate ( nodes2vertex ( num_nodes )) nodes2vertex = 0 if ( dg ) then vertex = 1 do ii = 1 , num_nodes nodes2vertex ( ii ) = vertex if ( ii == 1 . or . ii == num_nodes ) then vertex = vertex + 1 elseif ( mod ( ii , 2 ) == 0 ) then vertex = vertex + 1 endif enddo else nodes2vertex = [( ii , ii = 1 , num_nodes )] endif do ii = 1 , num_nodes print * , ii , nodes2vertex ( ii ), xcoords ( nodes2vertex ( ii )) enddo print * , ! stop ! Two dummy lines : !   $EndNodes !   $Elements read ( 21 , * ) read ( 21 , * ) read ( 21 , * ) num_elements num_elements = num_elements - 2 allocate ( order ( num_elements )) allocate ( elem_conn ( num_elements , 2 )) allocate ( vertex_conn ( num_elements , 2 )) ! Initialize all elements as first order linear elements order = 1 ! Two dummy lines - Associated with 'point' elements read ( 21 , * ) read ( 21 , * ) do ii = 1 , num_elements read ( 21 , * ) d_int , d_int , d_int , d_int , d_int , vertex_conn ( ii , 1 : 2 ) ! print*, pack(vertex_conn, vertex_conn == nodes2vertex) enddo ! print*, pack([( ii, ii = 1, num_nodes )], & !         nodes2vertex == nodes2vertex(3) & !         .or. nodes2vertex == nodes2vertex(5)) ! stop if ( . not . dg ) then elem_conn = vertex_conn else do ii = 1 , num_elements ! elem_conn(ii,:) = pack([( ii, ii = 1, num_nodes )], & !   nodes2vertex == vertex_conn(ii,1)) ! print*, loc(2._wp) ! print*, loc(nodes2vertex == vertex_conn(ii,2)) print * , order ( ii ), vertex_conn ( ii ,:), elem_conn ( ii ,:) print * , enddo endif print * , do ii = 1 , size ( xcoords ) print * , xcoords ( ii ) enddo print * , close ( unit = 21 , iostat = ios ) if ( ios /= 0 ) stop \"Error closing file unit 21\" return end subroutine read_gmsh_file_1D subroutine write_out_solution ( num_nodes , xcoords , GlobalX ) integer , intent ( in ) :: num_nodes real ( wp ), intent ( in ), dimension (:) :: xcoords , GlobalX integer :: ii , ios open ( unit = 21 , file = 'data.out' , iostat = ios , status = \"replace\" , action = \"write\" ) if ( ios /= 0 ) then print * , ios stop \"Error opening file data.out\" endif do ii = 1 , num_nodes write ( 21 , * ) xcoords ( ii ), GlobalX ( ii ) enddo close ( unit = 21 , iostat = ios ) if ( ios /= 0 ) then print * , ios stop \"Error closing file unit data.out\" endif return end subroutine write_out_solution end module io","tags":"","loc":"sourcefile/io.f90.html","title":"io.f90 – learn_dg"},{"text":"This File Depends On sourcefile~~legendre.f90~~EfferentGraph sourcefile~legendre.f90 legendre.f90 sourcefile~misc.f90 misc.f90 sourcefile~misc.f90->sourcefile~legendre.f90 sourcefile~linalg.f90 linalg.f90 sourcefile~linalg.f90->sourcefile~legendre.f90 sourcefile~integration.f90 integration.f90 sourcefile~integration.f90->sourcefile~legendre.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files Dependent On This One sourcefile~~legendre.f90~~AfferentGraph sourcefile~legendre.f90 legendre.f90 sourcefile~assembly.f90 assembly.f90 sourcefile~legendre.f90->sourcefile~assembly.f90 sourcefile~pascal_smod.f90 pascal_smod.f90 sourcefile~legendre.f90->sourcefile~pascal_smod.f90 sourcefile~doubleint.f90 doubleint.f90 sourcefile~legendre.f90->sourcefile~doubleint.f90 sourcefile~main.f90 main.f90 sourcefile~assembly.f90->sourcefile~main.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Modules legendre Source Code legendre.f90 Source Code module legendre use iso_fortran_env , only : wp => real64 use misc , only : r8mat_print use lib_array , only : linspace use integration , only : integrate , integrate2D use linalg , only : linsolve_quick , linsolve , inv2 , det2 , eye implicit none private public :: getIe , assembleElementalMatrix , getxy ! public :: pascal ! interface pascal !    module procedure pascal_1D_line !    module procedure pascal_2D_quad ! end interface pascal public :: pascal interface pascal module function pascal_1D_line ( N , x ) result ( row ) integer , intent ( in ) :: N real ( wp ), intent ( in ) :: x real ( wp ), dimension ( N + 1 ) :: row end function pascal_1D_line module function pascal_2D_quad ( N , x , y ) result ( row ) integer , intent ( in ) :: N real ( wp ), intent ( in ) :: x real ( wp ), intent ( in ) :: y real ( wp ), dimension ( N + 1 ) :: row end function pascal_2D_quad end interface pascal contains ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! ! !!!!!! Elemental Matrix Routines 1-D !!!!!!! ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! subroutine getIe ( dii , djj , xcoords , Ie ) !*  Routine to calculate the elemental mass/stiffness matrix based on the !   derivatives of the basis functions. ! !   Currently only zero-th and first order derivatives are supported. Second !   order derivatives need to be reduced to first order derivatives in the !   problem formulation using Green's Theorem integer , intent ( in ) :: dii !! Derivative of the first basis function integer , intent ( in ) :: djj !! Derivative of the second basis function real ( wp ), intent ( in ), dimension (:) :: xcoords !! Coordinates of the 1D line element real ( wp ), intent ( out ), dimension (:,:) :: Ie !! Output elemental matrix integer :: ii , jj , order order = size ( xcoords ) - 1 do ii = 1 , size ( xcoords ) Ie ( ii , :) = [( integrate_basis_1d_Ie ( order , ii , jj , dii , djj , xcoords ), jj = 1 , order + 1 )] enddo return end subroutine getIe function integrate_basis_1d_Ie ( N , ii , jj , dii , djj , xcoords ) result ( integral ) integer , intent ( in ) :: N , ii , jj , dii , djj real ( wp ), intent ( in ), dimension (:) :: xcoords real ( wp ) :: integral integer :: order , basis_num1 , basis_num2 real ( wp ), dimension (:, :), allocatable :: Vinv order = N basis_num1 = ii basis_num2 = jj allocate ( Vinv ( order + 1 , order + 1 )) call vandermonde ( order + 1 , Vinv ) ! Check to make sure xcoords is an array of size (N+1) if ( size ( xcoords ) /= order + 1 ) then write ( * , * ) 'The shape of `xcoords` is outside the acceptable range for a' write ( * , * ) '1D basis function.' write ( * , * ) 'Shape(xcoords) should be [' , 2 , order + 1 , '], not ' , shape ( xcoords ) endif call integrate ( local_wrapper , - 1.0_wp , 1.0_wp , integral ) return contains subroutine XorJ ( s , dx , out ) integer , intent ( in ) :: dx real ( wp ), intent ( in ), dimension (:) :: s real ( wp ), intent ( out ), dimension (:) :: out integer :: ii out = 0.0_wp do ii = 1 , size ( xcoords ) out = out + basis_1D ( s , Vinv (:, ii ), dx ) * xcoords ( ii ) enddo end subroutine XorJ subroutine local_wrapper ( s , y ) real ( wp ), intent ( in ), dimension (:) :: s real ( wp ), intent ( out ), dimension (:) :: y real ( wp ), dimension (:), allocatable :: J allocate ( J ( size ( s ))) call XorJ ( s , 1 , J ) ! write(*,*) dii, djj y = 1.0_wp ! Here we have to be careful because J is not always needed in the first ! two function calls. Instead of using if statements, we can use an exponent so that when dx_ == 0, J is 1 y = y * basis_1D ( s , Vinv (:, basis_num1 ), dii ) / ( J ** real ( dii , wp )) y = y * basis_1D ( s , Vinv (:, basis_num2 ), djj ) / ( J ** real ( djj , wp )) y = y * J deallocate ( J ) return end subroutine local_wrapper end function integrate_basis_1d_Ie function basis_1D ( x , alpha , dx ) result ( y ) ! Input/output variables integer , intent ( in ) :: dx real ( wp ), intent ( in ), dimension (:) :: x real ( wp ), intent ( in ), dimension (:) :: alpha real ( wp ), dimension (:), allocatable :: y , yx ! Local variables integer :: ii , N allocate ( y ( size ( x )), yx ( size ( x ))) N = size ( alpha ) y = 0._wp do ii = 1 + dx , N if ( dx == 0 ) then yx = alpha ( ii ) * x ** real ( ii - 1 , wp ) else ! Hoping for the best that dx == 1 yx = real ( ii - 1 , wp ) * alpha ( ii ) * ( x ) ** ( real ( ii - 1 - dx , wp )) endif y = y + yx enddo return end function basis_1D subroutine vandermonde ( n , Vinv ) integer :: ii , jj integer :: n real ( wp ), dimension ( n ) :: x real ( wp ), dimension (( n ) ** 2 ) :: V_flat real ( wp ), dimension ( n , n ) :: V , Vinv , eye call linspace ( - 1._wp , 1._wp , x ) V_flat = [( [( [ x ( ii ) ** real ( jj - 1 , wp )], ii = 1 , n )], jj = 1 , n )] V = reshape ([ V_flat ], [ n , n ]) ! call r8mat_print(n, n, V, 'Original V Matrix: ') eye = 0._wp do ii = 1 , n eye ( ii , ii ) = 1._wp enddo call linsolve_quick ( n , V , n , eye , Vinv ) return end subroutine vandermonde ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! ! !!!!!! Elemental Matrix Routines 2-D !!!!!!! ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! pure function getxy ( N ) result ( xy ) integer , intent ( in ) :: N real ( wp ), dimension ( N , 2 ) :: xy ! Keep a copy of 1/3 handy so no need to retype it all the time real ( wp ), parameter :: zero = 0._wp real ( wp ), parameter :: one = 1._wp real ( wp ), parameter :: third = 1._wp / 3._wp if ( N == 4 ) then xy ( 1 ,:) = [ - one , - one ] ! Node 1 xy ( 2 ,:) = [ one , - one ] ! Node 2 xy ( 3 ,:) = [ one , one ] ! Node 3 xy ( 4 ,:) = [ - one , one ] ! Node 4 elseif ( N == 9 ) then xy ( 1 ,:) = [ - one , - one ] ! Node 1 xy ( 2 ,:) = [ one , - one ] ! Node 2 xy ( 3 ,:) = [ one , one ] ! Node 3 xy ( 4 ,:) = [ - one , one ] ! Node 4 xy ( 5 ,:) = [ zero , - one ] ! Node 5 xy ( 6 ,:) = [ one , zero ] ! Node 6 xy ( 7 ,:) = [ zero , one ] ! Node 7 xy ( 8 ,:) = [ - one , zero ] ! Node 8 xy ( 9 ,:) = [ zero , zero ] ! Node 9 elseif ( N == 16 ) then xy ( 1 ,:) = [ - one , - one ] ! Node 1 xy ( 2 ,:) = [ one , - one ] ! Node 2 xy ( 3 ,:) = [ one , one ] ! Node 3 xy ( 4 ,:) = [ - one , one ] ! Node 4 xy ( 5 ,:) = [ - third , - one ] ! Node 5 xy ( 6 ,:) = [ third , - one ] ! Node 6 xy ( 7 ,:) = [ one , - third ] ! Node 7 xy ( 8 ,:) = [ one , third ] ! Node 8 xy ( 9 ,:) = [ third , one ] ! Node 9 xy ( 10 ,:) = [ - third , one ] ! Node 10 xy ( 11 ,:) = [ - one , third ] ! Node 11 xy ( 12 ,:) = [ - one , - third ] ! Node 12 xy ( 13 ,:) = [ - third , - third ] ! Node 13 xy ( 14 ,:) = [ third , - third ] ! Node 14 xy ( 15 ,:) = [ third , third ] ! Node 15 xy ( 16 ,:) = [ - third , third ] ! Node 16 ! else ! !   print*, \"Unsupported number of nodes selected: \", N !   stop \"Number of nodes must be either 4, 9, or 16\" endif return end function getxy function getArow ( N , xi , eta ) result ( row ) integer , intent ( in ) :: N real ( wp ), intent ( in ) :: xi , eta real ( wp ), dimension ( N ) :: row if ( N == 4 ) then row = pascal ( 1 , xi , eta ) elseif ( N == 9 ) then ! row = [1._wp, & !       xi, eta, & !       xi**2._wp, xi*eta, eta**2._wp, & !       xi**2._wp * eta, xi * eta**2._wp, & !       xi**2._wp * eta**2._wp] row = pascal ( 2 , xi , eta ) elseif ( N == 16 ) then ! row = [1._wp, & !       xi, eta, & !       xi**2._wp, xi*eta, eta**2._wp, & !       xi**3._wp, xi**2._wp * eta, xi * eta**2._wp, eta**3._wp, & !       xi**3._wp * eta, xi**2._wp * eta**2._wp, xi * eta**3._wp, & !       xi**3._wp * eta**2._wp, xi**2._wp * eta**3._wp, & !       xi**3._wp * eta**3._wp] row = pascal ( 3 , xi , eta ) ! else ! !   print*, \"Unsupported number of nodes selected: \", N !   stop \"Number of nodes must be either 4, 9, or 16\" endif return end function getArow function getAlpha ( N ) result ( alpha ) integer , intent ( in ) :: N real ( wp ), dimension ( N , N ) :: alpha integer :: ii real ( wp ), dimension ( N , N ) :: A , B A = getA ( N ) B = eye ( N ) call linsolve_quick ( N , A , N , B , alpha ) return contains function getA ( N ) result ( A ) integer , intent ( in ) :: N real ( wp ), dimension ( N , N ) :: A integer :: ii real ( wp ), dimension ( N , 2 ) :: xy xy = getxy ( N ) do ii = 1 , N A ( ii ,:) = getArow ( N , xy ( ii , 1 ), xy ( ii , 2 )) enddo return end function getA end function getAlpha function getJacobian ( N , xi , eta , xy , alpha ) result ( J ) !* ! Calculates the Jacobian of a quadrilateral element ! ! The Jacobian of an element is defined as: !  \\textbf{J} = \\textbf{P} \\textbf{X}  ! ! Where: !  \\textbf{P} = \\left[ \\begin{array}{cc} !     \\frac{\\partial H_1}{\\partial \\xi} & \\frac{\\partial H_2}{\\partial \\xi} \\\\ !     \\frac{\\partial H_1}{\\partial \\eta} & \\frac{\\partial H_2}{\\partial \\eta} \\end{array} !       \\cdots !     \\begin{array}{cc} !     \\frac{\\partial H_{N-1}}{\\partial \\xi} & \\frac{\\partial H_{N}}{\\partial \\xi} \\\\ !     \\frac{\\partial H_{N-1}}{\\partial \\eta} & \\frac{\\partial H_{N}}{\\partial \\eta} \\end{array} ! \\right] ! !  X = \\left[ \\begin{array}{rcl} !       x_1 & & y_1 \\\\ !       x_2 & & y_2 \\\\ !       & \\vdots & \\\\ !       x_{N-1} & & y_{N-1} \\\\ !       x_N & & y_N \\\\ !   \\end{array} \\right] ! ! @note The following below doesn't work with MathJax and is being rendered incorrectly for some reason: ! !  X = \\left[ \\begin{array}{c} !      \\begin{array}{cc} !        x_1 & y_1 \\\\ !        x_2 & y_2 !      \\end{array} \\\\ !      \\vdots \\\\ !      \\begin{array}{cc} !        x_{N-1} & y_{N-1} \\\\ !        x_N & y_N !      \\end{array} \\\\ !    \\end{array} \\right] ! ! *  H_i  : Basis function i ! *  x_i  : X-coordinate of node i ! *  y_i  : Y-coordinate of node i integer , intent ( in ) :: N !! Number of points in element real ( wp ), intent ( in ) :: xi !! real ( wp ), intent ( in ) :: eta !! real ( wp ), dimension ( N , 2 ), intent ( in ) :: xy !! real ( wp ), dimension ( N , N ), intent ( in ) :: alpha !! real ( wp ), dimension ( 2 , 2 ) :: J !! integer :: ii !! real ( wp ), parameter :: eps = epsilon ( 0 e0 ) real ( wp ), dimension ( 2 , N ) :: P !! Array of real ( wp ), dimension ( N ) :: x !! Row in element coefficient matrix ! P is a matrix containing derivatives of each basis function at (xi,eta) ! P = [dN_1/dxi, dN_2/dxi, dN_3/dxi, ... !      dN_1/deta, dN_2/deta, dN_3/deta, ...] do ii = 1 , N x = alpha (:, ii ) P ( 1 , ii ) = dot_product ( x , getArow ( N , xi + eps , eta )) - & dot_product ( x , getArow ( N , xi - eps , eta )) P ( 2 , ii ) = dot_product ( x , getArow ( N , xi , eta + eps )) - & dot_product ( x , getArow ( N , xi , eta - eps )) enddo P = P / ( 2._wp * eps ) J = matmul ( P , xy ) return end function getJacobian function assembleElementalMatrix ( N , d1 , d2 , xy ) result ( Ie ) ! Dummy variables integer , intent ( in ) :: N , d1 , d2 real ( wp ), dimension ( N , 2 ), intent ( in ) :: xy real ( wp ), dimension ( N , N ) :: Ie ! Local variables integer :: N1 , N2 real ( wp ), dimension ( N , N ) :: alpha ! Get the coefficients of the basis functions (alpha). Both bi-linear (N=4) ! and bi-quadratic (N=9) quadrilaterals are supported. alpha = getAlpha ( N ) Ie = 0._wp do N1 = 1 , N do N2 = 1 , N ! fun is now implicitly defined using the following: N1, N2, d1, and d2 Ie ( N1 , N2 ) = Ie ( N1 , N2 ) + integrate2D ( fun ) enddo enddo contains function fun ( xi , eta ) result ( out ) ! Dummy variables real ( wp ), dimension (:,:), intent ( in ) :: xi , eta real ( wp ), dimension (:,:), allocatable :: out ! Local variables integer :: ii , jj , num_pts real ( wp ), parameter :: eps = epsilon ( 0 e0 ) real ( wp ) :: fun1 , fun2 real ( wp ), dimension ( 2 ) :: dfun1 , dfun2 real ( wp ) :: detJ real ( wp ), dimension ( 2 , 2 ) :: J , invJ ! Initialize function output. Actual number of pts is num_pts*num_pts, ! because the meshgrid goes in both x and y directions. Only need one. num_pts = size ( xi , 1 ) allocate ( out ( num_pts , num_pts )) out = 0._wp do ii = 1 , num_pts do jj = 1 , num_pts ! Calculate Jacobian, inverse Jacobian, and determinant of finite ! element at (xi,eta) J = getJacobian ( N , xi ( ii , jj ), eta ( ii , jj ), xy , alpha ) invJ = inv2 ( J ) detJ = det2 ( J ) ! If fun1 is just N_i, use dot_product to determine N_i if ( d1 == 0 ) then fun1 = dot_product ( alpha (:, N1 ), getArow ( N , xi ( ii , jj ), eta ( ii , jj ))) else ! If fun1 contains a derivative, need to calc N_i,xi and N_i,eta dfun1 ( 1 ) = ( & dot_product ( alpha (:, N1 ), getArow ( N , xi ( ii , jj ) + eps , eta ( ii , jj ))) - & dot_product ( alpha (:, N1 ), getArow ( N , xi ( ii , jj ) - eps , eta ( ii , jj ))) & ) / ( 2._wp * eps ) dfun1 ( 2 ) = ( & dot_product ( alpha (:, N1 ), getArow ( N , xi ( ii , jj ), eta ( ii , jj ) + eps )) - & dot_product ( alpha (:, N1 ), getArow ( N , xi ( ii , jj ), eta ( ii , jj ) - eps )) & ) / ( 2._wp * eps ) ! N_i,x = dxi/dx * N_i,xi + deta/dx * N_i,eta fun1 = dot_product ( invJ ( d1 ,:), dfun1 ) endif ! If fun2 is just N_i, use dot_product to determine N_i if ( d2 == 0 ) then fun2 = dot_product ( alpha (:, N2 ), getArow ( N , xi ( ii , jj ), eta ( ii , jj ))) else ! If fun2 contains a derivative, need to calc N_i,xi and N_i,eta dfun2 ( 1 ) = ( & dot_product ( alpha (:, N2 ), & getArow ( N , xi ( ii , jj ) + eps , eta ( ii , jj ))) - & dot_product ( alpha (:, N2 ), & getArow ( N , xi ( ii , jj ) - eps , eta ( ii , jj ))) & ) / ( 2._wp * eps ) dfun2 ( 2 ) = ( & dot_product ( alpha (:, N2 ), getArow ( N , xi ( ii , jj ), eta ( ii , jj ) + eps )) - & dot_product ( alpha (:, N2 ), getArow ( N , xi ( ii , jj ), eta ( ii , jj ) - eps )) & ) / ( 2._wp * eps ) ! N_i,y = dxi/dy * N_i,xi + deta/dy * N_i,eta fun2 = dot_product ( invJ ( d2 ,:), dfun2 ) endif out ( ii , jj ) = fun1 * fun2 * detJ enddo enddo return end function fun end function assembleElementalMatrix end module legendre","tags":"","loc":"sourcefile/legendre.f90.html","title":"legendre.f90 – learn_dg"},{"text":"Files Dependent On This One sourcefile~~linalg.f90~~AfferentGraph sourcefile~linalg.f90 linalg.f90 sourcefile~legendre.f90 legendre.f90 sourcefile~linalg.f90->sourcefile~legendre.f90 sourcefile~main.f90 main.f90 sourcefile~linalg.f90->sourcefile~main.f90 sourcefile~doubleint.f90 doubleint.f90 sourcefile~linalg.f90->sourcefile~doubleint.f90 sourcefile~legendre.f90->sourcefile~doubleint.f90 sourcefile~assembly.f90 assembly.f90 sourcefile~legendre.f90->sourcefile~assembly.f90 sourcefile~pascal_smod.f90 pascal_smod.f90 sourcefile~legendre.f90->sourcefile~pascal_smod.f90 sourcefile~assembly.f90->sourcefile~main.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Modules linalg Source Code linalg.f90 Source Code module linalg use iso_fortran_env , only : wp => real64 implicit none private public :: linsolve_quick , linsolve , inv2 , det2 , eye contains pure function eye ( N ) integer , intent ( in ) :: N real ( wp ), dimension ( N , N ) :: eye integer :: ii eye = 0._wp ; forall ( ii = 1 : N ) eye ( ii , ii ) = 1._wp return end function eye pure function inv2 ( J ) result ( invJ ) real ( wp ), dimension ( 2 , 2 ), intent ( in ) :: J real ( wp ), dimension ( 2 , 2 ) :: invJ invJ = reshape ( [ J ( 2 , 2 ), - J ( 2 , 1 ), - J ( 1 , 2 ), J ( 1 , 1 )], [ 2 , 2 ] ) invJ = invJ / det2 ( J ) return end function inv2 pure function det2 ( A ) result ( det ) ! Computes the determinant of a 2x2 matrix real ( wp ), dimension ( 2 , 2 ), intent ( in ) :: A real ( wp ) :: det det = A ( 1 , 1 ) * A ( 2 , 2 ) - A ( 1 , 2 ) * A ( 2 , 1 ) return end function det2 subroutine linsolve_quick ( n , a , nrhs , b , x ) ! Quick wrapper around linsolve integer , intent ( in ) :: n , nrhs real ( wp ), intent ( in ), dimension ( n , n ) :: a real ( wp ), intent ( in ), dimension ( n , nrhs ) :: b real ( wp ), intent ( out ), dimension ( n , nrhs ) :: x integer , dimension ( n ) :: P real ( wp ), dimension ( n , n ) :: LU call linsolve ( n , a , nrhs , b , x , LU , P , . False .) return end subroutine linsolve_quick subroutine linsolve ( n , a , nrhs , b , x , LU , P , toggle ) ! This routine is a wrapper dgesv, splitting it into its two primary ! components: !             dgetrf - Decomposes A into P*L*U !             dgetrs - Uses P*L*U to solve for x (Ax=b => (P*L*U)x=b) ! ! Splitting these two up like this allows you to save the decomposed ! version of 'a' so that you don't have to do it again. If 'toggle' is ! equal to true, then the decomposition has already occured and LU can be ! trusted - OK to skip dgetrf ! Dummy variables integer , intent ( in ) :: n , nrhs integer , intent ( inout ), dimension ( n ) :: P real ( wp ), intent ( in ), dimension ( n , nrhs ) :: b real ( wp ), intent ( in ), dimension ( n , n ) :: a real ( wp ), intent ( out ), dimension ( n , nrhs ) :: x real ( wp ), intent ( inout ), dimension ( n , n ) :: LU logical , intent ( in ) :: toggle ! Local variables integer :: info integer , dimension ( n ) :: my_P real ( wp ), dimension ( n , n ) :: my_a real ( wp ), dimension ( n , nrhs ) :: my_b my_a = a my_b = b if ( . not . toggle ) then call dgetrf ( n , n , my_a , n , my_P , info ) if ( info /= 0 ) then write ( * , '(a)' ) ' ' write ( * , '(a)' ) 'DGETRF' write ( * , '(a,i8)' ) '  Factorization failed, INFO = ' , info stop endif LU = my_a P = my_P endif call dgetrs ( 'No transpose' , n , nrhs , LU , n , P , my_b , n , info ) if ( info /= 0 ) then write ( * , '(a)' ) ' ' write ( * , '(a)' ) 'DGETRS' write ( * , '(a,i8)' ) '  Back substitution failed, INFO = ' , info stop endif x = my_b return end subroutine linsolve end module linalg","tags":"","loc":"sourcefile/linalg.f90.html","title":"linalg.f90 – learn_dg"},{"text":"This File Depends On sourcefile~~main.f90~~EfferentGraph sourcefile~main.f90 main.f90 sourcefile~assembly.f90 assembly.f90 sourcefile~assembly.f90->sourcefile~main.f90 sourcefile~io.f90 io.f90 sourcefile~io.f90->sourcefile~main.f90 sourcefile~misc.f90 misc.f90 sourcefile~misc.f90->sourcefile~main.f90 sourcefile~legendre.f90 legendre.f90 sourcefile~misc.f90->sourcefile~legendre.f90 sourcefile~linalg.f90 linalg.f90 sourcefile~linalg.f90->sourcefile~main.f90 sourcefile~linalg.f90->sourcefile~legendre.f90 sourcefile~legendre.f90->sourcefile~assembly.f90 sourcefile~integration.f90 integration.f90 sourcefile~integration.f90->sourcefile~legendre.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Programs main Source Code main.f90 Source Code program main use iso_fortran_env , only : wp => real64 use linalg , only : linsolve_quick use misc , only : r8mat_print use io , only : read_gmsh_file_1D , & write_out_solution use assembly , only : initialize_global_mats , assemble , set_BCs implicit none real ( wp ), parameter :: diff = 0.1_wp , vel = - 5._wp integer :: num_nodes integer , dimension (:), allocatable :: order , nodes2vertex integer , dimension (:,:), allocatable :: elem_conn real ( wp ), dimension (:), allocatable :: xcoords , GlobalB , GlobalX real ( wp ), dimension (:,:), allocatable :: GlobalA logical :: dg ! dg = .true. dg = . false . call read_gmsh_file_1D ( num_nodes , order , nodes2vertex , elem_conn , xcoords , dg ) ! stop call initialize_global_mats ( num_nodes , GlobalA , GlobalB , GlobalX ) call assemble ( order , xcoords , elem_conn , GlobalA , diff , vel ) call set_BCs ( xcoords , GlobalB , GlobalA ) ! call r8mat_print(num_nodes, num_nodes, GlobalA, 'Global Stiffness matrix:') ! stop call linsolve_quick ( num_nodes , GlobalA , 1 , GlobalB , GlobalX ) ! call r8mat_print(num_nodes, 1, GlobalB, 'Global RHS:') ! call r8mat_print(num_nodes, 1, GlobalX, 'Global Solution Vector:') call write_out_solution ( num_nodes , xcoords , GlobalX ) end program main","tags":"","loc":"sourcefile/main.f90.html","title":"main.f90 – learn_dg"},{"text":"Files Dependent On This One sourcefile~~misc.f90~~AfferentGraph sourcefile~misc.f90 misc.f90 sourcefile~legendre.f90 legendre.f90 sourcefile~misc.f90->sourcefile~legendre.f90 sourcefile~main.f90 main.f90 sourcefile~misc.f90->sourcefile~main.f90 sourcefile~doubleint.f90 doubleint.f90 sourcefile~misc.f90->sourcefile~doubleint.f90 sourcefile~legendre.f90->sourcefile~doubleint.f90 sourcefile~assembly.f90 assembly.f90 sourcefile~legendre.f90->sourcefile~assembly.f90 sourcefile~pascal_smod.f90 pascal_smod.f90 sourcefile~legendre.f90->sourcefile~pascal_smod.f90 sourcefile~assembly.f90->sourcefile~main.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Modules misc Source Code misc.f90 Source Code module misc use iso_fortran_env , only : wp => real64 implicit none private public :: r8mat_print contains subroutine r8mat_print ( m , n , a , title ) ! ************************************************************************** ! !* R8MAT_PRINT prints an R8MAT. ! !  Discussion: ! !    An R8MAT is a two dimensional matrix of double precision real values. ! !  Licensing: ! !    This code is distributed under the GNU LGPL license. ! !  Modified: ! !    12 September 2004 ! !  Author: ! !    John Burkardt ! !  Parameters: ! !    Input, integer M, the number of rows in A. ! !    Input, integer N, the number of columns in A. ! !    Input, real ( kind = 8 ) A(M,N), the matrix. ! !    Input, character ( len = * ) TITLE, a title to be printed. implicit none integer ( kind = 4 ) m integer ( kind = 4 ) n real ( kind = 8 ) a ( m , n ) character ( len = * ) title call r8mat_print_some ( m , n , a , 1 , 1 , m , n , title ) return end subroutine r8mat_print subroutine r8mat_print_some ( m , n , a , ilo , jlo , ihi , jhi , title ) ! ************************************************************************** ! !* R8MAT_PRINT_SOME prints some of an R8MAT. ! !  Discussion: ! !    An R8MAT is a two dimensional matrix of double precision real values. ! !  Licensing: ! !    This code is distributed under the GNU LGPL license. ! !  Modified: ! !    26 March 2005 ! !  Author: ! !    John Burkardt ! !  Parameters: ! !    Input, integer M, N, the number of rows and columns. ! !    Input, real ( kind = 8 ) A(M,N), an M by N matrix to be printed. ! !    Input, integer ILO, JLO, the first row and column to print. ! !    Input, integer IHI, JHI, the last row and column to print. ! !    Input, character ( len = * ) TITLE, an optional title. implicit none integer ( kind = 4 ), parameter :: incx = 5 integer ( kind = 4 ) m integer ( kind = 4 ) n real ( kind = 8 ) a ( m , n ) character ( len = 14 ) ctemp ( incx ) integer ( kind = 4 ) i integer ( kind = 4 ) i2hi integer ( kind = 4 ) i2lo integer ( kind = 4 ) ihi integer ( kind = 4 ) ilo integer ( kind = 4 ) inc integer ( kind = 4 ) j integer ( kind = 4 ) j2 integer ( kind = 4 ) j2hi integer ( kind = 4 ) j2lo integer ( kind = 4 ) jhi integer ( kind = 4 ) jlo character ( len = * ) title if ( 0 < len_trim ( title ) ) then write ( * , '(a)' ) ' ' write ( * , '(a)' ) trim ( title ) endif do j2lo = max ( jlo , 1 ), min ( jhi , n ), incx j2hi = j2lo + incx - 1 j2hi = min ( j2hi , n ) j2hi = min ( j2hi , jhi ) inc = j2hi + 1 - j2lo write ( * , '(a)' ) ' ' do j = j2lo , j2hi j2 = j + 1 - j2lo write ( ctemp ( j2 ), '(i8,6x)' ) j enddo write ( * , '(''  Col   '',5a14)' ) ctemp ( 1 : inc ) write ( * , '(a)' ) '  Row' write ( * , '(a)' ) ' ' i2lo = max ( ilo , 1 ) i2hi = min ( ihi , m ) do i = i2lo , i2hi do j2 = 1 , inc j = j2lo - 1 + j2 if ( a ( i , j ) == real ( int ( a ( i , j ) ), kind = 8 ) ) then write ( ctemp ( j2 ), '(f8.0,6x)' ) a ( i , j ) else write ( ctemp ( j2 ), '(g14.6)' ) a ( i , j ) endif enddo write ( * , '(i5,1x,5a14)' ) i , ( ctemp ( j ), j = 1 , inc ) enddo enddo write ( * , '(a)' ) ' ' return end subroutine r8mat_print_some end module misc","tags":"","loc":"sourcefile/misc.f90.html","title":"misc.f90 – learn_dg"},{"text":"This File Depends On sourcefile~~pascal_smod.f90~~EfferentGraph sourcefile~pascal_smod.f90 pascal_smod.f90 sourcefile~legendre.f90 legendre.f90 sourcefile~legendre.f90->sourcefile~pascal_smod.f90 sourcefile~misc.f90 misc.f90 sourcefile~misc.f90->sourcefile~legendre.f90 sourcefile~linalg.f90 linalg.f90 sourcefile~linalg.f90->sourcefile~legendre.f90 sourcefile~integration.f90 integration.f90 sourcefile~integration.f90->sourcefile~legendre.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Submodules pascal_smod Source Code pascal_smod.f90 Source Code submodule ( legendre ) pascal_smod use iso_fortran_env , only : wp => real64 implicit none contains module function pascal_1D_line ( N , x ) result ( row ) integer , intent ( in ) :: N real ( wp ), intent ( in ) :: x real ( wp ), dimension ( N + 1 ) :: row integer :: ii ! Produces the elements of an array: [1, x, x&#94;2, ..., x&#94;N] row = [( x ** ( ii - 1 ), ii = 1 , N + 1 )] return end function pascal_1D_line module function pascal_2D_quad ( N , x , y ) result ( row ) !* ! Generates an array of points related to a quadrilateral using Pascal's ! triangle in 2D, where rows are 0-indexed ! ! Pascal's triangle in 2D looks like this, with points used in bi-quadratic quadrilateral in bold: !    [\\mathbf{1}]  !    [\\mathbf{x},~ \\mathbf{y}]  !    [\\mathbf{x&#94;2},~ \\mathbf{x y},~ \\mathbf{y&#94;2}]  !    [x&#94;3,~ \\mathbf{x&#94;2y},~ \\mathbf{xy&#94;2},~ y&#94;3]  !    [x&#94;4,~ x&#94;3y,~ \\mathbf{x&#94;2y&#94;2},~ xy&#94;3, y&#94;4]  !    \\vdots  !    [x&#94;N,~ x&#94;{N-1}y,~ \\cdots ~,~ xy&#94;{N-1},~ y&#94;N]  integer , intent ( in ) :: N !! Order of the qaudrilateral real ( wp ), intent ( in ) :: x !! X-coordinate of node used in calculation real ( wp ), intent ( in ) :: y !! Y-coordinate of node used in calculation real ( wp ), dimension (( N + 1 ) ** 2 ) :: row !! Output row integer :: ii , start , finish real ( wp ), dimension (:), allocatable :: temp , temp_pre , temp_post row = 0.d0 ! Collects the first N rows of a 2D pascal triangle as function of x and y temp_pre = [( pascal_2D_row ( ii , x , y ), ii = 0 , N )] temp_post = [( pascal_2D_quad_post ( N , ii , x , y ), ii = N + 1 , 2 * N )] row = [ temp_pre , temp_post ] return contains pure function pascal_2D_quad_post ( N , ii , x , y ) result ( row ) integer , intent ( in ) :: N , ii real ( wp ), intent ( in ) :: x , y real ( wp ), dimension ( 2 * N - ii + 1 ) :: row integer :: start , finish real ( wp ), dimension (:), allocatable :: temp temp = pascal_2D_row ( ii , x , y ) start = ii - N + 1 finish = ii - ( ii - N ) + 1 row = temp ( start : finish ) return end function pascal_2D_quad_post end function pascal_2D_quad pure function pascal_2D_row ( N , x , y ) result ( row ) !* ! Generates a row of Pascal's triangle in 2D, where rows are 0-indexed ! ! Pascal's triangle in 2D looks like this: !    [1]  !    [x,~ y]  !    [x&#94;2,~ x y,~ y&#94;2]  !    [x&#94;3,~ x&#94;2y,~ xy&#94;2,~ y&#94;3]  !    [x&#94;4,~ x&#94;3y,~ x&#94;2y&#94;2,~ xy&#94;3, y&#94;4]  !    \\vdots  !    [x&#94;N,~ x&#94;{N-1}y,~ \\cdots,~ xy&#94;{N-1},~ y&#94;N]  ! ! Therefore, the third row (index=2) would be x&#94;2, x\\cdot y, y&#94;2 integer , intent ( in ) :: N !! Row number of pascal's 2D triange (0-indexed) real ( wp ), intent ( in ) :: x !! X-value used in triange real ( wp ), intent ( in ) :: y !! Y-Value used in triange real ( wp ), dimension ( N + 1 ) :: row !! Output row of triange integer :: ii ! Produces the elements of an array: [x&#94;N, x&#94;(N-1)*y, x&#94;(N-2)*y&#94;2, ..., y&#94;N] row = [( x ** ( N - ii ) * y ** ( ii ), ii = 0 , N )] return end function pascal_2D_row end submodule pascal_smod","tags":"","loc":"sourcefile/pascal_smod.f90.html","title":"pascal_smod.f90 – learn_dg"},{"text":"public subroutine initialize_global_mats(num_nodes, GlobalA, GlobalB, GlobalX) This routine initalizes the global stiffness matrix, global rhs vector,\n  and global solution vector based on the number of nodes in the system This is a bullet point Another bullet point This might be a number Also a number? Some  \\LaTeX :\n  \\frac{\\partial u}{\\partial t} = 0  Arguments Type Intent Optional Attributes Name integer, intent(in) :: num_nodes The number of nodes in the system real(kind=wp), intent(out), dimension(:,:), allocatable :: GlobalA Global mass matrix real(kind=wp), intent(out), dimension(:), allocatable :: GlobalB Global RHS Vector real(kind=wp), intent(out), dimension(:), allocatable :: GlobalX Global solution vector Called By proc~~initialize_global_mats~~CalledByGraph proc~initialize_global_mats initialize_global_mats program~main main program~main->proc~initialize_global_mats Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code initialize_global_mats Source Code subroutine initialize_global_mats ( num_nodes , & GlobalA , & GlobalB , & GlobalX ) !* This routine initalizes the global stiffness matrix, global rhs vector, !  and global solution vector based on the number of nodes in the system ! ! * This is a bullet point ! * Another bullet point ! ! 1. This might be a number ! 2. Also a number? ! ! Some  \\LaTeX : !  \\frac{\\partial u}{\\partial t} = 0  integer , intent ( in ) :: num_nodes !! The number of nodes in the system real ( wp ), intent ( out ), dimension (:), allocatable :: GlobalB !! Global RHS Vector real ( wp ), intent ( out ), dimension (:), allocatable :: GlobalX !! Global solution vector real ( wp ), intent ( out ), dimension (:,:), allocatable :: GlobalA !! Global mass matrix allocate ( GlobalA ( num_nodes , num_nodes )) allocate ( GlobalB ( num_nodes )) allocate ( GlobalX ( num_nodes )) ! Intial Conditions GlobalA = 0._wp GlobalX = 0._wp GlobalB = 0._wp return end subroutine initialize_global_mats","tags":"","loc":"proc/initialize_global_mats.html","title":"initialize_global_mats – learn_dg"},{"text":"public subroutine assemble(order, xcoords, elem_conn, GlobalA, diff, vel) Assemble the global stiffness matrix based on element connectivity Arguments Type Intent Optional Attributes Name integer, intent(in), dimension(:) :: order Order of element(s) real(kind=wp), intent(in), dimension(:) :: xcoords Array of nodal coordinates integer, intent(in), dimension(:,:) :: elem_conn Element connectivity real(kind=wp), intent(out), dimension(:,:) :: GlobalA Global Stiffness matrix real(kind=wp), intent(in) :: diff Diffusivity coefficient [m/s&#94;2] real(kind=wp), intent(in) :: vel Velocity [m/s] Calls proc~~assemble~~CallsGraph proc~assemble assemble getie getie proc~assemble->getie Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called By proc~~assemble~~CalledByGraph proc~assemble assemble program~main main program~main->proc~assemble Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code assemble Source Code subroutine assemble ( order , xcoords , elem_conn , GlobalA , diff , vel ) !* Assemble the global stiffness matrix based on element connectivity integer , intent ( in ), dimension (:) :: order !! Order of element(s) integer , intent ( in ), dimension (:,:) :: elem_conn !! Element connectivity real ( wp ), intent ( in ) :: diff !! Diffusivity coefficient [m/s&#94;2] real ( wp ), intent ( in ) :: vel !! Velocity [m/s] real ( wp ), intent ( in ), dimension (:) :: xcoords !! Array of nodal coordinates real ( wp ), intent ( out ), dimension (:,:) :: GlobalA !! Global Stiffness matrix integer :: ii real ( wp ), dimension (:,:), allocatable :: Ie ! Add elemental stiffness matrices to Global Stiffness Matrix do ii = 1 , size ( order ) ! Reallocate elemental stiffness matrix allocate ( Ie ( order ( ii ) + 1 , order ( ii ) + 1 )) call getIe ( 1 , 1 , xcoords ( elem_conn ( ii ,:)), Ie ) ! call r8mat_print(order(ii)+1, order(ii)+1, Ie, 'Elemental Stiffness Matrix:') GlobalA ( elem_conn ( ii ,:), elem_conn ( ii ,:)) = & GlobalA ( elem_conn ( ii ,:), elem_conn ( ii ,:)) - diff * Ie call getIe ( 0 , 1 , xcoords ( elem_conn ( ii ,:)), Ie ) ! call r8mat_print(order(ii)+1, order(ii)+1, Ie, 'Elemental Stiffness Matrix:') GlobalA ( elem_conn ( ii ,:), elem_conn ( ii ,:)) = & GlobalA ( elem_conn ( ii ,:), elem_conn ( ii ,:)) - vel * Ie ! Deallocate elemental stiffness matrix after every loop deallocate ( Ie ) ! stop enddo ! call r8mat_print(num_nodes, num_nodes, GlobalA, 'Global Stiffness Matrix:') ! stop return end subroutine assemble","tags":"","loc":"proc/assemble.html","title":"assemble – learn_dg"},{"text":"public subroutine set_BCs(xcoords, GlobalB, GlobalA) Set boundary conditions in GlobalA and GlobalB using two Dirchlet\n   boundaries Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: xcoords Array of nodal coordinates real(kind=wp), intent(out), dimension(:) :: GlobalB Global RHS Vector real(kind=wp), intent(out), dimension(:,:) :: GlobalA Global Mass Matrix Source Code set_BCs Source Code subroutine set_BCs ( xcoords , GlobalB , GlobalA ) !*  Set boundary conditions in GlobalA and GlobalB using two Dirchlet !   boundaries real ( wp ), intent ( in ), dimension (:) :: xcoords !! Array of nodal coordinates real ( wp ), intent ( out ), dimension (:) :: GlobalB !! Global RHS Vector real ( wp ), intent ( out ), dimension (:,:) :: GlobalA !! Global Mass Matrix integer , dimension ( 1 ) :: iloc !! Index variable to locate node numbers based on xcoords ! Left Boundary Dirchlet BC iloc = minloc ( xcoords ) GlobalA ( iloc ,:) = 0._wp GlobalA ( iloc , iloc ) = 1._wp GlobalB ( iloc ) = 0._wp ! Right Boundary Dirchlet BC iloc = maxloc ( xcoords ) GlobalA ( iloc ,:) = 0._wp GlobalA ( iloc , iloc ) = 1._wp GlobalB ( iloc ) = 1._wp ! call r8mat_print(num_nodes, 1, GlobalB, 'Global RHS:') ! stop return end subroutine set_BCs","tags":"","loc":"proc/set_bcs.html","title":"set_BCs – learn_dg"},{"text":"public function integrate2D(fun) result(out) Arguments Type Intent Optional Attributes Name procedure( fun2d_interf ) :: fun Return Value real(kind=wp) Calls proc~~integrate2d~~CallsGraph proc~integrate2d integrate2D proc~gaussquad gaussquad proc~integrate2d->proc~gaussquad proc~gaussquad_rosetta gaussquad_rosetta proc~gaussquad->proc~gaussquad_rosetta Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs.","tags":"","loc":"proc/integrate2d.html","title":"integrate2D – learn_dg"},{"text":"public subroutine integrate(sub, a, b, result) Arguments Type Intent Optional Attributes Name procedure( sub1d_interf ) :: sub real(kind=wp), intent(in) :: a real(kind=wp), intent(in) :: b real(kind=wp), intent(out) :: result Calls proc~~integrate~~CallsGraph proc~integrate integrate proc~gaussquad gaussquad proc~integrate->proc~gaussquad proc~gaussquad_rosetta gaussquad_rosetta proc~gaussquad->proc~gaussquad_rosetta Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called By proc~~integrate~~CalledByGraph proc~integrate integrate proc~integrate_basis_1d_ie integrate_basis_1d_Ie proc~integrate_basis_1d_ie->proc~integrate proc~getie getIe proc~getie->proc~integrate_basis_1d_ie Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code integrate Source Code subroutine integrate ( sub , a , b , result ) ! This routine uses gauss-legendre quadrature to integrate a 1D function ! Input/Output variables real ( wp ), intent ( in ) :: a , b real ( wp ), intent ( out ) :: result procedure ( sub1d_interf ) :: sub ! Local variables integer :: N real ( wp ) :: result_old , error real ( wp ), parameter :: eps = sqrt ( epsilon ( 1.0_wp )) real ( wp ), dimension (:), allocatable :: x , w , y N = 3 result = 0.0_wp error = 1.0_wp do result_old = result allocate ( x ( N ), w ( N ), y ( N )) call gaussquad ( N , x , w ) call sub ( x , y ) result = sum ( y * w ) deallocate ( x , w , y ) ! error = norm2([result, result_old]) error = sqrt (( result - result_old ) ** 2.0_wp ) ! error = abs((result-result_old)/(result_old+eps)) ! print*, N, result, error ! print*, N, result, result_old, error, eps ! Check if error is acceptable, as well as whether the loop was gone ! through at least twice (N = 3, 4, 5...) if ( ( error < eps . or . abs ( result ) < eps ) & . and . N > 5 ) then exit else N = N + 1 endif enddo return end subroutine integrate","tags":"","loc":"proc/integrate.html","title":"integrate – learn_dg"},{"text":"private subroutine gaussquad(N, x, w) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N real(kind=wp), intent(out), dimension(N) :: x real(kind=wp), intent(out), dimension(N) :: w Calls proc~~gaussquad~~CallsGraph proc~gaussquad gaussquad proc~gaussquad_rosetta gaussquad_rosetta proc~gaussquad->proc~gaussquad_rosetta Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called By proc~~gaussquad~~CalledByGraph proc~gaussquad gaussquad proc~integrate2d integrate2D proc~integrate2d->proc~gaussquad proc~integrate integrate proc~integrate->proc~gaussquad proc~integrate_basis_1d_ie integrate_basis_1d_Ie proc~integrate_basis_1d_ie->proc~integrate proc~getie getIe proc~getie->proc~integrate_basis_1d_ie Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code gaussquad Source Code subroutine gaussquad ( N , x , w ) integer , intent ( in ) :: N real ( wp ), intent ( out ), dimension ( N ) :: x , w select case ( N ) case ( 1 ) x = [ 0._wp ] w = [ 2._wp ] case ( 2 ) x = [ - 0.5773502691896257_wp , & 0.5773502691896257_wp ] w = [ 1._wp , & 1._wp ] case ( 3 ) x = [ - 0.7745966692414834_wp , & 0._wp , & 0.7745966692414834_wp ] w = [ 0.5555555555555556_wp , & 0.8888888888888888_wp , & 0.5555555555555556_wp ] case ( 4 ) x = [ - 0.8611363115940526_wp , & - 0.3399810435848563_wp , & 0.3399810435848563_wp , & 0.8611363115940526_wp ] w = [ 0.3478548451374538_wp , & 0.6521451548625461_wp , & 0.6521451548625461_wp , & 0.3478548451374538_wp ] case ( 5 ) x = [ - 0.9061798459386640_wp , & - 0.5384693101056831_wp , & 0._wp , & 0.5384693101056831_wp , & 0.9061798459386640_wp ] w = [ 0.2369268850561891_wp , & 0.4786286704993665_wp , & 0.5688888888888889_wp , & 0.4786286704993665_wp , & 0.2369268850561891_wp ] case default ! call lgwt(-1._wp, 1._wp, N, x, w) ! call cgwt(N, x, w) call gaussquad_rosetta ( N , x , w ) end select return end subroutine gaussquad","tags":"","loc":"proc/gaussquad.html","title":"gaussquad – learn_dg"},{"text":"private subroutine lgwt(a, b, num_pts, x, w) This function is a fortran90 port of the matlab function, lgwt.m\n   The source code of lgwt.m was originally found at:\n     http://www.mathworks.com/matlabcentral/fileexchange/4540 Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a real(kind=wp), intent(in) :: b integer, intent(in) :: num_pts real(kind=wp), intent(out), dimension(:) :: x real(kind=wp), intent(out), dimension(:) :: w Calls proc~~lgwt~~CallsGraph proc~lgwt lgwt linspace linspace proc~lgwt->linspace Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code lgwt Source Code subroutine lgwt ( a , b , num_pts , x , w ) !*  This function is a fortran90 port of the matlab function, lgwt.m !   The source code of lgwt.m was originally found at: !     http://www.mathworks.com/matlabcentral/fileexchange/4540 ! Variables in/out integer , intent ( in ) :: num_pts real ( wp ), intent ( in ) :: a , b real ( wp ), intent ( out ), dimension (:) :: x , w ! Local variables integer :: ii , jj , N , N1 , N2 ! real(wp), parameter:: eps=sqrt(epsilon(1.0_wp)) real ( wp ), parameter :: eps = 1 d - 10 real ( wp ), dimension (:), allocatable :: xu , array1 , y , y0 , Lpp real ( wp ), dimension (:, :), allocatable :: L , Lp real ( wp ), parameter :: pi = 4.0_wp * datan ( 1.0_wp ) N = num_pts - 1 N1 = N + 1 N2 = N + 2 ! Allocate and initialize arrays allocate ( xu ( N1 ), array1 ( N1 ), y ( N1 ), y0 ( N1 )) allocate ( L ( N1 , N2 ), Lp ( N1 , N2 ), Lpp ( N1 )) L = 0.0_wp Lp = 0.0_wp call linspace ( - 1.0_wp , 1.0_wp , xu ) array1 = [ ( ii , ii = 0 , N ) ] ! Initial guess of the roots of the Legendre polynomial of order N y = cos (( 2.0_wp * real ( array1 , wp ) + 1.0_wp ) * & pi / ( 2.0_wp * real ( N , wp ) + 2.0_wp )) + & ( 0.27_wp / real ( N1 , wp )) * sin ( pi * xu * real ( N , wp ) / real ( N2 , wp )) y0 = 2.0_wp do L (:, 1 ) = 1.0_wp Lp (:, 1 ) = 0.0_wp L (:, 2 ) = y Lp (:, 2 ) = 1.0_wp do jj = 2 , N1 L (:, jj + 1 ) = ( ( 2.0_wp * real ( jj , wp ) - 1.0_wp ) * y * L (:, jj ) - & real ( jj - 1 , wp ) * L (:, jj - 1 )) / real ( jj , wp ) enddo Lpp = real ( N2 , wp ) * ( L (:, N1 ) - y * L (:, N2 )) / ( 1.0_wp - y ** 2.0_wp ) y0 = y y = y0 - L (:, N2 ) / Lpp if ( norm2 ( y - y0 ) < eps ) then exit endif enddo x = ( a * ( 1.0_wp - y ) + b * ( 1.0_wp + y ) ) / 2.0_wp w = ( b - a ) / (( 1.0_wp - y ** 2.0_wp ) * Lpp ** 2.0_wp ) * & ( real ( N2 , wp ) / real ( N1 , wp )) ** 2.0_wp return end subroutine lgwt","tags":"","loc":"proc/lgwt.html","title":"lgwt – learn_dg"},{"text":"private subroutine cgwt(num_pts, x, w) Arguments Type Intent Optional Attributes Name integer, intent(in) :: num_pts real(kind=wp), intent(out), dimension(:) :: x real(kind=wp), intent(out), dimension(:) :: w Source Code cgwt Source Code subroutine cgwt ( num_pts , x , w ) ! This function  determines the points and weights associated with Chebyshev-Gauss quadrature ! Variables in/out integer , intent ( in ) :: num_pts real ( wp ), intent ( out ), dimension (:) :: x , w ! Local variables integer :: ii real ( wp ), parameter :: pi = 4._wp * datan ( 1._wp ) x = cos ( ( real ( 2 * [( ii , ii = 1 , num_pts )] - 1 , wp ) ) / real ( 2 * num_pts , wp ) * pi ) w = pi / real ( num_pts , wp ) / (( 1.0_wp - x ** 2._wp ) ** ( - 0.5_wp )) ! print*, x ! print*, w ! stop return end subroutine cgwt","tags":"","loc":"proc/cgwt.html","title":"cgwt – learn_dg"},{"text":"private subroutine gaussquad_rosetta(n, r1, r2) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=wp), intent(out) :: r1 (n) real(kind=wp), intent(out) :: r2 (n) Called By proc~~gaussquad_rosetta~~CalledByGraph proc~gaussquad_rosetta gaussquad_rosetta proc~gaussquad gaussquad proc~gaussquad->proc~gaussquad_rosetta proc~integrate2d integrate2D proc~integrate2d->proc~gaussquad proc~integrate integrate proc~integrate->proc~gaussquad proc~integrate_basis_1d_ie integrate_basis_1d_Ie proc~integrate_basis_1d_ie->proc~integrate proc~getie getIe proc~getie->proc~integrate_basis_1d_ie Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code gaussquad_rosetta Source Code subroutine gaussquad_rosetta ( n , r1 , r2 ) ! This code was originally found at the following website: !  http://rosettacode.org/wiki/Numerical_integration/Gauss-Legendre_Quadrature#Fortran integer , intent ( in ) :: n real ( wp ), intent ( out ) :: r1 ( n ), r2 ( n ) integer :: k real ( wp ), parameter :: pi = 4._wp * atan ( 1._wp ) real ( wp ) :: x , f , df , dx integer :: i , iter real ( wp ), allocatable :: p0 (:), p1 (:), tmp (:) p0 = [ 1._wp ] p1 = [ 1._wp , 0._wp ] do k = 2 , n tmp = (( 2 * k - 1 ) * [ p1 , 0._wp ] - ( k - 1 ) * [ 0._wp , 0._wp , p0 ]) / k p0 = p1 ; p1 = tmp enddo do i = 1 , n x = cos ( pi * ( i - 0.25_wp ) / ( n + 0.5_wp )) do iter = 1 , 10 f = p1 ( 1 ); df = 0._wp do k = 2 , size ( p1 ) df = f + x * df f = p1 ( k ) + x * f enddo dx = f / df x = x - dx if ( abs ( dx ) < 10 * epsilon ( dx )) exit enddo r1 ( i ) = x r2 ( i ) = 2 / (( 1 - x ** 2 ) * df ** 2 ) enddo return end subroutine gaussquad_rosetta","tags":"","loc":"proc/gaussquad_rosetta.html","title":"gaussquad_rosetta – learn_dg"},{"text":"interface private function fun2d_interf(x, y) result(z) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:,:) :: x real(kind=wp), intent(in), dimension(:,:) :: y Return Value real(kind=wp),\n  dimension(:,:),allocatable","tags":"","loc":"interface/fun2d_interf.html","title":"fun2d_interf – learn_dg"},{"text":"interface private subroutine sub1d_interf(xx, yy) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: xx real(kind=wp), intent(out), dimension(:) :: yy","tags":"","loc":"interface/sub1d_interf.html","title":"sub1d_interf – learn_dg"},{"text":"public subroutine read_gmsh_file_1D(num_nodes, order, nodes2vertex, elem_conn, xcoords, dg) Reads the input mesh file (gmsh .msh format) and returns the number of\n   nodes, the order of each element, element connectivity, and the\n   coordinates of the nodes (nx1 for 1D, nx2 for 2D, etc.) Arguments Type Intent Optional Attributes Name integer, intent(out) :: num_nodes Number of nodes in mesh integer, intent(out), dimension(:), allocatable :: order Array containing order of each element integer, intent(out), dimension(:), allocatable :: nodes2vertex Array containing node to vertex connectivity (only interesting w.r.t discontinuous galerkin) integer, intent(out), dimension(:,:), allocatable :: elem_conn Array containing node connectivity of each element real(kind=wp), intent(out), dimension(:), allocatable :: xcoords Array containing node coordinates logical, intent(in) :: dg Logical switch is continuous galerkin or discontinuous galerkin Source Code read_gmsh_file_1D Source Code subroutine read_gmsh_file_1D ( num_nodes , & order , & nodes2vertex , & elem_conn , & xcoords , & dg ) ! !*  Reads the input mesh file (gmsh .msh format) and returns the number of !   nodes, the order of each element, element connectivity, and the !   coordinates of the nodes (nx1 for 1D, nx2 for 2D, etc.) integer , intent ( out ) :: num_nodes !! Number of nodes in mesh integer , intent ( out ), dimension (:), allocatable :: order !! Array containing order of each element integer , intent ( out ), dimension (:), allocatable :: nodes2vertex !! Array containing node to vertex connectivity (only interesting w.r.t discontinuous galerkin) integer , intent ( out ), dimension (:,:), allocatable :: elem_conn !! Array containing node connectivity of each element real ( wp ), intent ( out ), dimension (:), allocatable :: xcoords !! Array containing node coordinates logical , intent ( in ) :: dg !! Logical switch is continuous galerkin or discontinuous galerkin integer :: ii , ios , vertex , num_elements , num_vertexes , d_int integer , dimension (:,:), allocatable :: vertex_conn real ( wp ) :: d_real character ( 80 ) :: filename character ( 80 ) :: blank_string call get_command_argument ( 1 , filename ) ! print*, filename open ( unit = 21 , file = filename , iostat = ios , status = \"old\" , action = \"read\" ) if ( ios /= 0 ) then print * , filename print * , ios stop \"Error opening file \" endif ! Read initial header information - assuming file is in the correct format do read ( 21 , * ) blank_string if ( trim ( blank_string ) == '$Nodes' ) exit enddo ! Read number of nodes read ( 21 , * ) num_vertexes allocate ( xcoords ( num_vertexes )) if ( . not . dg ) then num_nodes = num_vertexes else num_nodes = 2 * num_vertexes - 2 endif ! Read coordinate information for each vertex do ii = 1 , num_vertexes read ( 21 , * ) d_int , xcoords ( ii ), d_real , d_real enddo allocate ( nodes2vertex ( num_nodes )) nodes2vertex = 0 if ( dg ) then vertex = 1 do ii = 1 , num_nodes nodes2vertex ( ii ) = vertex if ( ii == 1 . or . ii == num_nodes ) then vertex = vertex + 1 elseif ( mod ( ii , 2 ) == 0 ) then vertex = vertex + 1 endif enddo else nodes2vertex = [( ii , ii = 1 , num_nodes )] endif do ii = 1 , num_nodes print * , ii , nodes2vertex ( ii ), xcoords ( nodes2vertex ( ii )) enddo print * , ! stop ! Two dummy lines : !   $EndNodes !   $Elements read ( 21 , * ) read ( 21 , * ) read ( 21 , * ) num_elements num_elements = num_elements - 2 allocate ( order ( num_elements )) allocate ( elem_conn ( num_elements , 2 )) allocate ( vertex_conn ( num_elements , 2 )) ! Initialize all elements as first order linear elements order = 1 ! Two dummy lines - Associated with 'point' elements read ( 21 , * ) read ( 21 , * ) do ii = 1 , num_elements read ( 21 , * ) d_int , d_int , d_int , d_int , d_int , vertex_conn ( ii , 1 : 2 ) ! print*, pack(vertex_conn, vertex_conn == nodes2vertex) enddo ! print*, pack([( ii, ii = 1, num_nodes )], & !         nodes2vertex == nodes2vertex(3) & !         .or. nodes2vertex == nodes2vertex(5)) ! stop if ( . not . dg ) then elem_conn = vertex_conn else do ii = 1 , num_elements ! elem_conn(ii,:) = pack([( ii, ii = 1, num_nodes )], & !   nodes2vertex == vertex_conn(ii,1)) ! print*, loc(2._wp) ! print*, loc(nodes2vertex == vertex_conn(ii,2)) print * , order ( ii ), vertex_conn ( ii ,:), elem_conn ( ii ,:) print * , enddo endif print * , do ii = 1 , size ( xcoords ) print * , xcoords ( ii ) enddo print * , close ( unit = 21 , iostat = ios ) if ( ios /= 0 ) stop \"Error closing file unit 21\" return end subroutine read_gmsh_file_1D","tags":"","loc":"proc/read_gmsh_file_1d.html","title":"read_gmsh_file_1D – learn_dg"},{"text":"public subroutine write_out_solution(num_nodes, xcoords, GlobalX) Arguments Type Intent Optional Attributes Name integer, intent(in) :: num_nodes real(kind=wp), intent(in), dimension(:) :: xcoords real(kind=wp), intent(in), dimension(:) :: GlobalX Called By proc~~write_out_solution~~CalledByGraph proc~write_out_solution write_out_solution program~main main program~main->proc~write_out_solution Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code write_out_solution Source Code subroutine write_out_solution ( num_nodes , xcoords , GlobalX ) integer , intent ( in ) :: num_nodes real ( wp ), intent ( in ), dimension (:) :: xcoords , GlobalX integer :: ii , ios open ( unit = 21 , file = 'data.out' , iostat = ios , status = \"replace\" , action = \"write\" ) if ( ios /= 0 ) then print * , ios stop \"Error opening file data.out\" endif do ii = 1 , num_nodes write ( 21 , * ) xcoords ( ii ), GlobalX ( ii ) enddo close ( unit = 21 , iostat = ios ) if ( ios /= 0 ) then print * , ios stop \"Error closing file unit data.out\" endif return end subroutine write_out_solution","tags":"","loc":"proc/write_out_solution.html","title":"write_out_solution – learn_dg"},{"text":"private function integrate_basis_1d_Ie(N, ii, jj, dii, djj, xcoords) result(integral) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N integer, intent(in) :: ii integer, intent(in) :: jj integer, intent(in) :: dii integer, intent(in) :: djj real(kind=wp), intent(in), dimension(:) :: xcoords Return Value real(kind=wp) Calls proc~~integrate_basis_1d_ie~~CallsGraph proc~integrate_basis_1d_ie integrate_basis_1d_Ie proc~vandermonde vandermonde proc~integrate_basis_1d_ie->proc~vandermonde proc~integrate integrate proc~integrate_basis_1d_ie->proc~integrate linspace linspace proc~vandermonde->linspace proc~linsolve_quick linsolve_quick proc~vandermonde->proc~linsolve_quick proc~gaussquad gaussquad proc~integrate->proc~gaussquad proc~linsolve linsolve proc~linsolve_quick->proc~linsolve dgetrs dgetrs proc~linsolve->dgetrs dgetrf dgetrf proc~linsolve->dgetrf proc~gaussquad_rosetta gaussquad_rosetta proc~gaussquad->proc~gaussquad_rosetta Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called By proc~~integrate_basis_1d_ie~~CalledByGraph proc~integrate_basis_1d_ie integrate_basis_1d_Ie proc~getie getIe proc~getie->proc~integrate_basis_1d_ie Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code integrate_basis_1d_Ie Source Code function integrate_basis_1d_Ie ( N , ii , jj , dii , djj , xcoords ) result ( integral ) integer , intent ( in ) :: N , ii , jj , dii , djj real ( wp ), intent ( in ), dimension (:) :: xcoords real ( wp ) :: integral integer :: order , basis_num1 , basis_num2 real ( wp ), dimension (:, :), allocatable :: Vinv order = N basis_num1 = ii basis_num2 = jj allocate ( Vinv ( order + 1 , order + 1 )) call vandermonde ( order + 1 , Vinv ) ! Check to make sure xcoords is an array of size (N+1) if ( size ( xcoords ) /= order + 1 ) then write ( * , * ) 'The shape of `xcoords` is outside the acceptable range for a' write ( * , * ) '1D basis function.' write ( * , * ) 'Shape(xcoords) should be [' , 2 , order + 1 , '], not ' , shape ( xcoords ) endif call integrate ( local_wrapper , - 1.0_wp , 1.0_wp , integral ) return contains subroutine XorJ ( s , dx , out ) integer , intent ( in ) :: dx real ( wp ), intent ( in ), dimension (:) :: s real ( wp ), intent ( out ), dimension (:) :: out integer :: ii out = 0.0_wp do ii = 1 , size ( xcoords ) out = out + basis_1D ( s , Vinv (:, ii ), dx ) * xcoords ( ii ) enddo end subroutine XorJ subroutine local_wrapper ( s , y ) real ( wp ), intent ( in ), dimension (:) :: s real ( wp ), intent ( out ), dimension (:) :: y real ( wp ), dimension (:), allocatable :: J allocate ( J ( size ( s ))) call XorJ ( s , 1 , J ) ! write(*,*) dii, djj y = 1.0_wp ! Here we have to be careful because J is not always needed in the first ! two function calls. Instead of using if statements, we can use an exponent so that when dx_ == 0, J is 1 y = y * basis_1D ( s , Vinv (:, basis_num1 ), dii ) / ( J ** real ( dii , wp )) y = y * basis_1D ( s , Vinv (:, basis_num2 ), djj ) / ( J ** real ( djj , wp )) y = y * J deallocate ( J ) return end subroutine local_wrapper end function integrate_basis_1d_Ie","tags":"","loc":"proc/integrate_basis_1d_ie.html","title":"integrate_basis_1d_Ie – learn_dg"},{"text":"private function basis_1D(x, alpha, dx) result(y) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: x real(kind=wp), intent(in), dimension(:) :: alpha integer, intent(in) :: dx Return Value real(kind=wp),\n  dimension(:),allocatable Source Code basis_1D Source Code function basis_1D ( x , alpha , dx ) result ( y ) ! Input/output variables integer , intent ( in ) :: dx real ( wp ), intent ( in ), dimension (:) :: x real ( wp ), intent ( in ), dimension (:) :: alpha real ( wp ), dimension (:), allocatable :: y , yx ! Local variables integer :: ii , N allocate ( y ( size ( x )), yx ( size ( x ))) N = size ( alpha ) y = 0._wp do ii = 1 + dx , N if ( dx == 0 ) then yx = alpha ( ii ) * x ** real ( ii - 1 , wp ) else ! Hoping for the best that dx == 1 yx = real ( ii - 1 , wp ) * alpha ( ii ) * ( x ) ** ( real ( ii - 1 - dx , wp )) endif y = y + yx enddo return end function basis_1D","tags":"","loc":"proc/basis_1d.html","title":"basis_1D – learn_dg"},{"text":"public pure function getxy(N) result(xy) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N Return Value real(kind=wp),\n  dimension(N,2) Called By proc~~getxy~~CalledByGraph proc~getxy getxy program~doubleint doubleint program~doubleint->proc~getxy Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code getxy Source Code pure function getxy ( N ) result ( xy ) integer , intent ( in ) :: N real ( wp ), dimension ( N , 2 ) :: xy ! Keep a copy of 1/3 handy so no need to retype it all the time real ( wp ), parameter :: zero = 0._wp real ( wp ), parameter :: one = 1._wp real ( wp ), parameter :: third = 1._wp / 3._wp if ( N == 4 ) then xy ( 1 ,:) = [ - one , - one ] ! Node 1 xy ( 2 ,:) = [ one , - one ] ! Node 2 xy ( 3 ,:) = [ one , one ] ! Node 3 xy ( 4 ,:) = [ - one , one ] ! Node 4 elseif ( N == 9 ) then xy ( 1 ,:) = [ - one , - one ] ! Node 1 xy ( 2 ,:) = [ one , - one ] ! Node 2 xy ( 3 ,:) = [ one , one ] ! Node 3 xy ( 4 ,:) = [ - one , one ] ! Node 4 xy ( 5 ,:) = [ zero , - one ] ! Node 5 xy ( 6 ,:) = [ one , zero ] ! Node 6 xy ( 7 ,:) = [ zero , one ] ! Node 7 xy ( 8 ,:) = [ - one , zero ] ! Node 8 xy ( 9 ,:) = [ zero , zero ] ! Node 9 elseif ( N == 16 ) then xy ( 1 ,:) = [ - one , - one ] ! Node 1 xy ( 2 ,:) = [ one , - one ] ! Node 2 xy ( 3 ,:) = [ one , one ] ! Node 3 xy ( 4 ,:) = [ - one , one ] ! Node 4 xy ( 5 ,:) = [ - third , - one ] ! Node 5 xy ( 6 ,:) = [ third , - one ] ! Node 6 xy ( 7 ,:) = [ one , - third ] ! Node 7 xy ( 8 ,:) = [ one , third ] ! Node 8 xy ( 9 ,:) = [ third , one ] ! Node 9 xy ( 10 ,:) = [ - third , one ] ! Node 10 xy ( 11 ,:) = [ - one , third ] ! Node 11 xy ( 12 ,:) = [ - one , - third ] ! Node 12 xy ( 13 ,:) = [ - third , - third ] ! Node 13 xy ( 14 ,:) = [ third , - third ] ! Node 14 xy ( 15 ,:) = [ third , third ] ! Node 15 xy ( 16 ,:) = [ - third , third ] ! Node 16 ! else ! !   print*, \"Unsupported number of nodes selected: \", N !   stop \"Number of nodes must be either 4, 9, or 16\" endif return end function getxy","tags":"","loc":"proc/getxy.html","title":"getxy – learn_dg"},{"text":"private function getArow(N, xi, eta) result(row) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N real(kind=wp), intent(in) :: xi real(kind=wp), intent(in) :: eta Return Value real(kind=wp),\n  dimension(N) Calls proc~~getarow~~CallsGraph proc~getarow getArow interface~pascal pascal proc~getarow->interface~pascal Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called By proc~~getarow~~CalledByGraph proc~getarow getArow proc~getjacobian getJacobian proc~getjacobian->proc~getarow Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code getArow Source Code function getArow ( N , xi , eta ) result ( row ) integer , intent ( in ) :: N real ( wp ), intent ( in ) :: xi , eta real ( wp ), dimension ( N ) :: row if ( N == 4 ) then row = pascal ( 1 , xi , eta ) elseif ( N == 9 ) then ! row = [1._wp, & !       xi, eta, & !       xi**2._wp, xi*eta, eta**2._wp, & !       xi**2._wp * eta, xi * eta**2._wp, & !       xi**2._wp * eta**2._wp] row = pascal ( 2 , xi , eta ) elseif ( N == 16 ) then ! row = [1._wp, & !       xi, eta, & !       xi**2._wp, xi*eta, eta**2._wp, & !       xi**3._wp, xi**2._wp * eta, xi * eta**2._wp, eta**3._wp, & !       xi**3._wp * eta, xi**2._wp * eta**2._wp, xi * eta**3._wp, & !       xi**3._wp * eta**2._wp, xi**2._wp * eta**3._wp, & !       xi**3._wp * eta**3._wp] row = pascal ( 3 , xi , eta ) ! else ! !   print*, \"Unsupported number of nodes selected: \", N !   stop \"Number of nodes must be either 4, 9, or 16\" endif return end function getArow","tags":"","loc":"proc/getarow.html","title":"getArow – learn_dg"},{"text":"private function getAlpha(N) result(alpha) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N Return Value real(kind=wp),\n  dimension(N,N) Calls proc~~getalpha~~CallsGraph proc~getalpha getAlpha proc~eye eye proc~getalpha->proc~eye proc~linsolve_quick linsolve_quick proc~getalpha->proc~linsolve_quick proc~linsolve linsolve proc~linsolve_quick->proc~linsolve dgetrs dgetrs proc~linsolve->dgetrs dgetrf dgetrf proc~linsolve->dgetrf Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called By proc~~getalpha~~CalledByGraph proc~getalpha getAlpha proc~assembleelementalmatrix assembleElementalMatrix proc~assembleelementalmatrix->proc~getalpha Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code getAlpha Source Code function getAlpha ( N ) result ( alpha ) integer , intent ( in ) :: N real ( wp ), dimension ( N , N ) :: alpha integer :: ii real ( wp ), dimension ( N , N ) :: A , B A = getA ( N ) B = eye ( N ) call linsolve_quick ( N , A , N , B , alpha ) return contains function getA ( N ) result ( A ) integer , intent ( in ) :: N real ( wp ), dimension ( N , N ) :: A integer :: ii real ( wp ), dimension ( N , 2 ) :: xy xy = getxy ( N ) do ii = 1 , N A ( ii ,:) = getArow ( N , xy ( ii , 1 ), xy ( ii , 2 )) enddo return end function getA end function getAlpha","tags":"","loc":"proc/getalpha.html","title":"getAlpha – learn_dg"},{"text":"private function getJacobian(N, xi, eta, xy, alpha) result(J) Calculates the Jacobian of a quadrilateral element The Jacobian of an element is defined as:\n  \\textbf{J} = \\textbf{P} \\textbf{X}  Where:\n  \\textbf{P} = \\left[ \\begin{array}{cc}\n     \\frac{\\partial H_1}{\\partial \\xi} & \\frac{\\partial H_2}{\\partial \\xi} \\\\\n     \\frac{\\partial H_1}{\\partial \\eta} & \\frac{\\partial H_2}{\\partial \\eta} \\end{array}\n       \\cdots\n     \\begin{array}{cc}\n     \\frac{\\partial H_{N-1}}{\\partial \\xi} & \\frac{\\partial H_{N}}{\\partial \\xi} \\\\\n     \\frac{\\partial H_{N-1}}{\\partial \\eta} & \\frac{\\partial H_{N}}{\\partial \\eta} \\end{array}\n \\right]  X = \\left[ \\begin{array}{rcl}\n       x_1 & & y_1 \\\\\n       x_2 & & y_2 \\\\\n       & \\vdots & \\\\\n       x_{N-1} & & y_{N-1} \\\\\n       x_N & & y_N \\\\\n   \\end{array} \\right] Note The following below doesn't work with MathJax and is being rendered incorrectly for some reason:  X = \\left[ \\begin{array}{c}\n      \\begin{array}{cc}\n        x_1 & y_1 \\\\\n        x_2 & y_2\n      \\end{array} \\\n      \\vdots \\\n      \\begin{array}{cc}\n        x_{N-1} & y_{N-1} \\\\\n        x_N & y_N\n      \\end{array} \\\\\n    \\end{array} \\right]  H_i  : Basis function i  x_i  : X-coordinate of node i  y_i  : Y-coordinate of node i Arguments Type Intent Optional Attributes Name integer, intent(in) :: N Number of points in element real(kind=wp), intent(in) :: xi real(kind=wp), intent(in) :: eta real(kind=wp), intent(in), dimension(N,2) :: xy real(kind=wp), intent(in), dimension(N,N) :: alpha Return Value real(kind=wp),\n  dimension(2,2) Calls proc~~getjacobian~~CallsGraph proc~getjacobian getJacobian proc~getarow getArow proc~getjacobian->proc~getarow interface~pascal pascal proc~getarow->interface~pascal Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code getJacobian Source Code function getJacobian ( N , xi , eta , xy , alpha ) result ( J ) !* ! Calculates the Jacobian of a quadrilateral element ! ! The Jacobian of an element is defined as: !  \\textbf{J} = \\textbf{P} \\textbf{X}  ! ! Where: !  \\textbf{P} = \\left[ \\begin{array}{cc} !     \\frac{\\partial H_1}{\\partial \\xi} & \\frac{\\partial H_2}{\\partial \\xi} \\\\ !     \\frac{\\partial H_1}{\\partial \\eta} & \\frac{\\partial H_2}{\\partial \\eta} \\end{array} !       \\cdots !     \\begin{array}{cc} !     \\frac{\\partial H_{N-1}}{\\partial \\xi} & \\frac{\\partial H_{N}}{\\partial \\xi} \\\\ !     \\frac{\\partial H_{N-1}}{\\partial \\eta} & \\frac{\\partial H_{N}}{\\partial \\eta} \\end{array} ! \\right] ! !  X = \\left[ \\begin{array}{rcl} !       x_1 & & y_1 \\\\ !       x_2 & & y_2 \\\\ !       & \\vdots & \\\\ !       x_{N-1} & & y_{N-1} \\\\ !       x_N & & y_N \\\\ !   \\end{array} \\right] ! ! @note The following below doesn't work with MathJax and is being rendered incorrectly for some reason: ! !  X = \\left[ \\begin{array}{c} !      \\begin{array}{cc} !        x_1 & y_1 \\\\ !        x_2 & y_2 !      \\end{array} \\\\ !      \\vdots \\\\ !      \\begin{array}{cc} !        x_{N-1} & y_{N-1} \\\\ !        x_N & y_N !      \\end{array} \\\\ !    \\end{array} \\right] ! ! *  H_i  : Basis function i ! *  x_i  : X-coordinate of node i ! *  y_i  : Y-coordinate of node i integer , intent ( in ) :: N !! Number of points in element real ( wp ), intent ( in ) :: xi !! real ( wp ), intent ( in ) :: eta !! real ( wp ), dimension ( N , 2 ), intent ( in ) :: xy !! real ( wp ), dimension ( N , N ), intent ( in ) :: alpha !! real ( wp ), dimension ( 2 , 2 ) :: J !! integer :: ii !! real ( wp ), parameter :: eps = epsilon ( 0 e0 ) real ( wp ), dimension ( 2 , N ) :: P !! Array of real ( wp ), dimension ( N ) :: x !! Row in element coefficient matrix ! P is a matrix containing derivatives of each basis function at (xi,eta) ! P = [dN_1/dxi, dN_2/dxi, dN_3/dxi, ... !      dN_1/deta, dN_2/deta, dN_3/deta, ...] do ii = 1 , N x = alpha (:, ii ) P ( 1 , ii ) = dot_product ( x , getArow ( N , xi + eps , eta )) - & dot_product ( x , getArow ( N , xi - eps , eta )) P ( 2 , ii ) = dot_product ( x , getArow ( N , xi , eta + eps )) - & dot_product ( x , getArow ( N , xi , eta - eps )) enddo P = P / ( 2._wp * eps ) J = matmul ( P , xy ) return end function getJacobian","tags":"","loc":"proc/getjacobian.html","title":"getJacobian – learn_dg"},{"text":"public function assembleElementalMatrix(N, d1, d2, xy) result(Ie) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N integer, intent(in) :: d1 integer, intent(in) :: d2 real(kind=wp), intent(in), dimension(N,2) :: xy Return Value real(kind=wp),\n  dimension(N,N) Calls proc~~assembleelementalmatrix~~CallsGraph proc~assembleelementalmatrix assembleElementalMatrix proc~getalpha getAlpha proc~assembleelementalmatrix->proc~getalpha integrate2d integrate2d proc~assembleelementalmatrix->integrate2d proc~eye eye proc~getalpha->proc~eye proc~linsolve_quick linsolve_quick proc~getalpha->proc~linsolve_quick proc~linsolve linsolve proc~linsolve_quick->proc~linsolve dgetrs dgetrs proc~linsolve->dgetrs dgetrf dgetrf proc~linsolve->dgetrf Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code assembleElementalMatrix Source Code function assembleElementalMatrix ( N , d1 , d2 , xy ) result ( Ie ) ! Dummy variables integer , intent ( in ) :: N , d1 , d2 real ( wp ), dimension ( N , 2 ), intent ( in ) :: xy real ( wp ), dimension ( N , N ) :: Ie ! Local variables integer :: N1 , N2 real ( wp ), dimension ( N , N ) :: alpha ! Get the coefficients of the basis functions (alpha). Both bi-linear (N=4) ! and bi-quadratic (N=9) quadrilaterals are supported. alpha = getAlpha ( N ) Ie = 0._wp do N1 = 1 , N do N2 = 1 , N ! fun is now implicitly defined using the following: N1, N2, d1, and d2 Ie ( N1 , N2 ) = Ie ( N1 , N2 ) + integrate2D ( fun ) enddo enddo contains function fun ( xi , eta ) result ( out ) ! Dummy variables real ( wp ), dimension (:,:), intent ( in ) :: xi , eta real ( wp ), dimension (:,:), allocatable :: out ! Local variables integer :: ii , jj , num_pts real ( wp ), parameter :: eps = epsilon ( 0 e0 ) real ( wp ) :: fun1 , fun2 real ( wp ), dimension ( 2 ) :: dfun1 , dfun2 real ( wp ) :: detJ real ( wp ), dimension ( 2 , 2 ) :: J , invJ ! Initialize function output. Actual number of pts is num_pts*num_pts, ! because the meshgrid goes in both x and y directions. Only need one. num_pts = size ( xi , 1 ) allocate ( out ( num_pts , num_pts )) out = 0._wp do ii = 1 , num_pts do jj = 1 , num_pts ! Calculate Jacobian, inverse Jacobian, and determinant of finite ! element at (xi,eta) J = getJacobian ( N , xi ( ii , jj ), eta ( ii , jj ), xy , alpha ) invJ = inv2 ( J ) detJ = det2 ( J ) ! If fun1 is just N_i, use dot_product to determine N_i if ( d1 == 0 ) then fun1 = dot_product ( alpha (:, N1 ), getArow ( N , xi ( ii , jj ), eta ( ii , jj ))) else ! If fun1 contains a derivative, need to calc N_i,xi and N_i,eta dfun1 ( 1 ) = ( & dot_product ( alpha (:, N1 ), getArow ( N , xi ( ii , jj ) + eps , eta ( ii , jj ))) - & dot_product ( alpha (:, N1 ), getArow ( N , xi ( ii , jj ) - eps , eta ( ii , jj ))) & ) / ( 2._wp * eps ) dfun1 ( 2 ) = ( & dot_product ( alpha (:, N1 ), getArow ( N , xi ( ii , jj ), eta ( ii , jj ) + eps )) - & dot_product ( alpha (:, N1 ), getArow ( N , xi ( ii , jj ), eta ( ii , jj ) - eps )) & ) / ( 2._wp * eps ) ! N_i,x = dxi/dx * N_i,xi + deta/dx * N_i,eta fun1 = dot_product ( invJ ( d1 ,:), dfun1 ) endif ! If fun2 is just N_i, use dot_product to determine N_i if ( d2 == 0 ) then fun2 = dot_product ( alpha (:, N2 ), getArow ( N , xi ( ii , jj ), eta ( ii , jj ))) else ! If fun2 contains a derivative, need to calc N_i,xi and N_i,eta dfun2 ( 1 ) = ( & dot_product ( alpha (:, N2 ), & getArow ( N , xi ( ii , jj ) + eps , eta ( ii , jj ))) - & dot_product ( alpha (:, N2 ), & getArow ( N , xi ( ii , jj ) - eps , eta ( ii , jj ))) & ) / ( 2._wp * eps ) dfun2 ( 2 ) = ( & dot_product ( alpha (:, N2 ), getArow ( N , xi ( ii , jj ), eta ( ii , jj ) + eps )) - & dot_product ( alpha (:, N2 ), getArow ( N , xi ( ii , jj ), eta ( ii , jj ) - eps )) & ) / ( 2._wp * eps ) ! N_i,y = dxi/dy * N_i,xi + deta/dy * N_i,eta fun2 = dot_product ( invJ ( d2 ,:), dfun2 ) endif out ( ii , jj ) = fun1 * fun2 * detJ enddo enddo return end function fun end function assembleElementalMatrix","tags":"","loc":"proc/assembleelementalmatrix.html","title":"assembleElementalMatrix – learn_dg"},{"text":"public subroutine getIe(dii, djj, xcoords, Ie) Routine to calculate the elemental mass/stiffness matrix based on the\n   derivatives of the basis functions. Currently only zero-th and first order derivatives are supported. Second\n   order derivatives need to be reduced to first order derivatives in the\n   problem formulation using Green's Theorem Arguments Type Intent Optional Attributes Name integer, intent(in) :: dii Derivative of the first basis function integer, intent(in) :: djj Derivative of the second basis function real(kind=wp), intent(in), dimension(:) :: xcoords Coordinates of the 1D line element real(kind=wp), intent(out), dimension(:,:) :: Ie Output elemental matrix Calls proc~~getie~~CallsGraph proc~getie getIe proc~integrate_basis_1d_ie integrate_basis_1d_Ie proc~getie->proc~integrate_basis_1d_ie proc~vandermonde vandermonde proc~integrate_basis_1d_ie->proc~vandermonde proc~integrate integrate proc~integrate_basis_1d_ie->proc~integrate linspace linspace proc~vandermonde->linspace proc~linsolve_quick linsolve_quick proc~vandermonde->proc~linsolve_quick proc~gaussquad gaussquad proc~integrate->proc~gaussquad proc~linsolve linsolve proc~linsolve_quick->proc~linsolve dgetrs dgetrs proc~linsolve->dgetrs dgetrf dgetrf proc~linsolve->dgetrf proc~gaussquad_rosetta gaussquad_rosetta proc~gaussquad->proc~gaussquad_rosetta var panprocgetieCallsGraph = svgPanZoom('#procgetieCallsGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code getIe Source Code subroutine getIe ( dii , djj , xcoords , Ie ) !*  Routine to calculate the elemental mass/stiffness matrix based on the !   derivatives of the basis functions. ! !   Currently only zero-th and first order derivatives are supported. Second !   order derivatives need to be reduced to first order derivatives in the !   problem formulation using Green's Theorem integer , intent ( in ) :: dii !! Derivative of the first basis function integer , intent ( in ) :: djj !! Derivative of the second basis function real ( wp ), intent ( in ), dimension (:) :: xcoords !! Coordinates of the 1D line element real ( wp ), intent ( out ), dimension (:,:) :: Ie !! Output elemental matrix integer :: ii , jj , order order = size ( xcoords ) - 1 do ii = 1 , size ( xcoords ) Ie ( ii , :) = [( integrate_basis_1d_Ie ( order , ii , jj , dii , djj , xcoords ), jj = 1 , order + 1 )] enddo return end subroutine getIe","tags":"","loc":"proc/getie.html","title":"getIe – learn_dg"},{"text":"private subroutine vandermonde(n, Vinv) Arguments Type Intent Optional Attributes Name integer :: n real(kind=wp), dimension(n, n) :: Vinv Calls proc~~vandermonde~~CallsGraph proc~vandermonde vandermonde linspace linspace proc~vandermonde->linspace proc~linsolve_quick linsolve_quick proc~vandermonde->proc~linsolve_quick proc~linsolve linsolve proc~linsolve_quick->proc~linsolve dgetrs dgetrs proc~linsolve->dgetrs dgetrf dgetrf proc~linsolve->dgetrf Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called By proc~~vandermonde~~CalledByGraph proc~vandermonde vandermonde proc~integrate_basis_1d_ie integrate_basis_1d_Ie proc~integrate_basis_1d_ie->proc~vandermonde proc~getie getIe proc~getie->proc~integrate_basis_1d_ie Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code vandermonde Source Code subroutine vandermonde ( n , Vinv ) integer :: ii , jj integer :: n real ( wp ), dimension ( n ) :: x real ( wp ), dimension (( n ) ** 2 ) :: V_flat real ( wp ), dimension ( n , n ) :: V , Vinv , eye call linspace ( - 1._wp , 1._wp , x ) V_flat = [( [( [ x ( ii ) ** real ( jj - 1 , wp )], ii = 1 , n )], jj = 1 , n )] V = reshape ([ V_flat ], [ n , n ]) ! call r8mat_print(n, n, V, 'Original V Matrix: ') eye = 0._wp do ii = 1 , n eye ( ii , ii ) = 1._wp enddo call linsolve_quick ( n , V , n , eye , Vinv ) return end subroutine vandermonde","tags":"","loc":"proc/vandermonde.html","title":"vandermonde – learn_dg"},{"text":"public interface pascal Called By interface~~pascal~~CalledByGraph interface~pascal pascal proc~getarow getArow proc~getarow->interface~pascal proc~getjacobian getJacobian proc~getjacobian->proc~getarow Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Functions pascal_1D_line pascal_2D_quad Functions public function pascal_1D_line(N, x) result(row) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N real(kind=wp), intent(in) :: x Return Value real(kind=wp),\n  dimension(N+1) public function pascal_2D_quad(N, x, y) result(row) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N real(kind=wp), intent(in) :: x real(kind=wp), intent(in) :: y Return Value real(kind=wp),\n  dimension(N+1)","tags":"","loc":"interface/pascal.html","title":"pascal – learn_dg"},{"text":"public pure function eye(N) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N Return Value real(kind=wp),\n  dimension(N,N) Called By proc~~eye~~CalledByGraph proc~eye eye proc~getalpha getAlpha proc~getalpha->proc~eye program~doubleint doubleint program~doubleint->proc~eye proc~assembleelementalmatrix assembleElementalMatrix proc~assembleelementalmatrix->proc~getalpha Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code eye Source Code pure function eye ( N ) integer , intent ( in ) :: N real ( wp ), dimension ( N , N ) :: eye integer :: ii eye = 0._wp ; forall ( ii = 1 : N ) eye ( ii , ii ) = 1._wp return end function eye","tags":"","loc":"proc/eye.html","title":"eye – learn_dg"},{"text":"public pure function inv2(J) result(invJ) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(2,2) :: J Return Value real(kind=wp),\n  dimension(2,2) Calls proc~~inv2~~CallsGraph proc~inv2 inv2 proc~det2 det2 proc~inv2->proc~det2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code inv2 Source Code pure function inv2 ( J ) result ( invJ ) real ( wp ), dimension ( 2 , 2 ), intent ( in ) :: J real ( wp ), dimension ( 2 , 2 ) :: invJ invJ = reshape ( [ J ( 2 , 2 ), - J ( 2 , 1 ), - J ( 1 , 2 ), J ( 1 , 1 )], [ 2 , 2 ] ) invJ = invJ / det2 ( J ) return end function inv2","tags":"","loc":"proc/inv2.html","title":"inv2 – learn_dg"},{"text":"public pure function det2(A) result(det) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(2,2) :: A Return Value real(kind=wp) Called By proc~~det2~~CalledByGraph proc~det2 det2 proc~inv2 inv2 proc~inv2->proc~det2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code det2 Source Code pure function det2 ( A ) result ( det ) ! Computes the determinant of a 2x2 matrix real ( wp ), dimension ( 2 , 2 ), intent ( in ) :: A real ( wp ) :: det det = A ( 1 , 1 ) * A ( 2 , 2 ) - A ( 1 , 2 ) * A ( 2 , 1 ) return end function det2","tags":"","loc":"proc/det2.html","title":"det2 – learn_dg"},{"text":"public subroutine linsolve_quick(n, a, nrhs, b, x) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=wp), intent(in), dimension(n, n) :: a integer, intent(in) :: nrhs real(kind=wp), intent(in), dimension(n, nrhs) :: b real(kind=wp), intent(out), dimension(n, nrhs) :: x Calls proc~~linsolve_quick~~CallsGraph proc~linsolve_quick linsolve_quick proc~linsolve linsolve proc~linsolve_quick->proc~linsolve dgetrs dgetrs proc~linsolve->dgetrs dgetrf dgetrf proc~linsolve->dgetrf Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called By proc~~linsolve_quick~~CalledByGraph proc~linsolve_quick linsolve_quick proc~vandermonde vandermonde proc~vandermonde->proc~linsolve_quick program~main main program~main->proc~linsolve_quick program~doubleint doubleint program~doubleint->proc~linsolve_quick proc~getalpha getAlpha proc~getalpha->proc~linsolve_quick proc~integrate_basis_1d_ie integrate_basis_1d_Ie proc~integrate_basis_1d_ie->proc~vandermonde proc~getie getIe proc~getie->proc~integrate_basis_1d_ie proc~assembleelementalmatrix assembleElementalMatrix proc~assembleelementalmatrix->proc~getalpha Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code linsolve_quick Source Code subroutine linsolve_quick ( n , a , nrhs , b , x ) ! Quick wrapper around linsolve integer , intent ( in ) :: n , nrhs real ( wp ), intent ( in ), dimension ( n , n ) :: a real ( wp ), intent ( in ), dimension ( n , nrhs ) :: b real ( wp ), intent ( out ), dimension ( n , nrhs ) :: x integer , dimension ( n ) :: P real ( wp ), dimension ( n , n ) :: LU call linsolve ( n , a , nrhs , b , x , LU , P , . False .) return end subroutine linsolve_quick","tags":"","loc":"proc/linsolve_quick.html","title":"linsolve_quick – learn_dg"},{"text":"public subroutine linsolve(n, a, nrhs, b, x, LU, P, toggle) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=wp), intent(in), dimension(n, n) :: a integer, intent(in) :: nrhs real(kind=wp), intent(in), dimension(n, nrhs) :: b real(kind=wp), intent(out), dimension(n, nrhs) :: x real(kind=wp), intent(inout), dimension(n, n) :: LU integer, intent(inout), dimension(n) :: P logical, intent(in) :: toggle Calls proc~~linsolve~~CallsGraph proc~linsolve linsolve dgetrs dgetrs proc~linsolve->dgetrs dgetrf dgetrf proc~linsolve->dgetrf Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called By proc~~linsolve~~CalledByGraph proc~linsolve linsolve proc~linsolve_quick linsolve_quick proc~linsolve_quick->proc~linsolve proc~vandermonde vandermonde proc~vandermonde->proc~linsolve_quick program~main main program~main->proc~linsolve_quick program~doubleint doubleint program~doubleint->proc~linsolve_quick proc~getalpha getAlpha proc~getalpha->proc~linsolve_quick proc~integrate_basis_1d_ie integrate_basis_1d_Ie proc~integrate_basis_1d_ie->proc~vandermonde proc~getie getIe proc~getie->proc~integrate_basis_1d_ie proc~assembleelementalmatrix assembleElementalMatrix proc~assembleelementalmatrix->proc~getalpha Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code linsolve Source Code subroutine linsolve ( n , a , nrhs , b , x , LU , P , toggle ) ! This routine is a wrapper dgesv, splitting it into its two primary ! components: !             dgetrf - Decomposes A into P*L*U !             dgetrs - Uses P*L*U to solve for x (Ax=b => (P*L*U)x=b) ! ! Splitting these two up like this allows you to save the decomposed ! version of 'a' so that you don't have to do it again. If 'toggle' is ! equal to true, then the decomposition has already occured and LU can be ! trusted - OK to skip dgetrf ! Dummy variables integer , intent ( in ) :: n , nrhs integer , intent ( inout ), dimension ( n ) :: P real ( wp ), intent ( in ), dimension ( n , nrhs ) :: b real ( wp ), intent ( in ), dimension ( n , n ) :: a real ( wp ), intent ( out ), dimension ( n , nrhs ) :: x real ( wp ), intent ( inout ), dimension ( n , n ) :: LU logical , intent ( in ) :: toggle ! Local variables integer :: info integer , dimension ( n ) :: my_P real ( wp ), dimension ( n , n ) :: my_a real ( wp ), dimension ( n , nrhs ) :: my_b my_a = a my_b = b if ( . not . toggle ) then call dgetrf ( n , n , my_a , n , my_P , info ) if ( info /= 0 ) then write ( * , '(a)' ) ' ' write ( * , '(a)' ) 'DGETRF' write ( * , '(a,i8)' ) '  Factorization failed, INFO = ' , info stop endif LU = my_a P = my_P endif call dgetrs ( 'No transpose' , n , nrhs , LU , n , P , my_b , n , info ) if ( info /= 0 ) then write ( * , '(a)' ) ' ' write ( * , '(a)' ) 'DGETRS' write ( * , '(a,i8)' ) '  Back substitution failed, INFO = ' , info stop endif x = my_b return end subroutine linsolve","tags":"","loc":"proc/linsolve.html","title":"linsolve – learn_dg"},{"text":"public subroutine r8mat_print(m, n, a, title) R8MAT_PRINT prints an R8MAT. Discussion: An R8MAT is a two dimensional matrix of double precision real values. Licensing: This code is distributed under the GNU LGPL license. Modified: 12 September 2004 Author: John Burkardt Parameters: Input, integer M, the number of rows in A.\n\nInput, integer N, the number of columns in A.\n\nInput, real ( kind = 8 ) A(M,N), the matrix.\n\nInput, character ( len = * ) TITLE, a title to be printed. Arguments Type Intent Optional Attributes Name integer(kind=4) :: m integer(kind=4) :: n real(kind=8) :: a (m,n) character(len=*) :: title Calls proc~~r8mat_print~~CallsGraph proc~r8mat_print r8mat_print proc~r8mat_print_some r8mat_print_some proc~r8mat_print->proc~r8mat_print_some Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called By proc~~r8mat_print~~CalledByGraph proc~r8mat_print r8mat_print program~doubleint doubleint program~doubleint->proc~r8mat_print Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code r8mat_print Source Code subroutine r8mat_print ( m , n , a , title ) ! ************************************************************************** ! !* R8MAT_PRINT prints an R8MAT. ! !  Discussion: ! !    An R8MAT is a two dimensional matrix of double precision real values. ! !  Licensing: ! !    This code is distributed under the GNU LGPL license. ! !  Modified: ! !    12 September 2004 ! !  Author: ! !    John Burkardt ! !  Parameters: ! !    Input, integer M, the number of rows in A. ! !    Input, integer N, the number of columns in A. ! !    Input, real ( kind = 8 ) A(M,N), the matrix. ! !    Input, character ( len = * ) TITLE, a title to be printed. implicit none integer ( kind = 4 ) m integer ( kind = 4 ) n real ( kind = 8 ) a ( m , n ) character ( len = * ) title call r8mat_print_some ( m , n , a , 1 , 1 , m , n , title ) return end subroutine r8mat_print","tags":"","loc":"proc/r8mat_print.html","title":"r8mat_print – learn_dg"},{"text":"private subroutine r8mat_print_some(m, n, a, ilo, jlo, ihi, jhi, title) R8MAT_PRINT_SOME prints some of an R8MAT. Discussion: An R8MAT is a two dimensional matrix of double precision real values. Licensing: This code is distributed under the GNU LGPL license. Modified: 26 March 2005 Author: John Burkardt Parameters: Input, integer M, N, the number of rows and columns.\n\nInput, real ( kind = 8 ) A(M,N), an M by N matrix to be printed.\n\nInput, integer ILO, JLO, the first row and column to print.\n\nInput, integer IHI, JHI, the last row and column to print.\n\nInput, character ( len = * ) TITLE, an optional title. Arguments Type Intent Optional Attributes Name integer(kind=4) :: m integer(kind=4) :: n real(kind=8) :: a (m,n) integer(kind=4) :: ilo integer(kind=4) :: jlo integer(kind=4) :: ihi integer(kind=4) :: jhi character(len=*) :: title Called By proc~~r8mat_print_some~~CalledByGraph proc~r8mat_print_some r8mat_print_some proc~r8mat_print r8mat_print proc~r8mat_print->proc~r8mat_print_some program~doubleint doubleint program~doubleint->proc~r8mat_print Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code r8mat_print_some Source Code subroutine r8mat_print_some ( m , n , a , ilo , jlo , ihi , jhi , title ) ! ************************************************************************** ! !* R8MAT_PRINT_SOME prints some of an R8MAT. ! !  Discussion: ! !    An R8MAT is a two dimensional matrix of double precision real values. ! !  Licensing: ! !    This code is distributed under the GNU LGPL license. ! !  Modified: ! !    26 March 2005 ! !  Author: ! !    John Burkardt ! !  Parameters: ! !    Input, integer M, N, the number of rows and columns. ! !    Input, real ( kind = 8 ) A(M,N), an M by N matrix to be printed. ! !    Input, integer ILO, JLO, the first row and column to print. ! !    Input, integer IHI, JHI, the last row and column to print. ! !    Input, character ( len = * ) TITLE, an optional title. implicit none integer ( kind = 4 ), parameter :: incx = 5 integer ( kind = 4 ) m integer ( kind = 4 ) n real ( kind = 8 ) a ( m , n ) character ( len = 14 ) ctemp ( incx ) integer ( kind = 4 ) i integer ( kind = 4 ) i2hi integer ( kind = 4 ) i2lo integer ( kind = 4 ) ihi integer ( kind = 4 ) ilo integer ( kind = 4 ) inc integer ( kind = 4 ) j integer ( kind = 4 ) j2 integer ( kind = 4 ) j2hi integer ( kind = 4 ) j2lo integer ( kind = 4 ) jhi integer ( kind = 4 ) jlo character ( len = * ) title if ( 0 < len_trim ( title ) ) then write ( * , '(a)' ) ' ' write ( * , '(a)' ) trim ( title ) endif do j2lo = max ( jlo , 1 ), min ( jhi , n ), incx j2hi = j2lo + incx - 1 j2hi = min ( j2hi , n ) j2hi = min ( j2hi , jhi ) inc = j2hi + 1 - j2lo write ( * , '(a)' ) ' ' do j = j2lo , j2hi j2 = j + 1 - j2lo write ( ctemp ( j2 ), '(i8,6x)' ) j enddo write ( * , '(''  Col   '',5a14)' ) ctemp ( 1 : inc ) write ( * , '(a)' ) '  Row' write ( * , '(a)' ) ' ' i2lo = max ( ilo , 1 ) i2hi = min ( ihi , m ) do i = i2lo , i2hi do j2 = 1 , inc j = j2lo - 1 + j2 if ( a ( i , j ) == real ( int ( a ( i , j ) ), kind = 8 ) ) then write ( ctemp ( j2 ), '(f8.0,6x)' ) a ( i , j ) else write ( ctemp ( j2 ), '(g14.6)' ) a ( i , j ) endif enddo write ( * , '(i5,1x,5a14)' ) i , ( ctemp ( j ), j = 1 , inc ) enddo enddo write ( * , '(a)' ) ' ' return end subroutine r8mat_print_some","tags":"","loc":"proc/r8mat_print_some.html","title":"r8mat_print_some – learn_dg"},{"text":"pure function pascal_2D_row(N, x, y) result(row) Generates a row of Pascal's triangle in 2D, where rows are 0-indexed Pascal's triangle in 2D looks like this:\n    [1] \n    [x,~ y] \n    [x&#94;2,~ x y,~ y&#94;2] \n    [x&#94;3,~ x&#94;2y,~ xy&#94;2,~ y&#94;3] \n    [x&#94;4,~ x&#94;3y,~ x&#94;2y&#94;2,~ xy&#94;3, y&#94;4] \n    \\vdots \n    [x&#94;N,~ x&#94;{N-1}y,~ \\cdots,~ xy&#94;{N-1},~ y&#94;N]  Therefore, the third row (index=2) would be x&#94;2, x\\cdot y, y&#94;2 Arguments Type Intent Optional Attributes Name integer, intent(in) :: N Row number of pascal's 2D triange (0-indexed) real(kind=wp), intent(in) :: x X-value used in triange real(kind=wp), intent(in) :: y Y-Value used in triange Return Value real(kind=wp),\n  dimension(N+1) Output row of triange Called By proc~~pascal_2d_row~~CalledByGraph proc~pascal_2d_row pascal_2D_row proc~pascal_2d_quad pascal_2D_quad proc~pascal_2d_quad->proc~pascal_2d_row Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code pascal_2D_row Source Code pure function pascal_2D_row ( N , x , y ) result ( row ) !* ! Generates a row of Pascal's triangle in 2D, where rows are 0-indexed ! ! Pascal's triangle in 2D looks like this: !    [1]  !    [x,~ y]  !    [x&#94;2,~ x y,~ y&#94;2]  !    [x&#94;3,~ x&#94;2y,~ xy&#94;2,~ y&#94;3]  !    [x&#94;4,~ x&#94;3y,~ x&#94;2y&#94;2,~ xy&#94;3, y&#94;4]  !    \\vdots  !    [x&#94;N,~ x&#94;{N-1}y,~ \\cdots,~ xy&#94;{N-1},~ y&#94;N]  ! ! Therefore, the third row (index=2) would be x&#94;2, x\\cdot y, y&#94;2 integer , intent ( in ) :: N !! Row number of pascal's 2D triange (0-indexed) real ( wp ), intent ( in ) :: x !! X-value used in triange real ( wp ), intent ( in ) :: y !! Y-Value used in triange real ( wp ), dimension ( N + 1 ) :: row !! Output row of triange integer :: ii ! Produces the elements of an array: [x&#94;N, x&#94;(N-1)*y, x&#94;(N-2)*y&#94;2, ..., y&#94;N] row = [( x ** ( N - ii ) * y ** ( ii ), ii = 0 , N )] return end function pascal_2D_row","tags":"","loc":"proc/pascal_2d_row.html","title":"pascal_2D_row – learn_dg"},{"text":"function pascal_1D_line(N, x) result(row) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N real(kind=wp), intent(in) :: x Return Value real(kind=wp),\n  dimension(N+1) Source Code pascal_1D_line Source Code module function pascal_1D_line ( N , x ) result ( row ) integer , intent ( in ) :: N real ( wp ), intent ( in ) :: x real ( wp ), dimension ( N + 1 ) :: row integer :: ii ! Produces the elements of an array: [1, x, x&#94;2, ..., x&#94;N] row = [( x ** ( ii - 1 ), ii = 1 , N + 1 )] return end function pascal_1D_line","tags":"","loc":"proc/pascal_1d_line.html","title":"pascal_1D_line – learn_dg"},{"text":"function pascal_2D_quad(N, x, y) result(row) Generates an array of points related to a quadrilateral using Pascal's\n triangle in 2D, where rows are 0-indexed Pascal's triangle in 2D looks like this, with points used in bi-quadratic quadrilateral in bold:\n    [\\mathbf{1}] \n    [\\mathbf{x},~ \\mathbf{y}] \n    [\\mathbf{x&#94;2},~ \\mathbf{x y},~ \\mathbf{y&#94;2}] \n    [x&#94;3,~ \\mathbf{x&#94;2y},~ \\mathbf{xy&#94;2},~ y&#94;3] \n    [x&#94;4,~ x&#94;3y,~ \\mathbf{x&#94;2y&#94;2},~ xy&#94;3, y&#94;4] \n    \\vdots \n    [x&#94;N,~ x&#94;{N-1}y,~ \\cdots ~,~ xy&#94;{N-1},~ y&#94;N]  Arguments Type Intent Optional Attributes Name integer, intent(in) :: N Order of the qaudrilateral real(kind=wp), intent(in) :: x X-coordinate of node used in calculation real(kind=wp), intent(in) :: y Y-coordinate of node used in calculation Return Value real(kind=wp),\n  dimension((N+1)**2) Output row Calls proc~~pascal_2d_quad~~CallsGraph proc~pascal_2d_quad pascal_2D_quad proc~pascal_2d_row pascal_2D_row proc~pascal_2d_quad->proc~pascal_2d_row Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code pascal_2D_quad Source Code module function pascal_2D_quad ( N , x , y ) result ( row ) !* ! Generates an array of points related to a quadrilateral using Pascal's ! triangle in 2D, where rows are 0-indexed ! ! Pascal's triangle in 2D looks like this, with points used in bi-quadratic quadrilateral in bold: !    [\\mathbf{1}]  !    [\\mathbf{x},~ \\mathbf{y}]  !    [\\mathbf{x&#94;2},~ \\mathbf{x y},~ \\mathbf{y&#94;2}]  !    [x&#94;3,~ \\mathbf{x&#94;2y},~ \\mathbf{xy&#94;2},~ y&#94;3]  !    [x&#94;4,~ x&#94;3y,~ \\mathbf{x&#94;2y&#94;2},~ xy&#94;3, y&#94;4]  !    \\vdots  !    [x&#94;N,~ x&#94;{N-1}y,~ \\cdots ~,~ xy&#94;{N-1},~ y&#94;N]  integer , intent ( in ) :: N !! Order of the qaudrilateral real ( wp ), intent ( in ) :: x !! X-coordinate of node used in calculation real ( wp ), intent ( in ) :: y !! Y-coordinate of node used in calculation real ( wp ), dimension (( N + 1 ) ** 2 ) :: row !! Output row integer :: ii , start , finish real ( wp ), dimension (:), allocatable :: temp , temp_pre , temp_post row = 0.d0 ! Collects the first N rows of a 2D pascal triangle as function of x and y temp_pre = [( pascal_2D_row ( ii , x , y ), ii = 0 , N )] temp_post = [( pascal_2D_quad_post ( N , ii , x , y ), ii = N + 1 , 2 * N )] row = [ temp_pre , temp_post ] return contains pure function pascal_2D_quad_post ( N , ii , x , y ) result ( row ) integer , intent ( in ) :: N , ii real ( wp ), intent ( in ) :: x , y real ( wp ), dimension ( 2 * N - ii + 1 ) :: row integer :: start , finish real ( wp ), dimension (:), allocatable :: temp temp = pascal_2D_row ( ii , x , y ) start = ii - N + 1 finish = ii - ( ii - N ) + 1 row = temp ( start : finish ) return end function pascal_2D_quad_post end function pascal_2D_quad","tags":"","loc":"proc/pascal_2d_quad.html","title":"pascal_2D_quad – learn_dg"},{"text":"Uses: iso_fortran_env legendre module~~assembly~~UsesGraph module~assembly assembly module~legendre legendre module~legendre->module~assembly iso_fortran_env iso_fortran_env iso_fortran_env->module~assembly iso_fortran_env->module~legendre module~integration integration iso_fortran_env->module~integration module~linalg linalg iso_fortran_env->module~linalg module~misc misc iso_fortran_env->module~misc lib_array lib_array lib_array->module~legendre lib_array->module~integration module~integration->module~legendre module~linalg->module~legendre module~misc->module~legendre Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used By module~~assembly~~UsedByGraph module~assembly assembly program~main main module~assembly->program~main Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Subroutines initialize_global_mats assemble set_BCs Subroutines public subroutine initialize_global_mats (num_nodes, GlobalA, GlobalB, GlobalX) This routine initalizes the global stiffness matrix, global rhs vector,\n  and global solution vector based on the number of nodes in the system Arguments Type Intent Optional Attributes Name integer, intent(in) :: num_nodes The number of nodes in the system real(kind=wp), intent(out), dimension(:,:), allocatable :: GlobalA Global mass matrix real(kind=wp), intent(out), dimension(:), allocatable :: GlobalB Global RHS Vector real(kind=wp), intent(out), dimension(:), allocatable :: GlobalX Global solution vector public subroutine assemble (order, xcoords, elem_conn, GlobalA, diff, vel) Assemble the global stiffness matrix based on element connectivity Arguments Type Intent Optional Attributes Name integer, intent(in), dimension(:) :: order Order of element(s) real(kind=wp), intent(in), dimension(:) :: xcoords Array of nodal coordinates integer, intent(in), dimension(:,:) :: elem_conn Element connectivity real(kind=wp), intent(out), dimension(:,:) :: GlobalA Global Stiffness matrix real(kind=wp), intent(in) :: diff Diffusivity coefficient [m/s&#94;2] real(kind=wp), intent(in) :: vel Velocity [m/s] public subroutine set_BCs (xcoords, GlobalB, GlobalA) Set boundary conditions in GlobalA and GlobalB using two Dirchlet\n   boundaries Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: xcoords Array of nodal coordinates real(kind=wp), intent(out), dimension(:) :: GlobalB Global RHS Vector real(kind=wp), intent(out), dimension(:,:) :: GlobalA Global Mass Matrix","tags":"","loc":"module/assembly.html","title":"assembly – learn_dg"},{"text":"Uses: iso_fortran_env lib_array module~~integration~~UsesGraph module~integration integration iso_fortran_env iso_fortran_env iso_fortran_env->module~integration lib_array lib_array lib_array->module~integration Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used By module~~integration~~UsedByGraph module~integration integration module~legendre legendre module~integration->module~legendre module~assembly assembly module~legendre->module~assembly program~doubleint doubleint module~legendre->program~doubleint module~pascal_smod pascal_smod module~legendre->module~pascal_smod program~main main module~assembly->program~main Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Interfaces fun2d_interf sub1d_interf Functions integrate2D Subroutines integrate gaussquad lgwt cgwt gaussquad_rosetta Interfaces interface private function fun2d_interf (x, y) result(z) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:,:) :: x real(kind=wp), intent(in), dimension(:,:) :: y Return Value real(kind=wp),\n  dimension(:,:), allocatable interface private subroutine sub1d_interf (xx, yy) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: xx real(kind=wp), intent(out), dimension(:) :: yy Functions public function integrate2D (fun) result(out) Arguments Type Intent Optional Attributes Name procedure( fun2d_interf ) :: fun Return Value real(kind=wp) Subroutines public subroutine integrate (sub, a, b, result) Arguments Type Intent Optional Attributes Name procedure( sub1d_interf ) :: sub real(kind=wp), intent(in) :: a real(kind=wp), intent(in) :: b real(kind=wp), intent(out) :: result private subroutine gaussquad (N, x, w) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N real(kind=wp), intent(out), dimension(N) :: x real(kind=wp), intent(out), dimension(N) :: w private subroutine lgwt (a, b, num_pts, x, w) This function is a fortran90 port of the matlab function, lgwt.m\n   The source code of lgwt.m was originally found at:\n     http://www.mathworks.com/matlabcentral/fileexchange/4540 Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a real(kind=wp), intent(in) :: b integer, intent(in) :: num_pts real(kind=wp), intent(out), dimension(:) :: x real(kind=wp), intent(out), dimension(:) :: w private subroutine cgwt (num_pts, x, w) Arguments Type Intent Optional Attributes Name integer, intent(in) :: num_pts real(kind=wp), intent(out), dimension(:) :: x real(kind=wp), intent(out), dimension(:) :: w private subroutine gaussquad_rosetta (n, r1, r2) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=wp), intent(out) :: r1 (n) real(kind=wp), intent(out) :: r2 (n)","tags":"","loc":"module/integration.html","title":"integration – learn_dg"},{"text":"Uses: iso_fortran_env lib_array module~~io~~UsesGraph module~io io iso_fortran_env iso_fortran_env iso_fortran_env->module~io lib_array lib_array lib_array->module~io Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used By module~~io~~UsedByGraph module~io io program~main main module~io->program~main Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Subroutines read_gmsh_file_1D write_out_solution Subroutines public subroutine read_gmsh_file_1D (num_nodes, order, nodes2vertex, elem_conn, xcoords, dg) Reads the input mesh file (gmsh .msh format) and returns the number of\n   nodes, the order of each element, element connectivity, and the\n   coordinates of the nodes (nx1 for 1D, nx2 for 2D, etc.) Arguments Type Intent Optional Attributes Name integer, intent(out) :: num_nodes Number of nodes in mesh integer, intent(out), dimension(:), allocatable :: order Array containing order of each element integer, intent(out), dimension(:), allocatable :: nodes2vertex Array containing node to vertex connectivity (only interesting w.r.t discontinuous galerkin) integer, intent(out), dimension(:,:), allocatable :: elem_conn Array containing node connectivity of each element real(kind=wp), intent(out), dimension(:), allocatable :: xcoords Array containing node coordinates logical, intent(in) :: dg Logical switch is continuous galerkin or discontinuous galerkin public subroutine write_out_solution (num_nodes, xcoords, GlobalX) Arguments Type Intent Optional Attributes Name integer, intent(in) :: num_nodes real(kind=wp), intent(in), dimension(:) :: xcoords real(kind=wp), intent(in), dimension(:) :: GlobalX","tags":"","loc":"module/io.html","title":"io – learn_dg"},{"text":"Uses: iso_fortran_env misc lib_array integration linalg module~~legendre~~UsesGraph module~legendre legendre lib_array lib_array lib_array->module~legendre module~integration integration lib_array->module~integration module~integration->module~legendre module~linalg linalg module~linalg->module~legendre iso_fortran_env iso_fortran_env iso_fortran_env->module~legendre iso_fortran_env->module~integration iso_fortran_env->module~linalg module~misc misc iso_fortran_env->module~misc module~misc->module~legendre Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Descendants: pascal_smod Used By module~~legendre~~UsedByGraph module~legendre legendre module~assembly assembly module~legendre->module~assembly program~doubleint doubleint module~legendre->program~doubleint module~pascal_smod pascal_smod module~legendre->module~pascal_smod program~main main module~assembly->program~main Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Interfaces pascal Functions integrate_basis_1d_Ie basis_1D getxy getArow getAlpha getJacobian assembleElementalMatrix Subroutines getIe vandermonde Interfaces public interface pascal public function pascal_1D_line(N, x) result(row) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N real(kind=wp), intent(in) :: x Return Value real(kind=wp),\n  dimension(N+1) public function pascal_2D_quad(N, x, y) result(row) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N real(kind=wp), intent(in) :: x real(kind=wp), intent(in) :: y Return Value real(kind=wp),\n  dimension(N+1) Functions private function integrate_basis_1d_Ie (N, ii, jj, dii, djj, xcoords) result(integral) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N integer, intent(in) :: ii integer, intent(in) :: jj integer, intent(in) :: dii integer, intent(in) :: djj real(kind=wp), intent(in), dimension(:) :: xcoords Return Value real(kind=wp) private function basis_1D (x, alpha, dx) result(y) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: x real(kind=wp), intent(in), dimension(:) :: alpha integer, intent(in) :: dx Return Value real(kind=wp),\n  dimension(:), allocatable public pure function getxy (N) result(xy) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N Return Value real(kind=wp),\n  dimension(N,2) private function getArow (N, xi, eta) result(row) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N real(kind=wp), intent(in) :: xi real(kind=wp), intent(in) :: eta Return Value real(kind=wp),\n  dimension(N) private function getAlpha (N) result(alpha) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N Return Value real(kind=wp),\n  dimension(N,N) private function getJacobian (N, xi, eta, xy, alpha) result(J) Calculates the Jacobian of a quadrilateral element Arguments Type Intent Optional Attributes Name integer, intent(in) :: N Number of points in element real(kind=wp), intent(in) :: xi real(kind=wp), intent(in) :: eta real(kind=wp), intent(in), dimension(N,2) :: xy real(kind=wp), intent(in), dimension(N,N) :: alpha Return Value real(kind=wp),\n  dimension(2,2) public function assembleElementalMatrix (N, d1, d2, xy) result(Ie) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N integer, intent(in) :: d1 integer, intent(in) :: d2 real(kind=wp), intent(in), dimension(N,2) :: xy Return Value real(kind=wp),\n  dimension(N,N) Subroutines public subroutine getIe (dii, djj, xcoords, Ie) Routine to calculate the elemental mass/stiffness matrix based on the\n   derivatives of the basis functions. Arguments Type Intent Optional Attributes Name integer, intent(in) :: dii Derivative of the first basis function integer, intent(in) :: djj Derivative of the second basis function real(kind=wp), intent(in), dimension(:) :: xcoords Coordinates of the 1D line element real(kind=wp), intent(out), dimension(:,:) :: Ie Output elemental matrix private subroutine vandermonde (n, Vinv) Arguments Type Intent Optional Attributes Name integer :: n real(kind=wp), dimension(n, n) :: Vinv","tags":"","loc":"module/legendre.html","title":"legendre – learn_dg"},{"text":"Uses: iso_fortran_env module~~linalg~~UsesGraph module~linalg linalg iso_fortran_env iso_fortran_env iso_fortran_env->module~linalg Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used By module~~linalg~~UsedByGraph module~linalg linalg module~legendre legendre module~linalg->module~legendre program~doubleint doubleint module~linalg->program~doubleint program~main main module~linalg->program~main module~legendre->program~doubleint module~assembly assembly module~legendre->module~assembly module~pascal_smod pascal_smod module~legendre->module~pascal_smod module~assembly->program~main Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Functions eye inv2 det2 Subroutines linsolve_quick linsolve Functions public pure function eye (N) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N Return Value real(kind=wp),\n  dimension(N,N) public pure function inv2 (J) result(invJ) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(2,2) :: J Return Value real(kind=wp),\n  dimension(2,2) public pure function det2 (A) result(det) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(2,2) :: A Return Value real(kind=wp) Subroutines public subroutine linsolve_quick (n, a, nrhs, b, x) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=wp), intent(in), dimension(n, n) :: a integer, intent(in) :: nrhs real(kind=wp), intent(in), dimension(n, nrhs) :: b real(kind=wp), intent(out), dimension(n, nrhs) :: x public subroutine linsolve (n, a, nrhs, b, x, LU, P, toggle) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=wp), intent(in), dimension(n, n) :: a integer, intent(in) :: nrhs real(kind=wp), intent(in), dimension(n, nrhs) :: b real(kind=wp), intent(out), dimension(n, nrhs) :: x real(kind=wp), intent(inout), dimension(n, n) :: LU integer, intent(inout), dimension(n) :: P logical, intent(in) :: toggle","tags":"","loc":"module/linalg.html","title":"linalg – learn_dg"},{"text":"Uses: iso_fortran_env module~~misc~~UsesGraph module~misc misc iso_fortran_env iso_fortran_env iso_fortran_env->module~misc Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used By module~~misc~~UsedByGraph module~misc misc module~legendre legendre module~misc->module~legendre program~doubleint doubleint module~misc->program~doubleint program~main main module~misc->program~main module~legendre->program~doubleint module~assembly assembly module~legendre->module~assembly module~pascal_smod pascal_smod module~legendre->module~pascal_smod module~assembly->program~main Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Subroutines r8mat_print r8mat_print_some Subroutines public subroutine r8mat_print (m, n, a, title) R8MAT_PRINT prints an R8MAT. Arguments Type Intent Optional Attributes Name integer(kind=4) :: m integer(kind=4) :: n real(kind=8) :: a (m,n) character(len=*) :: title private subroutine r8mat_print_some (m, n, a, ilo, jlo, ihi, jhi, title) R8MAT_PRINT_SOME prints some of an R8MAT. Arguments Type Intent Optional Attributes Name integer(kind=4) :: m integer(kind=4) :: n real(kind=8) :: a (m,n) integer(kind=4) :: ilo integer(kind=4) :: jlo integer(kind=4) :: ihi integer(kind=4) :: jhi character(len=*) :: title","tags":"","loc":"module/misc.html","title":"misc – learn_dg"},{"text":"Ancestors: legendre Uses: iso_fortran_env module~~pascal_smod~~UsesGraph module~pascal_smod pascal_smod iso_fortran_env iso_fortran_env iso_fortran_env->module~pascal_smod module~legendre legendre iso_fortran_env->module~legendre module~integration integration iso_fortran_env->module~integration module~linalg linalg iso_fortran_env->module~linalg module~misc misc iso_fortran_env->module~misc module~legendre->module~pascal_smod lib_array lib_array lib_array->module~legendre lib_array->module~integration module~integration->module~legendre module~linalg->module~legendre module~misc->module~legendre Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Functions pascal_2D_row Module Functions pascal_1D_line pascal_2D_quad Functions pure function pascal_2D_row (N, x, y) result(row) Generates a row of Pascal's triangle in 2D, where rows are 0-indexed Arguments Type Intent Optional Attributes Name integer, intent(in) :: N Row number of pascal's 2D triange (0-indexed) real(kind=wp), intent(in) :: x X-value used in triange real(kind=wp), intent(in) :: y Y-Value used in triange Return Value real(kind=wp),\n  dimension(N+1) Output row of triange Module Functions function pascal_1D_line (N, x) result(row) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N real(kind=wp), intent(in) :: x Return Value real(kind=wp),\n  dimension(N+1) function pascal_2D_quad (N, x, y) result(row) Generates an array of points related to a quadrilateral using Pascal's\n triangle in 2D, where rows are 0-indexed Arguments Type Intent Optional Attributes Name integer, intent(in) :: N Order of the qaudrilateral real(kind=wp), intent(in) :: x X-coordinate of node used in calculation real(kind=wp), intent(in) :: y Y-coordinate of node used in calculation Return Value real(kind=wp),\n  dimension((N+1)**2) Output row","tags":"","loc":"module/pascal_smod.html","title":"pascal_smod – learn_dg"},{"text":"Uses: iso_fortran_env linalg misc legendre program~~doubleint~~UsesGraph program~doubleint doubleint module~misc misc module~misc->program~doubleint module~legendre legendre module~misc->module~legendre module~legendre->program~doubleint iso_fortran_env iso_fortran_env iso_fortran_env->program~doubleint iso_fortran_env->module~misc iso_fortran_env->module~legendre module~linalg linalg iso_fortran_env->module~linalg module~integration integration iso_fortran_env->module~integration module~linalg->program~doubleint module~linalg->module~legendre lib_array lib_array lib_array->module~legendre lib_array->module~integration module~integration->module~legendre Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Calls program~~doubleint~~CallsGraph program~doubleint doubleint proc~r8mat_print r8mat_print program~doubleint->proc~r8mat_print proc~getxy getxy program~doubleint->proc~getxy proc~linsolve_quick linsolve_quick program~doubleint->proc~linsolve_quick proc~eye eye program~doubleint->proc~eye assembleelementalmatrix assembleelementalmatrix program~doubleint->assembleelementalmatrix proc~r8mat_print_some r8mat_print_some proc~r8mat_print->proc~r8mat_print_some proc~linsolve linsolve proc~linsolve_quick->proc~linsolve dgetrs dgetrs proc~linsolve->dgetrs dgetrf dgetrf proc~linsolve->dgetrf Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Variables ii N xy Ie GlobalB GlobalX GlobalA elem Source Code doubleint Variables Type Attributes Name Initial integer :: ii integer, parameter :: N = 16 real(kind=wp), dimension(N,2) :: xy real(kind=wp), dimension(N,N) :: Ie real(kind=wp), dimension(16) :: GlobalB real(kind=wp), dimension(16) :: GlobalX real(kind=wp), dimension(16,16) :: GlobalA integer, dimension(1, 16) :: elem Source Code program doubleint use iso_fortran_env , only : wp => real64 use linalg , only : linsolve_quick , eye use misc , only : r8mat_print use legendre , only : assembleElementalMatrix , getxy implicit none integer :: ii ! integer, parameter :: N = 4 ! integer, parameter :: N = 9 integer , parameter :: N = 16 real ( wp ), dimension ( N , 2 ) :: xy real ( wp ), dimension ( N , N ) :: Ie ! real(wp), dimension(10)    :: GlobalB, GlobalX ! real(wp), dimension(10,10)  :: GlobalA ! real(wp), dimension(15)    :: GlobalB, GlobalX ! real(wp), dimension(15,15)  :: GlobalA real ( wp ), dimension ( 16 ) :: GlobalB , GlobalX real ( wp ), dimension ( 16 , 16 ) :: GlobalA ! integer,  dimension(4,4)  :: elem ! integer,  dimension(2,9)  :: elem integer , dimension ( 1 , 16 ) :: elem ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!! ! !!!!!! Bi-linear quads !!!!!!! ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!! ! Element connection(s) for 3 bi-linear quadrilaterals ! elem(1,:) = [1, 2, 3, 4] ! elem(2,:) = [2, 5, 6, 3] ! elem(3,:) = [5, 7, 8, 6] ! elem(4,:) = [7, 9, 10, 8] ! Get base xi/eta coordinates for bi-linear quadrilateral ! xy(:,1) = [-1._wp, 1._wp, 1._wp, -1._wp] ! xy(:,2) = [-1._wp, -1._wp, 1._wp, 1._wp] ! Adjust for bi-linear quad ! xy(:,1) = [0._wp, 1._wp, 1.6_wp, 0._wp] ! xy(:,2) = [-1._wp, -2._wp, 5._wp, 3._wp] ! xy(:,1) = [0._wp, 0.03333_wp, 0.03333_wp, 0._wp] ! xy(:,2) = [0._wp, 0._wp, 0.03333_wp, 0.03333_wp] ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!! ! !!!!!! Bi-linear quads !!!!!!! ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!! ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! ! !!!!!! Bi-quadratic quads !!!!!!! ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! ! Element connection(s) for 2 bi-quadratic quadrilaterals ! elem(1,:) = [1, 2, 5, 6, 7, 8, 9, 10, 11] ! elem(2,:) = [2, 3, 4, 5, 12, 13, 14, 8, 15] ! Get base xi/eta coordinates for bi-quadratic quadrilateral ! xy(:,1) = [-1._wp, 1._wp, 1._wp, -1._wp, 0._wp, 1._wp, 0._wp, -1._wp, 0._wp] ! xy(:,2) = [-1._wp, -1._wp, 1._wp, 1._wp, -1._wp, 0._wp, 1._wp, 0._wp, 0._wp] ! Adjust for bi-quadratic quad ! xy(:,1) = [0._wp, 0.03333_wp, 0.03333_wp, 0._wp, 0.016667_wp, 0.03333_wp, 0.016667_wp, 0._wp, 0.016667_wp] ! xy(:,2) = [0._wp, 0._wp, 0.03333_wp, 0.03333_wp, 0._wp, 0.016667_wp, 0.03333_wp, 0.016667_wp, 0.016667_wp] ! xy(1,:) = [-1.25_wp, -0.8_wp] ! xy(6,:) = [0.75_wp, 0.1_wp] ! xy(9,:) = [-0.25_wp, 0.25_wp] ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! ! !!!!!! Bi-quadratic quads !!!!!!! ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!! ! !!!!!! Bi-cubic quads !!!!!!! ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!! ! Element connection(s) for 2 bi-cubic quadrilaterals elem ( 1 ,:) = [( ii , ii = 1 , 16 )] ! Get base xi/eta coordinates for bi-cubic quadrilateral xy = getxy ( N ) ! Adjust for bi-cubic quad ! xy(:,1) = [0._wp, 0.03333_wp, 0.03333_wp, 0._wp, 0.016667_wp, 0.03333_wp, 0.016667_wp, 0._wp, 0.016667_wp] ! xy(:,2) = [0._wp, 0._wp, 0.03333_wp, 0.03333_wp, 0._wp, 0.016667_wp, 0.03333_wp, 0.016667_wp, 0.016667_wp] ! xy(1,:) = [-1.25_wp, -0.8_wp] ! xy(6,:) = [0.75_wp, 0.1_wp] ! xy(9,:) = [-0.25_wp, 0.25_wp] ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!! ! !!!!!! Bi-cubic quads !!!!!!! ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!! GlobalA = 0._wp do ii = 1 , size ( elem , 1 ) Ie = - assembleElementalMatrix ( N , 1 , 1 , xy ) - assembleElementalMatrix ( N , 2 , 2 , xy ) GlobalA ( elem ( ii ,:), elem ( ii ,:)) = GlobalA ( elem ( ii ,:), elem ( ii ,:)) + Ie enddo ! Zero-out the row corresponding with BCs and set A(ii,ii) to 1.0 forall ii ! GlobalA( [1, 4, 9, 10], : ) = 0._wp ! GlobalA( [1, 4, 9, 10], [1, 4, 9, 10] ) = eye(4) ! GlobalA( [1, 6, 10, 3, 4, 13], : ) = 0._wp ! GlobalA( [1, 6, 10, 3, 4, 13], [1, 6, 10, 3, 4, 13] ) = eye(6) GlobalA ( [ 1 , 2 , 7 , 8 , 3 , 4 , 11 , 12 ], : ) = 0._wp GlobalA ( [ 1 , 2 , 7 , 8 , 3 , 4 , 11 , 12 ], [ 1 , 2 , 7 , 8 , 3 , 4 , 11 , 12 ] ) = eye ( 8 ) call r8mat_print ( size ( GlobalA , 1 ), size ( GlobalA , 2 ), GlobalA , \"Global Stiffness Matrix:\" ) ! Set BCs (zero everywhere, 1 on left boundary) GlobalB = 0._wp ! GlobalB( [1, 4] ) = 1._wp ! GlobalB( [1, 6, 10] ) = 1._wp GlobalB ( [ 1 , 4 , 11 , 12 ] ) = 1._wp ! Solve linear system call linsolve_quick ( size ( GlobalA , 1 ), GlobalA , size ( GlobalB , 1 ), GlobalB , GlobalX ) call r8mat_print ( size ( GlobalX , 1 ), 1 , GlobalX , \"Solution Vector:\" ) end program doubleint","tags":"","loc":"program/doubleint.html","title":"doubleint – learn_dg"},{"text":"Uses: iso_fortran_env linalg misc io assembly program~~main~~UsesGraph program~main main module~assembly assembly module~assembly->program~main module~misc misc module~misc->program~main module~legendre legendre module~misc->module~legendre module~io io module~io->program~main iso_fortran_env iso_fortran_env iso_fortran_env->program~main iso_fortran_env->module~assembly iso_fortran_env->module~misc iso_fortran_env->module~io module~linalg linalg iso_fortran_env->module~linalg iso_fortran_env->module~legendre module~integration integration iso_fortran_env->module~integration module~linalg->program~main module~linalg->module~legendre module~legendre->module~assembly lib_array lib_array lib_array->module~io lib_array->module~legendre lib_array->module~integration module~integration->module~legendre Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Calls program~~main~~CallsGraph program~main main set_bcs set_bcs program~main->set_bcs proc~write_out_solution write_out_solution program~main->proc~write_out_solution proc~assemble assemble program~main->proc~assemble proc~linsolve_quick linsolve_quick program~main->proc~linsolve_quick proc~initialize_global_mats initialize_global_mats program~main->proc~initialize_global_mats read_gmsh_file_1d read_gmsh_file_1d program~main->read_gmsh_file_1d getie getie proc~assemble->getie proc~linsolve linsolve proc~linsolve_quick->proc~linsolve dgetrs dgetrs proc~linsolve->dgetrs dgetrf dgetrf proc~linsolve->dgetrf Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Variables diff vel num_nodes order nodes2vertex elem_conn xcoords GlobalB GlobalX GlobalA dg Source Code main Variables Type Attributes Name Initial real(kind=wp), parameter :: diff = 0.1_wp real(kind=wp), parameter :: vel = -5._wp integer :: num_nodes integer, dimension(:), allocatable :: order integer, dimension(:), allocatable :: nodes2vertex integer, dimension(:,:), allocatable :: elem_conn real(kind=wp), dimension(:), allocatable :: xcoords real(kind=wp), dimension(:), allocatable :: GlobalB real(kind=wp), dimension(:), allocatable :: GlobalX real(kind=wp), dimension(:,:), allocatable :: GlobalA logical :: dg Source Code program main use iso_fortran_env , only : wp => real64 use linalg , only : linsolve_quick use misc , only : r8mat_print use io , only : read_gmsh_file_1D , & write_out_solution use assembly , only : initialize_global_mats , assemble , set_BCs implicit none real ( wp ), parameter :: diff = 0.1_wp , vel = - 5._wp integer :: num_nodes integer , dimension (:), allocatable :: order , nodes2vertex integer , dimension (:,:), allocatable :: elem_conn real ( wp ), dimension (:), allocatable :: xcoords , GlobalB , GlobalX real ( wp ), dimension (:,:), allocatable :: GlobalA logical :: dg ! dg = .true. dg = . false . call read_gmsh_file_1D ( num_nodes , order , nodes2vertex , elem_conn , xcoords , dg ) ! stop call initialize_global_mats ( num_nodes , GlobalA , GlobalB , GlobalX ) call assemble ( order , xcoords , elem_conn , GlobalA , diff , vel ) call set_BCs ( xcoords , GlobalB , GlobalA ) ! call r8mat_print(num_nodes, num_nodes, GlobalA, 'Global Stiffness matrix:') ! stop call linsolve_quick ( num_nodes , GlobalA , 1 , GlobalB , GlobalX ) ! call r8mat_print(num_nodes, 1, GlobalB, 'Global RHS:') ! call r8mat_print(num_nodes, 1, GlobalX, 'Global Solution Vector:') call write_out_solution ( num_nodes , xcoords , GlobalX ) end program main","tags":"","loc":"program/main.html","title":"main – learn_dg"},{"text":"Introduction This is an introduction","tags":"","loc":"page//index.html","title":"User Guide – learn_dg"},{"text":"Finite Element Theory Finite Element Theory Introduction Basis functions Partial Differential Equations Introduction This is the intro Basis functions Basis functions in 1D: Linear line (2 pts) Quadratic line (3 pts) Cubic line (4 pts) Basis functions in 2D: Bi-linear quadrilateral (4 pts) Bi-quadratic quadrilateral (9 pts) Bi-cubic quadrilateral (16 pts) Partial Differential Equations Example adv-diff equation  \\frac{\\partial u}{\\partial t} = \\Delta \\left( u \\right) - \\nabla \\cdot \\left( \\vec{c} u \\right)  Example","tags":"","loc":"page/finite-element-theory/index.html","title":"Finite Element Theory – learn_dg"},{"text":"Examples Examples Example Advection-Diffusion Problem Example Advection-Diffusion Problem Here goes the example","tags":"","loc":"page/finite-element-theory/01_example.html","title":"Example – learn_dg"}]}