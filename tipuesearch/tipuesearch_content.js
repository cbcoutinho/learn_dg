var tipuesearch = {"pages":[{"tags":"home","text":"learn_dg Note Watch out, none of this code works More information can be found in the user guide . Documentation Documentation about the project can be found here: Learn_dg Documentation Dependencies This project has been refactored to be built on Linux using CMake. It's still possible to create a windows executable, but that is all done by cross-compilers on the Linux side. Further, the project also requires BLAS/Lapack. To build the project, execute make cmake at the project root directory (cmake is a make recipe right now). If that is strange for you, make a build subdirectory in this directory and execute the following: cmake .. To create a windows executable/library of the project, either execute make cmake_win at the project root, or create a build subdicretory and execute the following: cmake -DCMAKE_TOOLCHAIN_FILE:STRING=../cmake/Toolchain-x64-mingw32.cmake .. Cross compiling the sources for Windows requires a few exotic packages. On openSUSE Leap 42.2, I had to first add the 'windows_mingw_win64' repo and install the following packages. These should cover the current state of the project. mingw64-cross-gcc\nmingw64-cross-g++\nmingw64-cross-gfortran\nmingw64-lapack-devel\nmingw64-blas-devel Developer Info Chris Coutinho","title":" learn_dg ","loc":"index.html"},{"tags":"","text":"Programs driver1D Source Code driver1D.f90 Source Code ! Learn_dg - A quick and dirty project to deploy a working DG solver ! Copyright (c) 2017, Chris Coutinho ! All rights reserved. ! ! Licensed under the BSD-2 clause license. See LICENSE for details. program driver1D use , intrinsic :: iso_fortran_env , only : wp => real64 use :: mod_linalg , only : linsolve_quick use :: mod_misc , only : r8mat_print use :: mod_io , only : read_gmsh_file_1D , write_out_solution use :: mod_assembly , only : initialize_global_mats , assemble , set_BCs implicit none real ( wp ), parameter :: diff = 0.1_wp , vel = - 5._wp integer :: num_nodes integer , dimension (:), allocatable :: nodes2vertex integer , dimension (:,:), allocatable :: cells real ( wp ), dimension (:), allocatable :: points , GlobalB , GlobalX real ( wp ), dimension (:,:), allocatable :: GlobalA logical :: dg ! dg = .true. dg = . false . call read_gmsh_file_1D ( num_nodes , nodes2vertex , cells , points , dg ) ! stop call initialize_global_mats ( num_nodes , GlobalA , GlobalB , GlobalX ) call assemble ( points , cells , diff , vel , GlobalA ) call set_BCs ( points , GlobalB , GlobalA ) ! call r8mat_print(num_nodes, num_nodes, GlobalA, 'Global Stiffness matrix:') ! stop call linsolve_quick ( num_nodes , GlobalA , 1 , GlobalB , GlobalX ) ! call r8mat_print(num_nodes, 1, GlobalB, 'Global RHS:') ! call r8mat_print(num_nodes, 1, GlobalX, 'Global Solution Vector:') call write_out_solution ( num_nodes , points , GlobalX ) end program driver1D","title":"driver1D.f90 – learn_dg","loc":"sourcefile/driver1d.f90.html"},{"tags":"","text":"Programs driver2D Source Code driver2D.f90 Source Code ! Learn_dg - A quick and dirty project to deploy a working DG solver ! Copyright (c) 2017, Chris Coutinho ! All rights reserved. ! ! Licensed under the BSD-2 clause license. See LICENSE for details. program driver2D use , intrinsic :: iso_fortran_env , only : wp => real64 use :: mod_linalg , only : linsolve_quick , eye use :: mod_misc , only : r8mat_print use :: mod_legendre , only : getXY use :: mod_assembly , only : assembleElementalMatrix , assemble implicit none integer :: ii ! integer, parameter :: N = 4 ! integer, parameter :: N = 9 integer , parameter :: N = 16 real ( wp ), dimension ( N , 2 ) :: xy real ( wp ), dimension (:,:), allocatable :: points real ( wp ), dimension ( N , N ) :: Ie real ( wp ), dimension ( N ) :: GlobalB , GlobalX real ( wp ), dimension ( N , N ) :: GlobalA ! real(wp), dimension(9)    :: GlobalB, GlobalX ! real(wp), dimension(9,9)  :: GlobalA ! real(wp), dimension(15)    :: GlobalB, GlobalX ! real(wp), dimension(15,15)  :: GlobalA ! real(wp), dimension(16)    :: GlobalB, GlobalX ! real(wp), dimension(16,16)  :: GlobalA integer , dimension ( 1 , N ) :: elem ! integer,  dimension(4,4)  :: elem ! integer,  dimension(2,9)  :: elem ! integer, dimension(1, 16) :: elem ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!! ! !!!!!! Bi-linear quads !!!!!!! ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!! ! Element connection(s) for 4 bi-linear quadrilaterals ! elem(1,:) = [1, 2, 3, 4] ! elem(2,:) = [2, 5, 6, 3] ! elem(3,:) = [5, 7, 8, 6] ! elem(4,:) = [7, 9, 10, 8] ! Get base xi/eta coordinates for bi-linear quadrilateral ! xy = getXY(N) ! Adjust for bi-linear quad ! xy(:,1) = [0._wp, 1._wp, 1.6_wp, 0._wp] ! xy(:,2) = [-1._wp, -2._wp, 5._wp, 3._wp] ! xy(:,1) = [0._wp, 0.03333_wp, 0.03333_wp, 0._wp] ! xy(:,2) = [0._wp, 0._wp, 0.03333_wp, 0.03333_wp] ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!! ! !!!!!! Bi-linear quads !!!!!!! ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!! ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! ! !!!!!! Bi-quadratic quads !!!!!!! ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! ! Element connection(s) for 2 bi-quadratic quadrilaterals ! elem(1,:) = [1, 2, 5, 6, 7, 8, 9, 10, 11] ! elem(2,:) = [2, 3, 4, 5, 12, 13, 14, 8, 15] ! Get base xi/eta coordinates for bi-quadratic quadrilateral ! xy = getXY(N) ! Adjust for bi-quadratic quad ! xy(:,1) = [0._wp, 0.03333_wp, 0.03333_wp, 0._wp, 0.016667_wp, 0.03333_wp, 0.016667_wp, 0._wp, 0.016667_wp] ! xy(:,2) = [0._wp, 0._wp, 0.03333_wp, 0.03333_wp, 0._wp, 0.016667_wp, 0.03333_wp, 0.016667_wp, 0.016667_wp] ! xy(1,:) = [-1.25_wp, -0.8_wp] ! xy(6,:) = [0.75_wp, 0.1_wp] ! xy(9,:) = [-0.25_wp, 0.25_wp] ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! ! !!!!!! Bi-quadratic quads !!!!!!! ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!! ! !!!!!! Bi-cubic quads !!!!!!! ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!! ! Element connection(s) for 2 bi-cubic quadrilaterals ! elem(1,:) = [(ii, ii=1,16)] ! Get base xi/eta coordinates for bi-cubic quadrilateral ! xy = getXY(N) ! Adjust for bi-cubic quad ! xy(:,1) = [0._wp, 0.03333_wp, 0.03333_wp, 0._wp, 0.016667_wp, 0.03333_wp, 0.016667_wp, 0._wp, 0.016667_wp] ! xy(:,2) = [0._wp, 0._wp, 0.03333_wp, 0.03333_wp, 0._wp, 0.016667_wp, 0.03333_wp, 0.016667_wp, 0.016667_wp] ! xy(1,:) = [-1.25_wp, -0.8_wp] ! xy(6,:) = [0.75_wp, 0.1_wp] ! xy(9,:) = [-0.25_wp, 0.25_wp] ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!! ! !!!!!! Bi-cubic quads !!!!!!! ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!! ! GlobalA = 0._wp ! do ii = 1, size(elem, 1) !   Ie = - assembleElementalMatrix(N, 1, 1, xy) - assembleElementalMatrix(N, 2, 2, xy) !   GlobalA(elem(ii,:), elem(ii,:)) = GlobalA(elem(ii,:), elem(ii,:)) + Ie ! enddo ! elem(1,:) = [1, 5, 9, 8] ! elem(2,:) = [5, 2, 6, 9] ! elem(3,:) = [9, 6, 3, 7] ! elem(4,:) = [8, 9, 7, 4] elem ( 1 ,:) = [( ii , ii = 1 , N )] ! call r8mat_print(size(elem,1), size(elem,2), dble(elem), \"cells\") points = getXY ( N ) ! call r8mat_print(size(points,1), size(points,2), points, 'points') call assemble ( points , elem , 1._wp , [ 0._wp , 0._wp ], GlobalA ) select case ( N ) case ( 9 ) GlobalA ( [ 1 , 2 , 3 , 4 , 6 , 8 ], : ) = 0._wp GlobalA ( [ 1 , 2 , 3 , 4 , 6 , 8 ], [ 1 , 2 , 3 , 4 , 6 , 8 ] ) = eye ( 6 ) GlobalB = 0._wp GlobalB ( [ 1 , 4 , 8 ] ) = 1._wp case ( 16 ) GlobalA ( [ 1 , 2 , 3 , 4 , 7 , 8 , 11 , 12 ], : ) = 0._wp GlobalA ( [ 1 , 2 , 3 , 4 , 7 , 8 , 11 , 12 ], [ 1 , 2 , 3 , 4 , 7 , 8 , 11 , 12 ] ) = eye ( 8 ) GlobalB = 0._wp GlobalB ( [ 1 , 4 , 11 , 12 ] ) = 1._wp end select ! Zero-out the row corresponding with BCs and set A(ii,ii) to 1.0 forall ii ! GlobalA( [1, 4, 9, 10], : ) = 0._wp ! GlobalA( [1, 4, 9, 10], [1, 4, 9, 10] ) = eye(4) ! GlobalA( [1, 6, 10, 3, 4, 13], : ) = 0._wp ! GlobalA( [1, 6, 10, 3, 4, 13], [1, 6, 10, 3, 4, 13] ) = eye(6) ! GlobalA( [1, 2, 7, 8, 3, 4, 11, 12], : ) = 0._wp ! GlobalA( [1, 2, 7, 8, 3, 4, 11, 12], [1, 2, 7, 8, 3, 4, 11, 12] ) = eye(8) ! call r8mat_print(size(GlobalA,1), size(GlobalA,2), GlobalA, \"Global Stiffness Matrix:\") ! Set BCs (zero everywhere, 1 on left boundary) ! GlobalB = 0._wp ! GlobalB( [1, 4] ) = 1._wp ! GlobalB( [1, 4, 8] ) = 1._wp ! GlobalB ( [1, 4, 11, 12] ) = 1._wp ! Solve linear system call linsolve_quick ( & size ( GlobalA , 1 ), GlobalA , & size ( GlobalB , 1 ), GlobalB , & GlobalX ) call r8mat_print ( & size ( GlobalX , 1 ), 1 , GlobalX , \"Solution Vector:\" ) end program driver2D","title":"driver2D.f90 – learn_dg","loc":"sourcefile/driver2d.f90.html"},{"tags":"","text":"Modules mod_assembly Source Code mod_assembly.f90 Source Code ! Learn_dg - A quick and dirty project to deploy a working DG solver ! Copyright (c) 2017, Chris Coutinho ! All rights reserved. ! ! Licensed under the BSD-2 clause license. See LICENSE for details. module mod_assembly use , intrinsic :: iso_fortran_env , only : wp => real64 use :: mod_legendre , only : getXY , getArow , getJacobian implicit none private public :: assembleElementalMatrix interface assembleElementalMatrix module function assembleElementalMatrix1D ( N , d1 , d2 , xy ) result ( Ie ) integer , intent ( in ) :: N , d1 , d2 real ( wp ), dimension ( N ), intent ( in ) :: xy real ( wp ), dimension ( N , N ) :: Ie end function assembleElementalMatrix1D module function assembleElementalMatrix2D ( N , d1 , d2 , xy ) result ( Ie ) integer , intent ( in ) :: N , d1 , d2 real ( wp ), dimension ( N , 2 ), intent ( in ) :: xy real ( wp ), dimension ( N , N ) :: Ie end function assembleElementalMatrix2D end interface assembleElementalMatrix public :: initialize_global_mats interface initialize_global_mats module subroutine initialize_global_mats ( & num_nodes , & GlobalA , & GlobalB , & GlobalX ) integer , intent ( in ) :: num_nodes real ( wp ), intent ( out ), dimension (:), allocatable :: GlobalB real ( wp ), intent ( out ), dimension (:), allocatable :: GlobalX real ( wp ), intent ( out ), dimension (:,:), allocatable :: GlobalA end subroutine initialize_global_mats end interface initialize_global_mats public :: assemble interface assemble module subroutine assemble1D ( points , cells , diff , vel , GlobalA ) integer , intent ( in ), dimension (:,:) :: cells real ( wp ), intent ( in ) :: diff real ( wp ), intent ( in ) :: vel real ( wp ), intent ( in ), dimension (:) :: points real ( wp ), intent ( out ), dimension (:,:) :: GlobalA end subroutine assemble1D module subroutine assemble2D ( points , cells , diff , vel , GlobalA ) integer , intent ( in ), dimension (:,:) :: cells real ( wp ), intent ( in ) :: diff real ( wp ), intent ( in ), dimension ( 2 ) :: vel real ( wp ), intent ( in ), dimension (:,:) :: points real ( wp ), intent ( out ), dimension (:,:) :: GlobalA end subroutine assemble2D end interface assemble public :: set_BCs interface set_BCs module subroutine set_BCs ( points , GlobalB , GlobalA ) real ( wp ), intent ( in ), dimension (:) :: points !! Array of nodal coordinates real ( wp ), intent ( out ), dimension (:) :: GlobalB !! Global RHS Vector real ( wp ), intent ( out ), dimension (:,:) :: GlobalA end subroutine set_BCs end interface set_BCs contains end module mod_assembly","title":"mod_assembly.f90 – learn_dg","loc":"sourcefile/mod_assembly.f90.html"},{"tags":"","text":"Modules mod_assembly_c Source Code mod_assembly_c.f90 Source Code ! Learn_dg - A quick and dirty project to deploy a working DG solver ! Copyright (c) 2017, Chris Coutinho ! All rights reserved. ! ! Licensed under the BSD-2 clause license. See LICENSE for details. module mod_assembly_c use , intrinsic :: iso_fortran_env , only : wp => real64 use , intrinsic :: iso_c_binding , only : c_int , c_double use :: mod_assembly , only : assembleElementalMatrix , assemble use :: mod_misc , only : r8mat_print implicit none private contains subroutine assembleElementalMatrix1D_c ( N , d1 , d2 , xy , Ie ) & bind ( c , name = 'assembleElementalMatrix1D_c' ) integer ( c_int ), intent ( in ), value :: N , d1 , d2 real ( c_double ), intent ( in ) :: xy ( N ) real ( c_double ), intent ( inout ) :: Ie ( N , N ) integer :: ii Ie = assembleElementalMatrix ( N , d1 , d2 , xy ) return end subroutine assembleElementalMatrix1D_c subroutine assembleElementalMatrix2D_c ( & N , d1 , d2 , xy , Ie ) & bind ( c , name = 'assembleElementalMatrix2D_c' ) integer ( c_int ), intent ( in ), value :: N , d1 , d2 real ( c_double ), intent ( in ) :: xy ( N , 2 ) real ( c_double ), intent ( inout ) :: Ie ( N , N ) integer :: ii Ie = assembleElementalMatrix ( N , d1 , d2 , xy ) return end subroutine assembleElementalMatrix2D_c subroutine assemble1D_c ( & num_cells , num_pts_per_cell , num_pts , points , cells , & diff , vel , GlobalA ) & bind ( c , name = 'assemble1D_c' ) integer ( c_int ), intent ( in ), value :: num_cells , num_pts_per_cell , num_pts integer ( c_int ), intent ( in ) :: cells ( num_cells , num_pts_per_cell ) real ( c_double ), intent ( in ), value :: diff , vel real ( c_double ), intent ( in ) :: points ( num_pts ) real ( c_double ), intent ( inout ) :: GlobalA ( num_pts , num_pts ) call assemble ( points , cells , diff , vel , GlobalA ) return end subroutine assemble1D_c subroutine assemble2D_c ( num_cells , num_pts_per_cell , num_pts , & & points , cells , diff , vel , GlobalA ) bind ( c , name = 'assemble2D_c' ) integer ( c_int ), intent ( in ), value :: num_cells , num_pts_per_cell , num_pts integer ( c_int ), intent ( in ) :: cells ( num_cells , num_pts_per_cell ) real ( c_double ), intent ( in ), value :: diff real ( c_double ), intent ( in ) :: vel ( 2 ), points ( num_pts , 2 ) real ( c_double ), intent ( inout ) :: GlobalA ( num_pts , num_pts ) call assemble ( points , cells , diff , vel , GlobalA ) return end subroutine assemble2D_c end module mod_assembly_c","title":"mod_assembly_c.f90 – learn_dg","loc":"sourcefile/mod_assembly_c.f90.html"},{"tags":"","text":"Submodules smod_assemble_1D Source Code smod_assemble_1D.f90 Source Code ! Learn_dg - A quick and dirty project to deploy a working DG solver ! Copyright (c) 2017, Chris Coutinho ! All rights reserved. ! ! Licensed under the BSD-2 clause license. See LICENSE for details. submodule ( mod_assembly ) smod_assemble_1D use , intrinsic :: iso_fortran_env , only : wp => real64 use :: mod_legendre , only : basis_1D , getAlpha => getAlpha1D use :: mod_integration , only : integrate implicit none contains module function assembleElementalMatrix1D ( N , d1 , d2 , xy ) result ( Ie ) !*  Routine to calculate the elemental mass/stiffness matrix !   based on the derivatives of the basis functions. ! !   Currently only zero-th and first order derivatives are !   supported. Second order derivatives need to be reduced to !   first order derivatives in the problem formulation using !   Green's Theorem (i.e. derivation by parts) integer , intent ( in ) :: N !! Number of nodes in basis function integer , intent ( in ) :: d1 !! Derivative of the first basis function integer , intent ( in ) :: d2 !! Derivative of the second basis function real ( wp ), intent ( in ), dimension ( N ) :: xy !! Coordinates of the 1D line element real ( wp ), dimension ( N , N ) :: Ie !! Output elemental matrix integer :: ii , jj , order Ie = 0._wp order = N - 1 do ii = 1 , N Ie ( ii , :) = [( integrate_basis_1d_Ie ( order , ii , jj , d1 , d2 , xy ), jj = 1 , order + 1 )] enddo return end function assembleElementalMatrix1D function integrate_basis_1d_Ie ( N , ii , jj , dii , djj , xy ) result ( integral ) integer , intent ( in ) :: N , ii , jj , dii , djj real ( wp ), intent ( in ), dimension (:) :: xy real ( wp ) :: integral integer :: kk integer :: order , basis_num1 , basis_num2 real ( wp ), dimension ( N + 1 , N + 1 ) :: Vinv order = N basis_num1 = ii basis_num2 = jj Vinv = getAlpha ( order + 1 ) ! Check to make sure xy is an array of size (N+1) if ( size ( xy ) /= order + 1 ) then write ( * , * ) 'The shape of `xy` is outside the acceptable range for a' write ( * , * ) '1D basis function.' write ( * , * ) 'Shape(xy) should be [' , 2 , order + 1 , '], not ' , shape ( xy ) endif ! call integrate(local_wrapper, [-1.0_wp, 1.0_wp], integral) integral = integrate ( local_wrapper , [ - 1._wp , 1._wp ]) return contains pure function local_wrapper ( s ) result ( y ) real ( wp ), intent ( in ) :: s (:) real ( wp ), allocatable :: y (:) real ( wp ), allocatable :: J (:) allocate ( J , mold = s ) allocate ( y , mold = s ) call XorJ ( s , 1 , J ) y = 1.0_wp ! Here we have to be careful because J is not always needed in the ! first two function calls. Instead of using if statements, we can ! use an exponent so that when dx_ == 0, J is 1 y = y * basis_1D ( s , Vinv (:, basis_num1 ), dii ) / ( J ** dble ( dii )) y = y * basis_1D ( s , Vinv (:, basis_num2 ), djj ) / ( J ** dble ( djj )) y = y * J deallocate ( J ) return end function local_wrapper pure subroutine XorJ ( s , dx , out ) integer , intent ( in ) :: dx real ( wp ), intent ( in ), dimension (:) :: s real ( wp ), intent ( out ), dimension (:) :: out integer :: ii out = 0.0_wp do ii = 1 , size ( xy ) out = out + basis_1D ( s , Vinv (:, ii ), dx ) * xy ( ii ) enddo return end subroutine XorJ end function integrate_basis_1d_Ie ! COPIED FROM mod_assembly module subroutine initialize_global_mats ( num_nodes , & GlobalA , & GlobalB , & GlobalX ) !*  This routine initalizes the global stiffness matrix, global !   rhs vector, and global solution vector based on the number of !   nodes in the system ! ! * This is a Another                               bullet point ! ! 1. This might be a number 2. Also a number? ! ! Some  \\LaTeX :  \\frac{\\partial u}{\\partial t} = 0  integer , intent ( in ) :: num_nodes !! The number of nodes in the system real ( wp ), intent ( out ), dimension (:), allocatable :: GlobalB !! Global RHS Vector real ( wp ), intent ( out ), dimension (:), allocatable :: GlobalX !! Global solution vector real ( wp ), intent ( out ), dimension (:,:), allocatable :: GlobalA !! Global mass matrix allocate ( GlobalA ( num_nodes , num_nodes )) allocate ( GlobalB ( num_nodes )) allocate ( GlobalX ( num_nodes )) ! Intial Conditions GlobalA = 0._wp GlobalX = 0._wp GlobalB = 0._wp return end subroutine initialize_global_mats subroutine assemble1D ( points , cells , diff , vel , GlobalA ) !* Assemble the global stiffness matrix based on element connectivity integer , intent ( in ), dimension (:,:) :: cells !! Element connectivity real ( wp ), intent ( in ) :: diff !! Diffusivity coefficient [m/s&#94;2] real ( wp ), intent ( in ) :: vel !! Velocity [m/s] real ( wp ), intent ( in ), dimension (:) :: points !! Array of nodal coordinates real ( wp ), intent ( out ), dimension (:,:) :: GlobalA !! Global Stiffness matrix integer :: ii , num_cells , num_pts real ( wp ), parameter :: eps = epsilon ( 1 e0 ) real ( wp ), allocatable :: xy (:), Ie (:,:) GlobalA = 0._wp num_cells = size ( cells , 1 ) ! Add elemental stiffness matrices to Global Stiffness Matrix !$OMP PARALLEL DEFAULT(SHARED) PRIVATE(ii, xy, Ie) REDUCTION(+:GlobalA) !$OMP DO do ii = 1 , num_cells num_pts = size ( cells ( ii ,:)) ! Reallocate elemental stiffness matrix allocate ( xy ( num_pts ), Ie ( num_pts , num_pts )) xy = points ( cells ( ii ,:)) Ie = assembleElementalMatrix1D ( num_pts , 1 , 1 , xy ) ! call r8mat_print(num_pts, num_pts, Ie, 'Elemental Stiffness Matrix:') GlobalA ( cells ( ii ,:), cells ( ii ,:)) = & GlobalA ( cells ( ii ,:), cells ( ii ,:)) - diff * Ie if ( abs ( vel ) . gt . eps ) then Ie = assembleElementalMatrix1D ( num_pts , 0 , 1 , xy ) ! call r8mat_print(num_pts, num_pts, Ie, 'Elemental Stiffness Matrix:') GlobalA ( cells ( ii ,:), cells ( ii ,:)) = & GlobalA ( cells ( ii ,:), cells ( ii ,:)) - vel * Ie endif ! Deallocate elemental stiffness matrix after every loop deallocate ( Ie , xy ) ! stop enddo !$OMP END DO !$OMP END PARALLEL ! call r8mat_print(num_nodes, num_nodes, GlobalA, 'Global Stiffness Matrix:') ! stop return end subroutine assemble1D subroutine set_BCs ( points , GlobalB , GlobalA ) !*  Set boundary conditions in GlobalA and GlobalB using two !   Dirchlet boundaries real ( wp ), intent ( in ), dimension (:) :: points !! Array of nodal coordinates real ( wp ), intent ( out ), dimension (:) :: GlobalB !! Global RHS Vector real ( wp ), intent ( out ), dimension (:,:) :: GlobalA !! Global Mass Matrix integer , dimension ( 1 ) :: iloc !! Index variable to locate node numbers based on points ! Left Boundary Dirchlet BC iloc = minloc ( points ) GlobalA ( iloc ,:) = 0._wp GlobalA ( iloc , iloc ) = 1._wp GlobalB ( iloc ) = 0._wp ! Right Boundary Dirchlet BC iloc = maxloc ( points ) GlobalA ( iloc ,:) = 0._wp GlobalA ( iloc , iloc ) = 1._wp GlobalB ( iloc ) = 1._wp ! call r8mat_print(num_nodes, 1, GlobalB, 'Global RHS:') ! stop return end subroutine set_BCs end submodule","title":"smod_assemble_1D.f90 – learn_dg","loc":"sourcefile/smod_assemble_1d.f90.html"},{"tags":"","text":"Submodules smod_assemble_2D Source Code smod_assemble_2D.f90 Source Code ! Learn_dg - A quick and dirty project to deploy a working DG solver ! Copyright (c) 2017, Chris Coutinho ! All rights reserved. ! ! Licensed under the BSD-2 clause license. See LICENSE for details. submodule ( mod_assembly ) smod_assemble_2D use , intrinsic :: iso_fortran_env , only : wp => real64 use :: mod_linalg , only : inv2 , det2 use :: mod_legendre , only : getAlpha => getAlpha2D use :: mod_integration , only : integrate use :: lib_array , only : linspace implicit none contains module function assembleElementalMatrix2D ( N , d1 , d2 , xy ) result ( Ie ) ! Dummy variables integer , intent ( in ) :: N , d1 , d2 real ( wp ), dimension ( N , 2 ), intent ( in ) :: xy real ( wp ), dimension ( N , N ) :: Ie ! Local variables integer :: node1 , node2 real ( wp ), dimension ( N , N ), target :: alpha ! Get the coefficients of the basis functions (alpha) ! Supported 2D basis functions: !   Bi-linear quadrilaterals (N=4) !   Bi-quadratic quadrilaterals (N=9) !   Bi-cubic quadrilaterals (N=16) !   Bi-quartic quadrilaterals (N=25) alpha = getAlpha ( N ) Ie = 0._wp outer : do node1 = 1 , N inner : do node2 = 1 , N ! fun is now implicitly defined using the following: node1, node2, d1, and d2 Ie ( node1 , node2 ) = Ie ( node1 , node2 ) + integrate ( fun , [ - 1._wp , 1._wp ], [ - 1._wp , 1._wp ]) enddo inner enddo outer return contains function fun ( xi , eta ) result ( out ) ! Dummy variables real ( wp ), dimension (:,:), intent ( in ) :: xi , eta real ( wp ), dimension (:,:), allocatable :: out ! Local variables integer :: ii , jj , num_pts real ( wp ), parameter :: eps = epsilon ( 0 e0 ) real ( wp ) :: fun1 , fun2 real ( wp ), dimension ( 2 ) :: dfun1 , dfun2 real ( wp ) :: detJ real ( wp ), dimension ( 2 , 2 ) :: J , invJ real ( wp ), dimension (:), pointer :: alpha_row ! Initialize function output. Actual number of pts is num_pts*num_pts, ! because the meshgrid goes in both x and y directions. Only need one. num_pts = size ( xi , 1 ) allocate ( out ( num_pts , num_pts )) out = 0._wp outer : do ii = 1 , num_pts inner : do jj = 1 , num_pts ! Calculate Jacobian, inverse Jacobian, and determinant of finite ! element at (xi,eta) J = getJacobian ( N , xi ( ii , jj ), eta ( ii , jj ), xy , alpha ) invJ = inv2 ( J ) detJ = det2 ( J ) alpha_row => alpha (:, node1 ) ! If fun1 is just N_i, use dot_product to determine N_i if ( d1 == 0 ) then fun1 = dot_product ( alpha_row , getArow ( N , xi ( ii , jj ), eta ( ii , jj ))) else ! If fun1 contains a derivative, need to calc N_i,xi and N_i,eta dfun1 ( 1 ) = ( & dot_product ( alpha_row , getArow ( N , xi ( ii , jj ) + eps , eta ( ii , jj ))) - & dot_product ( alpha_row , getArow ( N , xi ( ii , jj ) - eps , eta ( ii , jj ))) & ) / ( 2._wp * eps ) dfun1 ( 2 ) = ( & dot_product ( alpha_row , getArow ( N , xi ( ii , jj ), eta ( ii , jj ) + eps )) - & dot_product ( alpha_row , getArow ( N , xi ( ii , jj ), eta ( ii , jj ) - eps )) & ) / ( 2._wp * eps ) ! N_i,x = dxi/dx * N_i,xi + deta/dx * N_i,eta fun1 = dot_product ( invJ ( d1 ,:), dfun1 ) endif alpha_row => alpha (:, node2 ) ! If fun2 is just N_i, use dot_product to determine N_i if ( d2 == 0 ) then fun2 = dot_product ( alpha_row , getArow ( N , xi ( ii , jj ), eta ( ii , jj ))) else ! If fun2 contains a derivative, need to calc N_i,xi and N_i,eta dfun2 ( 1 ) = ( & dot_product ( alpha_row , getArow ( N , xi ( ii , jj ) + eps , eta ( ii , jj ))) - & dot_product ( alpha_row , getArow ( N , xi ( ii , jj ) - eps , eta ( ii , jj ))) & ) / ( 2._wp * eps ) dfun2 ( 2 ) = ( & dot_product ( alpha_row , getArow ( N , xi ( ii , jj ), eta ( ii , jj ) + eps )) - & dot_product ( alpha_row , getArow ( N , xi ( ii , jj ), eta ( ii , jj ) - eps )) & ) / ( 2._wp * eps ) ! N_i,y = dxi/dy * N_i,xi + deta/dy * N_i,eta fun2 = dot_product ( invJ ( d2 ,:), dfun2 ) endif out ( ii , jj ) = fun1 * fun2 * detJ enddo inner enddo outer return end function fun end function assembleElementalMatrix2D module subroutine assemble2D ( points , cells , diff , vel , GlobalA ) integer , intent ( in ), dimension (:,:) :: cells real ( wp ), intent ( in ) :: diff real ( wp ), intent ( in ), dimension ( 2 ) :: vel real ( wp ), intent ( in ), dimension (:,:) :: points real ( wp ), intent ( out ), dimension (:,:) :: GlobalA integer :: ii , jj integer :: num_cells , num_pts real ( wp ), parameter :: eps = epsilon ( 0 e0 ) real ( wp ), dimension (:,:), allocatable :: Ie , xy GlobalA = 0._wp num_cells = size ( cells , 1 ) num_pts = size ( cells , 2 ) allocate ( xy ( num_pts , 2 ), Ie ( num_pts , num_pts )) ! NOTE: This is assuming that all elements have the same number of points !$OMP PARALLEL DEFAULT(SHARED) PRIVATE(ii, xy, Ie) REDUCTION(+:GlobalA) !$OMP DO outer : do ii = 1 , num_cells xy = points ( cells ( ii ,:), :) ! *** Elemental matrix for diffusion in X and Y *** Ie = assembleElementalMatrix ( num_pts , 1 , 1 , xy ) + & & assembleElementalMatrix ( num_pts , 2 , 2 , xy ) GlobalA ( cells ( ii ,:), cells ( ii ,:)) = & & GlobalA ( cells ( ii ,:), cells ( ii ,:)) - diff * Ie ! Add elemental matrix for velcity in X (1) and Y (2) to GlobalA adv : do jj = 1 , 2 if ( abs ( vel ( jj )) . gt . eps ) then Ie = assembleElementalMatrix ( num_pts , 0 , jj , xy ) GlobalA ( cells ( ii ,:), cells ( ii ,:)) = & & GlobalA ( cells ( ii ,:), cells ( ii ,:)) - vel ( jj ) * Ie endif enddo adv enddo outer !$OMP END DO !$OMP END PARALLEL deallocate ( Ie , xy ) return end subroutine assemble2D end submodule","title":"smod_assemble_2D.f90 – learn_dg","loc":"sourcefile/smod_assemble_2d.f90.html"},{"tags":"","text":"Modules mod_integration Source Code mod_integration.f90 Source Code ! Learn_dg - A quick and dirty project to deploy a working DG solver ! Copyright (c) 2017, Chris Coutinho ! All rights reserved. ! ! Licensed under the BSD-2 clause license. See LICENSE for details. module mod_integration use , intrinsic :: iso_fortran_env , only : wp => real64 use :: lib_array , only : linspace implicit none private public :: integrate interface integrate module procedure integrate1D module procedure integrate2D end interface integrate interface module function fun2d_interf ( x , y ) result ( z ) real ( wp ), intent ( in ) :: x (:,:), y (:,:) real ( wp ), allocatable :: z (:,:) end function module function fun1d_interf ( xx ) result ( yy ) real ( wp ), intent ( in ) :: xx (:) real ( wp ), allocatable :: yy (:) end function fun1d_interf module subroutine gaussquad ( N , x , w ) integer , intent ( in ) :: N real ( wp ), intent ( out ) :: x ( N ), w ( N ) end subroutine gaussquad end interface contains module function integrate1D ( fun , xbnds ) result ( result ) ! This routine uses gauss-legendre quadrature to integrate a 1D ! line function ! Input/Output dummy variables real ( wp ), intent ( in ) :: xbnds ( 2 ) real ( wp ) :: result procedure ( fun1d_interf ) :: fun ! Local variables integer , parameter :: N_start = 2 integer :: N real ( wp ) :: result_old , error real ( wp ), parameter :: eps = epsilon ( 0 e0 ) real ( wp ), allocatable :: x (:), w (:), y (:) N = N_start result = 0.0_wp error = 1.0_wp do result_old = result allocate ( x ( N ), w ( N ), y ( N )) call gaussquad ( N , x , w ) y = fun ( x ) result = dot_product ( y , w ) deallocate ( x , w , y ) ! error = norm2([result, result_old]) error = sqrt (( result - result_old ) ** 2.0_wp ) ! error = abs((result-result_old)/(result_old+eps)) ! print*, N, result, error ! print*, N, result, result_old, error, eps ! Check if error is acceptable, as well as whether the loop ! was gone through at least twice (N = 3, 4, 5...) if ( N > N_start . and . & norm2 ( [ error ] ) <= eps ) then ! print'(a,i3,a,e13.5)',  'Fun integrated in ', N, & !                         ' iterations. Error = ', error exit else N = N + 1 endif enddo return end function integrate1D module function integrate2D ( fun , xbnds , ybnds ) result ( out ) procedure ( fun2d_interf ) :: fun real ( wp ), intent ( in ) :: xbnds ( 2 ), ybnds ( 2 ) real ( wp ) :: out integer , parameter :: N_start = 4 integer :: ii , N real ( wp ) :: out_old , error real ( wp ), parameter :: eps = epsilon ( 0 e0 ) real ( wp ), dimension (:), allocatable :: x , w real ( wp ), dimension (:,:), allocatable :: xx , yy real ( wp ), dimension (:,:), allocatable :: wx , wy real ( wp ), dimension (:,:), allocatable :: out_spread ! Adaptive integration based on 2D Gauss-Legendre Quadrature ii = 1 ! Iteration number N = N_start ! Initial number of points to use error = 1._wp ! Initial estimate of error do ! Allocate x (positions) and w (weights) based on roots of the Legendre ! polynomial of order 'N' allocate ( x ( N ), w ( N )) allocate ( xx ( N , N ), yy ( N , N )) allocate ( wx ( N , N ), wy ( N , N )) allocate ( out_spread ( N , N )) call gaussquad ( N , x , w ) ! Copy the 'x' array along both the x and y axes xx = spread ( x , dim = 1 , ncopies = N ) yy = spread ( x , dim = 2 , ncopies = N ) ! Copy the weights along both the x and y axes as well wx = spread ( w , dim = 1 , ncopies = N ) wy = spread ( w , dim = 2 , ncopies = N ) ! Calculate the function at the xx and yy nodes, and ! multiply the result with the weights: wx and wy out_spread = fun ( xx , yy ) * wx * wy ! Sum up the resulting array into a single scalar output out = sum ( reshape ( out_spread , [ N * N , 1 ] )) ! print*, out ! Set error if ii > 1 if ( ii > 1 ) then error = out - out_old else error = 1._wp endif ! Deallocate all arrays no longer needed. They will change ! size in each iteration anyway deallocate ( x , w , xx , yy , wx , wy , out_spread ) ! If iteration counter is more than 1 then check exit ! criteria if ( N > N_start . and . & norm2 ( [ error ] ) <= eps ) then ! print'(a,i3,a,e13.5)', 'Fun integrated in ', N, & !                        ' iterations. Error = ', error exit else out_old = out ii = ii + 1 N = N + 1 endif enddo return end function end module mod_integration","title":"mod_integration.f90 – learn_dg","loc":"sourcefile/mod_integration.f90.html"},{"tags":"","text":"Submodules smod_integration Source Code smod_integration.f90 Source Code submodule ( mod_integration ) smod_integration implicit none contains module subroutine gaussquad ( N , x , w ) integer , intent ( in ) :: N real ( wp ), intent ( out ), dimension ( N ) :: x , w select case ( N ) case ( 1 ) x = [ 0._wp ] w = [ 2._wp ] case ( 2 ) x = [ - 0.5773502691896257_wp , & 0.5773502691896257_wp ] w = [ 1._wp , & 1._wp ] case ( 3 ) x = [ - 0.7745966692414834_wp , & 0._wp , & 0.7745966692414834_wp ] w = [ 0.5555555555555556_wp , & 0.8888888888888888_wp , & 0.5555555555555556_wp ] case ( 4 ) x = [ - 0.8611363115940526_wp , & - 0.3399810435848563_wp , & 0.3399810435848563_wp , & 0.8611363115940526_wp ] w = [ 0.3478548451374538_wp , & 0.6521451548625461_wp , & 0.6521451548625461_wp , & 0.3478548451374538_wp ] case ( 5 ) x = [ - 0.9061798459386640_wp , & - 0.5384693101056831_wp , & 0._wp , & 0.5384693101056831_wp , & 0.9061798459386640_wp ] w = [ 0.2369268850561891_wp , & 0.4786286704993665_wp , & 0.5688888888888889_wp , & 0.4786286704993665_wp , & 0.2369268850561891_wp ] case default ! call lgwt(-1._wp, 1._wp, N, x, w) ! call cgwt(N, x, w) call gaussquad_rosetta ( N , x , w ) end select return end subroutine gaussquad subroutine lgwt ( a , b , num_pts , x , w ) !*  This function is a fortran90 port of the matlab function, !   lgwt.m The source code of lgwt.m was originally found at: !   http://www.mathworks.com/matlabcentral/fileexchange/4540 ! Variables in/out integer , intent ( in ) :: num_pts real ( wp ), intent ( in ) :: a , b real ( wp ), intent ( out ) :: x (:), w (:) ! Local variables integer :: ii , jj , N , N1 , N2 ! real(wp), parameter:: eps=sqrt(epsilon(1.0_wp)) real ( wp ), parameter :: eps = 1 d - 10 real ( wp ), dimension (:), allocatable :: xu , array1 , y , y0 , Lpp real ( wp ), dimension (:, :), allocatable :: L , Lp real ( wp ), parameter :: pi = 4.0_wp * datan ( 1.0_wp ) N = num_pts - 1 N1 = N + 1 N2 = N + 2 ! Allocate and initialize arrays allocate ( xu ( N1 ), array1 ( N1 ), y ( N1 ), y0 ( N1 )) allocate ( L ( N1 , N2 ), Lp ( N1 , N2 ), Lpp ( N1 )) L = 0.0_wp Lp = 0.0_wp call linspace ( - 1.0_wp , 1.0_wp , xu ) array1 = [ ( ii , ii = 0 , N ) ] ! Initial guess of the roots of the Legendre polynomial of order N y = cos (( 2.0_wp * dble ( array1 ) + 1.0_wp ) * & pi / ( 2.0_wp * dble ( N ) + 2.0_wp )) + & ( 0.27_wp / dble ( N1 )) * sin ( pi * xu * dble ( N ) / dble ( N2 )) y0 = 2.0_wp outer : do L (:, 1 ) = 1.0_wp Lp (:, 1 ) = 0.0_wp L (:, 2 ) = y Lp (:, 2 ) = 1.0_wp inner : do jj = 2 , N1 L (:, jj + 1 ) = ( & ( 2.0_wp * dble ( jj ) - 1.0_wp ) * y * L (:, jj ) - & dble ( jj - 1 ) * L (:, jj - 1 )) & / dble ( jj ) enddo inner Lpp = dble ( N2 ) * ( L (:, N1 ) - y * L (:, N2 )) & / ( 1.0_wp - y ** 2.0_wp ) y0 = y y = y0 - L (:, N2 ) / Lpp if ( norm2 ( y - y0 ) < eps ) then exit outer endif enddo outer x = ( a * ( 1.0_wp - y ) + b * ( 1.0_wp + y ) ) / 2.0_wp w = ( b - a ) / (( 1.0_wp - y ** 2.0_wp ) * Lpp ** 2.0_wp ) * & ( dble ( N2 ) / dble ( N1 )) ** 2.0_wp return end subroutine lgwt subroutine cgwt ( num_pts , x , w ) ! This function determines the points and weights associated ! with Chebyshev-Gauss quadrature ! Variables in/out integer , intent ( in ) :: num_pts real ( wp ), intent ( out ), dimension (:) :: x , w ! Local variables integer :: ii real ( wp ), parameter :: pi = 4._wp * datan ( 1._wp ) x = cos ( ( dble ( 2 * [( ii , ii = 1 , num_pts )] - 1 ) ) / dble ( 2 * num_pts ) * pi ) w = pi / dble ( num_pts ) / (( 1.0_wp - x ** 2._wp ) ** ( - 0.5_wp )) ! print*, x ! print*, w ! stop return end subroutine cgwt subroutine gaussquad_rosetta ( n , r1 , r2 ) ! This code was originally found at the following website: !  http://rosettacode.org/wiki/Numerical_integration/Gauss-Legendre_Quadrature#Fortran integer , intent ( in ) :: n real ( wp ), intent ( out ) :: r1 ( n ), r2 ( n ) integer :: k real ( wp ), parameter :: pi = 4._wp * atan ( 1._wp ) real ( wp ) :: x , f , df , dx integer :: i , iter real ( wp ), allocatable :: p0 (:), p1 (:), tmp (:) p0 = [ 1._wp ] p1 = [ 1._wp , 0._wp ] do k = 2 , n tmp = (( 2 * k - 1 ) * [ p1 , 0._wp ] - ( k - 1 ) * [ 0._wp , 0._wp , p0 ]) / k p0 = p1 ; p1 = tmp enddo outer : do i = 1 , n x = cos ( pi * ( i - 0.25_wp ) / ( n + 0.5_wp )) inner : do iter = 1 , 10 f = p1 ( 1 ); df = 0._wp deep : do k = 2 , size ( p1 ) df = f + x * df f = p1 ( k ) + x * f enddo deep dx = f / df x = x - dx if ( abs ( dx ) < 10 * epsilon ( dx )) exit enddo inner r1 ( i ) = x r2 ( i ) = 2 / (( 1 - x ** 2 ) * df ** 2 ) enddo outer return end subroutine gaussquad_rosetta end submodule","title":"smod_integration.f90 – learn_dg","loc":"sourcefile/smod_integration.f90.html"},{"tags":"","text":"Modules mod_io Source Code mod_io.f90 Source Code ! Learn_dg - A quick and dirty project to deploy a working DG solver ! Copyright (c) 2017, Chris Coutinho ! All rights reserved. ! ! Licensed under the BSD-2 clause license. See LICENSE for details. module mod_io use , intrinsic :: iso_fortran_env , only : wp => real64 use :: lib_array , only : linspace implicit none private public :: read_gmsh_file_1D , & write_out_solution contains subroutine read_gmsh_file_1D ( num_nodes , & nodes2vertex , & cells , & points , & dg ) !*  Reads the input mesh file (gmsh .msh format) and returns the !   number of nodes, element connectivity, and the coordinates of !   the nodes in 1D integer , intent ( out ) :: num_nodes !! Number of nodes in mesh integer , intent ( out ), dimension (:), allocatable :: nodes2vertex !! Array containing node to vertex connectivity (only interesting w.r.t discontinuous galerkin) integer , intent ( out ), dimension (:,:), allocatable :: cells !! Array containing node connectivity of each element real ( wp ), intent ( out ), dimension (:), allocatable :: points !! Array containing node coordinates logical , intent ( in ) :: dg !! Logical switch is continuous galerkin or discontinuous galerkin integer :: ii , ios , vertex , num_elements , num_vertexes , d_int integer , dimension (:,:), allocatable :: vertex_conn real ( wp ) :: d_real character ( 80 ) :: filename character ( 80 ) :: blank_string call get_command_argument ( 1 , filename ) if ( len_trim ( filename ) == 0 ) then call print_header () endif open ( unit = 21 , file = filename , iostat = ios , status = \"old\" , action = \"read\" ) if ( ios /= 0 ) then print * , filename print * , ios stop \"Error opening file \" endif ! Read initial header information - assuming file is in the correct format do read ( 21 , * ) blank_string if ( trim ( blank_string ) == '$Nodes' ) exit enddo ! Read number of nodes read ( 21 , * ) num_vertexes allocate ( points ( num_vertexes )) if ( . not . dg ) then num_nodes = num_vertexes else num_nodes = 2 * num_vertexes - 2 endif ! Read coordinate information for each vertex do ii = 1 , num_vertexes read ( 21 , * ) d_int , points ( ii ), d_real , d_real enddo allocate ( nodes2vertex ( num_nodes )) nodes2vertex = 0 if ( dg ) then vertex = 1 do ii = 1 , num_nodes nodes2vertex ( ii ) = vertex if ( ii == 1 . or . ii == num_nodes ) then vertex = vertex + 1 elseif ( mod ( ii , 2 ) == 0 ) then vertex = vertex + 1 endif enddo else nodes2vertex = [( ii , ii = 1 , num_nodes )] endif ! do ii = 1, num_nodes !   print*, ii, nodes2vertex(ii), points(nodes2vertex(ii)) ! enddo ! print*, ! stop ! Two dummy lines : !   $EndNodes !   $Elements read ( 21 , * ) read ( 21 , * ) read ( 21 , * ) num_elements num_elements = num_elements - 2 allocate ( cells ( num_elements , 2 )) allocate ( vertex_conn ( num_elements , 2 )) ! Two dummy lines - Associated with 'point' elements read ( 21 , * ) read ( 21 , * ) do ii = 1 , num_elements read ( 21 , * ) d_int , d_int , d_int , d_int , d_int , vertex_conn ( ii , 1 : 2 ) ! print*, pack(vertex_conn, vertex_conn == nodes2vertex) enddo ! print*, pack([( ii, ii = 1, num_nodes )], & !         nodes2vertex == nodes2vertex(3) & !         .or. nodes2vertex == nodes2vertex(5)) ! stop if ( . not . dg ) then cells = vertex_conn else ! do ii = 1, num_elements !   cells(ii,:) = pack([( ii, ii = 1, num_nodes )], & !                     nodes2vertex == vertex_conn(ii,1)) !   print*, loc(2._wp) !   print*, loc(nodes2vertex == vertex_conn(ii,2)) !   print*, vertex_conn(ii,:), cells(ii,:) !   print*, ! enddo endif ! print*, ! do ii = 1, size(points) !   print*, points(ii) ! enddo ! print*, close ( unit = 21 , iostat = ios ) if ( ios /= 0 ) stop \"Error closing file unit 21\" return end subroutine read_gmsh_file_1D subroutine write_out_solution ( num_nodes , points , GlobalX ) integer , intent ( in ) :: num_nodes real ( wp ), intent ( in ), dimension (:) :: points , GlobalX integer :: ii , ios open ( unit = 21 , file = 'data.out' , iostat = ios , status = \"replace\" , action = \"write\" ) if ( ios /= 0 ) then print * , ios stop \"Error opening file data.out\" endif do ii = 1 , num_nodes write ( 21 , * ) points ( ii ), GlobalX ( ii ) enddo close ( unit = 21 , iostat = ios ) if ( ios /= 0 ) then print * , ios stop \"Error closing file unit data.out\" endif return end subroutine write_out_solution subroutine print_header () ! print*, ! print*, '  _____  ______ _____      _             _     ' ! print*, ' |  __ \\|  ____|  __ \\    | |           | |    ' ! print*, ' | |__) | |__  | |  | |___| |_ __ _  ___| | __ ' ! print*, ' |  _  /|  __| | |  | / __| __/ _` |/ __| |/ / ' ! print*, ' | | \\ \\| |____| |__| \\__ \\ || (_| | (__|   <  ' ! print*, ' |_|  \\_\\______|_____/|___/\\__\\__,_|\\___|_|\\_\\ ' ! print*, ! print*, ! print*, ' Developed by Chris Coutinho                   ' ! print*, print * , print * , '     ____  __________       __             __   ' print * , '    / __ \\/ ____/ __ \\_____/ /_____ ______/ /__ ' print * , '   / /_/ / __/ / / / / ___/ __/ __ `/ ___/ //_/ ' print * , '  / _, _/ /___/ /_/ (__  ) /_/ /_/ / /__/ ,<    ' print * , ' /_/ |_/_____/_____/____/\\__/\\__,_/\\___/_/|_|   ' print * , print * , print * , ' Developed by Chris Coutinho                   ' print * , print * , 'No Input file supplied' print * , stop end subroutine print_header end module mod_io","title":"mod_io.f90 – learn_dg","loc":"sourcefile/mod_io.f90.html"},{"tags":"","text":"Modules mod_legendre Source Code mod_legendre.f90 Source Code ! Learn_dg - A quick and dirty project to deploy a working DG solver ! Copyright (c) 2017, Chris Coutinho ! All rights reserved. ! ! Licensed under the BSD-2 clause license. See LICENSE for details. module mod_legendre use , intrinsic :: iso_fortran_env , only : wp => real64 implicit none private public :: basis_1D interface basis_1D pure module function basis_1D ( x , alpha , dx ) result ( y ) ! Input/output variables integer , intent ( in ) :: dx real ( wp ), intent ( in ), dimension (:) :: x real ( wp ), intent ( in ), dimension (:) :: alpha real ( wp ), dimension (:), allocatable :: y end function basis_1D end interface basis_1D public :: getXY interface getXY pure module function getXY_2D ( N ) result ( xy ) integer , intent ( in ) :: N real ( wp ), dimension ( N , 2 ) :: xy end function getXY_2D end interface getXY public :: pascal_single_row interface pascal_single_row pure module function pascal_row_2D ( N , x , y ) result ( row ) integer , intent ( in ) :: N real ( wp ), intent ( in ) :: x real ( wp ), intent ( in ) :: y real ( wp ), dimension ( N + 1 ) :: row end function pascal_row_2D end interface pascal_single_row public :: pascal_row interface pascal_row pure module function pascal_1D_line ( N , x ) result ( row ) integer , intent ( in ) :: N real ( wp ), intent ( in ) :: x real ( wp ), dimension ( N + 1 ) :: row end function pascal_1D_line pure module function pascal_2D_quad ( N , x , y ) result ( row ) integer , intent ( in ) :: N real ( wp ), intent ( in ) :: x real ( wp ), intent ( in ) :: y real ( wp ), dimension (( N + 1 ) ** 2 ) :: row end function pascal_2D_quad end interface pascal_row public :: getArow interface getArow pure module function getArow1D ( N , xi ) result ( row ) integer , intent ( in ) :: N real ( wp ), intent ( in ) :: xi real ( wp ), dimension ( N ) :: row end function getArow1D pure module function getArow2D ( N , xi , eta ) result ( row ) integer , intent ( in ) :: N real ( wp ), intent ( in ) :: xi , eta real ( wp ), dimension ( N ) :: row end function getArow2D end interface getArow public :: getAlpha2D interface getAlpha2D module function getAlpha2D ( N ) result ( alpha ) integer , intent ( in ) :: N real ( wp ), dimension ( N , N ) :: alpha end function getAlpha2D end interface getAlpha2D public :: getAlpha1D interface getAlpha1D module function getAlpha1D ( N ) result ( alpha ) integer , intent ( in ) :: N real ( wp ), dimension ( N , N ) :: alpha end function getAlpha1D end interface getAlpha1D public :: getJacobian interface getJacobian module function getJacobian_2D ( N , xi , eta , xy , alpha ) result ( J ) integer , intent ( in ) :: N real ( wp ), intent ( in ) :: xi real ( wp ), intent ( in ) :: eta real ( wp ), dimension ( N , 2 ), intent ( in ) :: xy real ( wp ), dimension ( N , N ), intent ( in ) :: alpha real ( wp ), dimension ( 2 , 2 ) :: J end function getJacobian_2D end interface getJacobian end module mod_legendre","title":"mod_legendre.f90 – learn_dg","loc":"sourcefile/mod_legendre.f90.html"},{"tags":"","text":"Modules mod_legendre_c Source Code mod_legendre_c.f90 Source Code ! Learn_dg - A quick and dirty project to deploy a working DG solver ! Copyright (c) 2017, Chris Coutinho ! All rights reserved. ! ! Licensed under the BSD-2 clause license. See LICENSE for details. module mod_legendre_c use , intrinsic :: iso_c_binding , only : c_int , c_double use :: mod_legendre , only : pascal_row , pascal_single_row implicit none private public :: pascal_1D_line_c , pascal_2D_quad_c ! NOTE: Not really sure if it's possible to use an iterface across a c-binding ! public :: pascal_row_c ! interface pascal_row_c !   module subroutine pascal_1D_line_c(N, x, row) bind(c, name='pascal_1D_line_c') !     integer(c_int), intent(in), value :: N !     real(c_double), intent(in), value :: x !     real(c_double), intent(out)       :: row(N+1) !   end subroutine pascal_1D_line_c ! !   module subroutine pascal_2D_quad_c(N, x, y, row) bind(c, name='pascal_2D_quad_c') !     integer(c_int), intent(in)  :: N !     real(c_double), intent(in)  :: x !     real(c_double), intent(in)  :: y !     real(c_double), intent(out) :: row((N+1)**2) !   end subroutine pascal_2D_quad_c ! end interface pascal_row_c contains module subroutine pascal_1D_line_c ( N , x , row ) bind ( c , name = 'pascal_1D_line_c' ) integer ( c_int ), intent ( in ), value :: N real ( c_double ), intent ( in ), value :: x real ( c_double ), intent ( out ) :: row ( N + 1 ) row = pascal_row ( N , x ) return end subroutine pascal_1D_line_c module subroutine pascal_single_row_c ( N , x , y , row ) bind ( c , name = 'pascal_single_row_c' ) integer ( c_int ), intent ( in ), value :: N real ( c_double ), intent ( in ), value :: x real ( c_double ), intent ( in ), value :: y real ( c_double ), intent ( out ) :: row ( N + 1 ) row = pascal_single_row ( N , x , y ) return end subroutine pascal_single_row_c module subroutine pascal_2D_quad_c ( N , x , y , row ) bind ( c , name = 'pascal_2D_quad_c' ) integer ( c_int ), intent ( in ), value :: N real ( c_double ), intent ( in ), value :: x real ( c_double ), intent ( in ), value :: y real ( c_double ), intent ( out ) :: row (( N + 1 ) ** 2 ) row = pascal_row ( N , x , y ) return end subroutine pascal_2D_quad_c end module mod_legendre_c","title":"mod_legendre_c.f90 – learn_dg","loc":"sourcefile/mod_legendre_c.f90.html"},{"tags":"","text":"Submodules smod_legendre_1D Source Code smod_legendre_1D.f90 Source Code ! Learn_dg - A quick and dirty project to deploy a working DG solver ! Copyright (c) 2017, Chris Coutinho ! All rights reserved. ! ! Licensed under the BSD-2 clause license. See LICENSE for details. submodule ( mod_legendre ) smod_legendre_1D !* ! Legendre_1D is a submodule used to generate arrays of coeffiecents used for ! developing finite element basis functions in 1D. Finite element basis ! functions are defined at internal nodes and used to iterpolate some value ! between those nodes. ! ! ! calculate the coeffiecents associated with a univarate Lagrangian polynomial ! !  1, x, x&#94;2, ..., x&#94;N  ! ! ! In the end you end up with a group of basis functions similar to this: ! ! ![Quadratic Basis Functions catption](|media|/quadratic_basis.png \"Quadratic Basis Functions\"){: width=\"500\" } ! {: style=\"text-align: center\" } use :: mod_linalg , only : linsolve_quick , eye use :: lib_array , only : linspace implicit none contains pure module function getArow1D ( N , xi ) result ( row ) integer , intent ( in ) :: N real ( wp ), intent ( in ) :: xi real ( wp ), dimension ( N ) :: row row = pascal_row ( N - 1 , xi ) return end function getArow1D module function getx ( N ) result ( x ) integer , intent ( in ) :: N real ( wp ), dimension ( N ) :: x call linspace ( - 1.d0 , 1.d0 , x ) ! Gmsh orders all their lines as endpoint1, endpoint2, internal... ! Therefore, need to reorder if numpts is more than 2 if ( N > 2 ) x = [ x ( 1 ), x ( N ), x ( 2 : N - 1 )] return end function getx module function getAlpha1D ( N ) result ( alpha ) integer , intent ( in ) :: N real ( wp ), dimension ( N , N ) :: alpha real ( wp ), dimension ( N , N ) :: A , B A = getA ( N ) B = eye ( N ) call linsolve_quick ( N , A , N , B , alpha ) return contains function getA ( N ) result ( A ) integer , intent ( in ) :: N real ( wp ), dimension ( N , N ) :: A integer :: ii real ( wp ), dimension ( N ) :: x x = getx ( N ) do ii = 1 , N A ( ii ,:) = getArow1D ( N , x ( ii )) enddo return end function getA end function getAlpha1D ! module procedure pascal_1D_line pure module function pascal_1D_line ( N , x ) result ( row ) !* ! Generates the elements of an array associated with a univarate ! Lagrange polynomial. integer , intent ( in ) :: N real ( wp ), intent ( in ) :: x real ( wp ), dimension ( N + 1 ) :: row integer :: ii row = [( x ** ( ii - 1 ), ii = 1 , N + 1 )] return end function pascal_1D_line ! end procedure pascal_1D_line pure module function basis_1D ( x , alpha , dx ) result ( y ) ! Input/output variables integer , intent ( in ) :: dx real ( wp ), intent ( in ), dimension (:) :: x real ( wp ), intent ( in ), dimension (:) :: alpha real ( wp ), dimension (:), allocatable :: y , yx ! Local variables integer :: ii , N allocate ( y , mold = x ) allocate ( yx , mold = x ) N = size ( alpha ) y = 0._wp do ii = 1 + dx , N yx = dble (( ii - 1 ) ** dx ) * alpha ( ii ) * x ** dble ( ii - 1 - dx ) y = y + yx enddo return end function basis_1D end submodule smod_legendre_1D","title":"smod_legendre_1D.f90 – learn_dg","loc":"sourcefile/smod_legendre_1d.f90.html"},{"tags":"","text":"Submodules smod_legendre_2D Source Code smod_legendre_2D.f90 Source Code ! Learn_dg - A quick and dirty project to deploy a working DG solver ! Copyright (c) 2017, Chris Coutinho ! All rights reserved. ! ! Licensed under the BSD-2 clause license. See LICENSE for details. submodule ( mod_legendre ) smod_legendre_2D use :: mod_linalg , only : linsolve_quick , eye use :: mod_misc , only : r8mat_print implicit none contains pure module function getXY_2D ( N ) result ( xy ) integer , intent ( in ) :: N real ( wp ), dimension ( N , 2 ) :: xy ! Keep a copy of 0, 1, and 1/3 handy so no need to retype it all the time real ( wp ), parameter :: zero = 0._wp real ( wp ), parameter :: one = 1._wp real ( wp ), parameter :: half = 1._wp / 2._wp real ( wp ), parameter :: third = 1._wp / 3._wp select case ( N ) case ( 4 ) xy ( 1 ,:) = [ - one , - one ] ! Node 1 xy ( 2 ,:) = [ one , - one ] ! Node 2 xy ( 3 ,:) = [ one , one ] ! Node 3 xy ( 4 ,:) = [ - one , one ] ! Node 4 case ( 9 ) xy ( 1 ,:) = [ - one , - one ] ! Node 1 xy ( 2 ,:) = [ one , - one ] ! Node 2 xy ( 3 ,:) = [ one , one ] ! Node 3 xy ( 4 ,:) = [ - one , one ] ! Node 4 xy ( 5 ,:) = [ zero , - one ] ! Node 5 xy ( 6 ,:) = [ one , zero ] ! Node 6 xy ( 7 ,:) = [ zero , one ] ! Node 7 xy ( 8 ,:) = [ - one , zero ] ! Node 8 xy ( 9 ,:) = [ zero , zero ] ! Node 9 case ( 16 ) xy ( 1 ,:) = [ - one , - one ] ! Node 1 xy ( 2 ,:) = [ one , - one ] ! Node 2 xy ( 3 ,:) = [ one , one ] ! Node 3 xy ( 4 ,:) = [ - one , one ] ! Node 4 xy ( 5 ,:) = [ - third , - one ] ! Node 5 xy ( 6 ,:) = [ third , - one ] ! Node 6 xy ( 7 ,:) = [ one , - third ] ! Node 7 xy ( 8 ,:) = [ one , third ] ! Node 8 xy ( 9 ,:) = [ third , one ] ! Node 9 xy ( 10 ,:) = [ - third , one ] ! Node 10 xy ( 11 ,:) = [ - one , third ] ! Node 11 xy ( 12 ,:) = [ - one , - third ] ! Node 12 xy ( 13 ,:) = [ - third , - third ] ! Node 13 xy ( 14 ,:) = [ third , - third ] ! Node 14 xy ( 15 ,:) = [ third , third ] ! Node 15 xy ( 16 ,:) = [ - third , third ] ! Node 16 case ( 25 ) xy ( 1 ,:) = [ - one , - one ] ! Node 1 xy ( 2 ,:) = [ one , - one ] ! Node 2 xy ( 3 ,:) = [ one , one ] ! Node 3 xy ( 4 ,:) = [ - one , one ] ! Node 4 xy ( 5 ,:) = [ - half , - one ] ! Node 5 xy ( 6 ,:) = [ zero , - one ] ! Node 6 xy ( 7 ,:) = [ half , - one ] ! Node 7 xy ( 8 ,:) = [ one , - half ] ! Node 8 xy ( 9 ,:) = [ one , zero ] ! Node 9 xy ( 10 ,:) = [ one , half ] ! Node 10 xy ( 11 ,:) = [ half , one ] ! Node 11 xy ( 12 ,:) = [ zero , one ] ! Node 12 xy ( 13 ,:) = [ - half , one ] ! Node 13 xy ( 14 ,:) = [ - one , half ] ! Node 14 xy ( 15 ,:) = [ - one , zero ] ! Node 15 xy ( 16 ,:) = [ - one , - half ] ! Node 16 xy ( 17 ,:) = [ - half , - half ] ! Node 17 xy ( 18 ,:) = [ half , - half ] ! Node 18 xy ( 19 ,:) = [ half , half ] ! Node 19 xy ( 20 ,:) = [ - half , half ] ! Node 20 xy ( 21 ,:) = [ zero , - half ] ! Node 21 xy ( 22 ,:) = [ half , zero ] ! Node 22 xy ( 23 ,:) = [ zero , half ] ! Node 23 xy ( 24 ,:) = [ - half , zero ] ! Node 24 xy ( 25 ,:) = [ zero , zero ] ! Node 25 case default ! TODO: I need to change this to a subroutine and ! include an output error variable - Pure can't print output xy = 0.d0 ! print*, 'getXY_2D called with N = ', N ! print*, 'That`s not implemented' end select return end function getXY_2D pure module function getArow2D ( N , xi , eta ) result ( row ) integer , intent ( in ) :: N real ( wp ), intent ( in ) :: xi , eta real ( wp ), dimension ( N ) :: row select case ( N ) case ( 4 ) row = pascal_row ( 1 , xi , eta ) case ( 9 ) row = pascal_row ( 2 , xi , eta ) case ( 16 ) row = pascal_row ( 3 , xi , eta ) case ( 25 ) row = pascal_row ( 4 , xi , eta ) case default row = 0.d0 ! print*, 'getArow2D called with N = ', N ! print*, 'That N is not yet implemented' end select return end function getArow2D module function getAlpha2D ( N ) result ( alpha ) integer , intent ( in ) :: N real ( wp ), dimension ( N , N ) :: alpha integer :: ii real ( wp ), dimension ( N , N ) :: A , B A = getA ( N ) B = eye ( N ) call linsolve_quick ( N , A , N , B , alpha ) return contains function getA ( N ) result ( A ) integer , intent ( in ) :: N real ( wp ), dimension ( N , N ) :: A integer :: ii real ( wp ), dimension ( N , 2 ) :: xy xy = getXY_2D ( N ) do ii = 1 , N A ( ii ,:) = getArow ( N , xy ( ii , 1 ), xy ( ii , 2 )) enddo return end function getA end function getAlpha2D ! module procedure pascal_2D_quad pure module function pascal_2D_quad ( N , x , y ) result ( row ) !* ! Generates an array of points related to a quadrilateral using Pascal's ! triangle in 2D, where rows are 0-indexed ! ! Pascal's triangle in 2D looks like this, with points used in bi-quadratic quadrilateral in bold: !    [\\mathbf{1}]  !    [\\mathbf{x},~ \\mathbf{y}]  !    [\\mathbf{x&#94;2},~ \\mathbf{x y},~ \\mathbf{y&#94;2}]  !    [x&#94;3,~ \\mathbf{x&#94;2y},~ \\mathbf{xy&#94;2},~ y&#94;3]  !    [x&#94;4,~ x&#94;3y,~ \\mathbf{x&#94;2y&#94;2},~ xy&#94;3, y&#94;4]  !    \\vdots  !    [x&#94;N,~ x&#94;{N-1}y,~ \\cdots ~,~ xy&#94;{N-1},~ y&#94;N]  integer , intent ( in ) :: N !! Order of the qaudrilateral real ( wp ), intent ( in ) :: x !! X-coordinate of node used in calculation real ( wp ), intent ( in ) :: y !! Y-coordinate of node used in calculation real ( wp ), dimension (( N + 1 ) ** 2 ) :: row !! Output row integer :: ii real ( wp ), dimension (:), allocatable :: temp_pre , temp_post row = 0.d0 ! Collects the first N rows of a 2D pascal triangle as function of x and y temp_pre = [( pascal_row_2D ( ii , x , y ), ii = 0 , N )] temp_post = [( pascal_2D_quad_post ( N , ii , x , y ), ii = N + 1 , 2 * N )] row = [ temp_pre , temp_post ] return contains pure function pascal_2D_quad_post ( N_ , ii_ , x_ , y_ ) result ( row_ ) integer , intent ( in ) :: N_ , ii_ real ( wp ), intent ( in ) :: x_ , y_ real ( wp ), dimension ( 2 * N_ - ii_ + 1 ) :: row_ integer :: start , finish real ( wp ), dimension (:), allocatable :: temp temp = pascal_row_2D ( ii_ , x_ , y_ ) start = ii_ - N_ + 1 finish = N_ + 1 row_ = temp ( start : finish ) return end function pascal_2D_quad_post end function pascal_2D_quad ! end procedure pascal_2D_quad pure function pascal_row_2D ( N , x , y ) result ( row ) !* ! Generates a row of Pascal's triangle in 2D ! ! Pascal's triangle in 2D looks like this: !    [1]  !    [x,~ y]  !    [x&#94;2,~ x y,~ y&#94;2]  !    [x&#94;3,~ x&#94;2y,~ xy&#94;2,~ y&#94;3]  !    [x&#94;4,~ x&#94;3y,~ x&#94;2y&#94;2,~ xy&#94;3, y&#94;4]  !    \\vdots  !    [x&#94;N,~ x&#94;{N-1}y,~ \\cdots,~ xy&#94;{N-1},~ y&#94;N]  ! ! The rows are zero-indexed, therefore, the third row (index=2) ! would be x&#94;2, x\\cdot y, y&#94;2 integer , intent ( in ) :: N !! Row number of pascal's 2D triange (0-indexed) real ( wp ), intent ( in ) :: x !! X-value used in triange real ( wp ), intent ( in ) :: y !! Y-Value used in triange real ( wp ), dimension ( N + 1 ) :: row !! Output row of triange integer :: ii ! Produces the elements of an array: [x&#94;N, x&#94;(N-1)*y, x&#94;(N-2)*y&#94;2, ..., y&#94;N] row = [( x ** ( N - ii ) * y ** ( ii ), ii = 0 , N )] return end function pascal_row_2D module function getJacobian_2D ( N , xi , eta , xy , alpha ) result ( J ) !* ! Calculates the Jacobian of a quadrilateral element at a point ! ! The Jacobian of an element is defined as: !  \\boldsymbol{J} = \\boldsymbol{P} \\boldsymbol{X}  ! ! Where: !  \\boldsymbol{P} = \\left[ \\begin{array}{cc} !     \\frac{\\partial H_1}{\\partial \\xi} & \\frac{\\partial H_2}{\\partial \\xi} \\\\ !     \\frac{\\partial H_1}{\\partial \\eta} & \\frac{\\partial H_2}{\\partial \\eta} \\end{array} !       \\cdots !     \\begin{array}{cc} !     \\frac{\\partial H_{N-1}}{\\partial \\xi} & \\frac{\\partial H_{N}}{\\partial \\xi} \\\\ !     \\frac{\\partial H_{N-1}}{\\partial \\eta} & \\frac{\\partial H_{N}}{\\partial \\eta} \\end{array} ! \\right] ! !  \\boldsymbol{X} = \\left[ \\begin{array}{c} !      \\begin{array}{cc} !        x_1 & y_1 \\\\ !        x_2 & y_2 !      \\end{array} \\\\\\\\ !      \\vdots \\\\\\\\ !      \\begin{array}{cc} !        x_{N-1} & y_{N-1} \\\\ !        x_N & y_N !      \\end{array} \\\\ !    \\end{array} \\right] ! ! Thus: ! !  \\boldsymbol{J} =  \\left[ \\begin{array}{cc} !           \\boldsymbol{H}_{\\xi} \\cdot \\boldsymbol{x} & \\boldsymbol{H}_{\\xi} \\cdot \\boldsymbol{y} \\\\ !           \\boldsymbol{H}_{\\eta} \\cdot \\boldsymbol{x} & \\boldsymbol{H}_{\\eta} \\cdot \\boldsymbol{y} \\\\ !         \\end{array} \\right] = \\left[ \\begin{array}{cc} !           \\frac{\\partial \\xi}{\\partial x} & \\frac{\\partial \\xi}{\\partial y} \\\\ !           \\frac{\\partial \\eta}{\\partial x} & \\frac{\\partial \\eta}{\\partial y} \\\\ !         \\end{array} \\right]  ! ! *  \\boldsymbol{H}  : Vector of basis functions ! *  \\boldsymbol{x}  : Vector of X-coordinates for all element nodes ! *  \\boldsymbol{y}  : Vector of Y-coordinates for all element nodes ! ! *  H_i  : Basis function i ! *  x_i  : X-coordinate of node i ! *  y_i  : Y-coordinate of node i integer , intent ( in ) :: N !! Number of points in element real ( wp ), intent ( in ) :: xi !! Value of xi coordinate in isoparametric element real ( wp ), intent ( in ) :: eta !! Value of eta coordinate in isoparametric element real ( wp ), dimension ( N , 2 ), intent ( in ) :: xy !! Array of x and y coordinates for the element real ( wp ), dimension ( N , N ), intent ( in ) :: alpha !! Array of coefficients used to define basis functions real ( wp ), dimension ( 2 , 2 ) :: J !! Jacobian of the isoparametric element at (xi,eta) real ( wp ), parameter :: eps = epsilon ( 0 e0 ) real ( wp ), dimension ( 2 , N ) :: P !! Array of derivatives of each basis function at (xi,eta) real ( wp ), dimension ( N ) :: x !! Row in element coefficient matrix ! P is a matrix containing derivatives of each basis function at (xi,eta) ! P = [dN_1/dxi, dN_2/dxi, dN_3/dxi, ... !      dN_1/deta, dN_2/deta, dN_3/deta, ...] P = 0._wp P ( 1 ,:) = [ getArow ( N , xi + eps , eta ) - & getArow ( N , xi - eps , eta )] P ( 2 ,:) = [ getArow ( N , xi , eta + eps ) - & getArow ( N , xi , eta - eps )] P = P / ( 2._wp * eps ) P = matmul ( P , alpha ) J = matmul ( P , xy ) return end function getJacobian_2D end submodule smod_legendre_2D","title":"smod_legendre_2D.f90 – learn_dg","loc":"sourcefile/smod_legendre_2d.f90.html"},{"tags":"","text":"Modules mod_linalg Source Code mod_linalg.f90 Source Code ! Learn_dg - A quick and dirty project to deploy a working DG solver ! Copyright (c) 2017, Chris Coutinho ! All rights reserved. ! ! Licensed under the BSD-2 clause license. See LICENSE for details. module mod_linalg use , intrinsic :: iso_fortran_env , only : wp => real64 implicit none private public :: linsolve_quick , linsolve , inv2 , det2 , eye contains pure function eye ( N ) ! Generates an identity matrix of size (N,N) integer , intent ( in ) :: N real ( wp ), dimension ( N , N ) :: eye integer :: ii eye = 0._wp forall ( ii = 1 : N ) eye ( ii , ii ) = 1._wp return end function eye pure function inv2 ( J ) result ( invJ ) ! Computes the inverse of a 2x2 matrix real ( wp ), dimension ( 2 , 2 ), intent ( in ) :: J real ( wp ), dimension ( 2 , 2 ) :: invJ invJ = reshape ( [ J ( 2 , 2 ), - J ( 2 , 1 ), - J ( 1 , 2 ), J ( 1 , 1 )], [ 2 , 2 ] ) invJ = invJ / det2 ( J ) return end function inv2 pure function det2 ( A ) result ( det ) ! Computes the determinant of a 2x2 matrix real ( wp ), dimension ( 2 , 2 ), intent ( in ) :: A real ( wp ) :: det det = A ( 1 , 1 ) * A ( 2 , 2 ) - A ( 1 , 2 ) * A ( 2 , 1 ) return end function det2 subroutine linsolve_quick ( n , a , nrhs , b , x ) ! Quick wrapper around linsolve integer , intent ( in ) :: n , nrhs real ( wp ), intent ( in ), dimension ( n , n ) :: a real ( wp ), intent ( in ), dimension ( n , nrhs ) :: b real ( wp ), intent ( out ), dimension ( n , nrhs ) :: x integer , dimension ( n ) :: P real ( wp ), dimension ( n , n ) :: LU call linsolve ( n , a , nrhs , b , x , LU , P , . False .) return end subroutine linsolve_quick subroutine linsolve ( n , a , nrhs , b , x , LU , P , toggle ) ! Linsolve is a wrapper of dgesv, the main linear solver routine for ! general dense matrices in LAPACK. This routine splits dgesv into ! its two primary components: ! !       dgetrf - Decomposes A into P*L*U !       dgetrs - Uses P*L*U to solve for x (Ax=b => (P*L*U)x=b) ! ! Splitting these two up like this allows you to save the decomposed ! version of 'A' so that you don't have to do it again. If 'toggle' ! is equal to true, then the decomposition has already occured and ! LU can be trusted - OK to skip dgetrf ! Dummy variables integer , intent ( in ) :: n , nrhs integer , intent ( inout ), dimension ( n ) :: P real ( wp ), intent ( in ), dimension ( n , n ) :: a real ( wp ), intent ( in ), dimension ( n , nrhs ) :: b real ( wp ), intent ( out ), dimension ( n , nrhs ) :: x real ( wp ), intent ( inout ), dimension ( n , n ) :: LU logical , intent ( in ) :: toggle ! Local variables integer :: info integer , dimension ( n ) :: my_P real ( wp ), dimension ( n , n ) :: my_a real ( wp ), dimension ( n , nrhs ) :: my_b my_a = a my_b = b if ( . not . toggle ) then call dgetrf ( n , n , my_a , n , my_P , info ) if ( info /= 0 ) then write ( * , '(a)' ) ' ' write ( * , '(a)' ) 'DGETRF' write ( * , '(a,i8)' ) '  Factorization failed, INFO = ' , info stop endif LU = my_a P = my_P endif call dgetrs ( 'No transpose' , n , nrhs , LU , n , P , my_b , n , info ) if ( info /= 0 ) then write ( * , '(a)' ) ' ' write ( * , '(a)' ) 'DGETRS' write ( * , '(a,i8)' ) '  Back substitution failed, INFO = ' , info stop endif x = my_b return end subroutine linsolve end module mod_linalg","title":"mod_linalg.f90 – learn_dg","loc":"sourcefile/mod_linalg.f90.html"},{"tags":"","text":"Modules mod_misc Source Code mod_misc.f90 Source Code ! Learn_dg - A quick and dirty project to deploy a working DG solver ! Copyright (c) 2017, Chris Coutinho ! All rights reserved. ! ! Licensed under the BSD-2 clause license. See LICENSE for details. module mod_misc use , intrinsic :: iso_fortran_env , only : wp => real64 implicit none private public :: r8mat_print contains subroutine r8mat_print ( m , n , a , title ) ! ************************************************************************** ! !* R8MAT_PRINT prints an R8MAT. ! !  Discussion: ! !    An R8MAT is a two dimensional matrix of double precision real values. ! !  Licensing: ! !    This code is distributed under the GNU LGPL license. ! !  Modified: ! !    12 September 2004 ! !  Author: ! !    John Burkardt ! !  Parameters: ! !    Input, integer M, the number of rows in A. ! !    Input, integer N, the number of columns in A. ! !    Input, real ( kind = 8 ) A(M,N), the matrix. ! !    Input, character ( len = * ) TITLE, a title to be printed. implicit none integer ( kind = 4 ) m integer ( kind = 4 ) n real ( kind = 8 ) a ( m , n ) character ( len = * ) title call r8mat_print_some ( m , n , a , 1 , 1 , m , n , title ) return end subroutine r8mat_print subroutine r8mat_print_some ( m , n , a , ilo , jlo , ihi , jhi , title ) ! ************************************************************************** ! !* R8MAT_PRINT_SOME prints some of an R8MAT. ! !  Discussion: ! !    An R8MAT is a two dimensional matrix of double precision real values. ! !  Licensing: ! !    This code is distributed under the GNU LGPL license. ! !  Modified: ! !    26 March 2005 ! !  Author: ! !    John Burkardt ! !  Parameters: ! !    Input, integer M, N, the number of rows and columns. ! !    Input, real ( kind = 8 ) A(M,N), an M by N matrix to be printed. ! !    Input, integer ILO, JLO, the first row and column to print. ! !    Input, integer IHI, JHI, the last row and column to print. ! !    Input, character ( len = * ) TITLE, an optional title. implicit none integer ( kind = 4 ), parameter :: incx = 5 integer ( kind = 4 ) m integer ( kind = 4 ) n real ( kind = 8 ) a ( m , n ) character ( len = 14 ) ctemp ( incx ) integer ( kind = 4 ) i integer ( kind = 4 ) i2hi integer ( kind = 4 ) i2lo integer ( kind = 4 ) ihi integer ( kind = 4 ) ilo integer ( kind = 4 ) inc integer ( kind = 4 ) j integer ( kind = 4 ) j2 integer ( kind = 4 ) j2hi integer ( kind = 4 ) j2lo integer ( kind = 4 ) jhi integer ( kind = 4 ) jlo character ( len = * ) title if ( 0 < len_trim ( title ) ) then write ( * , '(a)' ) ' ' write ( * , '(a)' ) trim ( title ) endif do j2lo = max ( jlo , 1 ), min ( jhi , n ), incx j2hi = j2lo + incx - 1 j2hi = min ( j2hi , n ) j2hi = min ( j2hi , jhi ) inc = j2hi + 1 - j2lo write ( * , '(a)' ) ' ' do j = j2lo , j2hi j2 = j + 1 - j2lo write ( ctemp ( j2 ), '(i8,6x)' ) j enddo write ( * , '(''  Col   '',5a14)' ) ctemp ( 1 : inc ) write ( * , '(a)' ) '  Row' write ( * , '(a)' ) ' ' i2lo = max ( ilo , 1 ) i2hi = min ( ihi , m ) do i = i2lo , i2hi do j2 = 1 , inc j = j2lo - 1 + j2 if ( a ( i , j ) == real ( int ( a ( i , j ) ), kind = 8 ) ) then write ( ctemp ( j2 ), '(f8.0,6x)' ) a ( i , j ) else write ( ctemp ( j2 ), '(g14.6)' ) a ( i , j ) endif enddo write ( * , '(i5,1x,5a14)' ) i , ( ctemp ( j ), j = 1 , inc ) enddo enddo write ( * , '(a)' ) ' ' return end subroutine r8mat_print_some end module mod_misc","title":"mod_misc.f90 – learn_dg","loc":"sourcefile/mod_misc.f90.html"},{"tags":"","text":"Modules mod_settings Source Code mod_settings.f90 Source Code module mod_settings use iso_fortran_env , only : wp => real64 implicit none private public :: t_settings type t_settings integer :: length = 0 integer :: width = 0 end type t_settings end module mod_settings","title":"mod_settings.f90 – learn_dg","loc":"sourcefile/mod_settings.f90.html"},{"tags":"","text":"type, public :: t_settings Variables length width Source Code t_settings Components Type Visibility Attributes Name Initial integer, public :: length = 0 integer, public :: width = 0 Source Code type t_settings integer :: length = 0 integer :: width = 0 end type t_settings","title":"t_settings – learn_dg ","loc":"type/t_settings.html"},{"tags":"","text":"public interface assembleElementalMatrix Functions assembleElementalMatrix1D assembleElementalMatrix2D Functions public function assembleElementalMatrix1D(N, d1, d2, xy) result(Ie) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N integer, intent(in) :: d1 integer, intent(in) :: d2 real(kind=wp), intent(in), dimension(N) :: xy Return Value real(kind=wp),\n  dimension(N,N) public function assembleElementalMatrix2D(N, d1, d2, xy) result(Ie) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N integer, intent(in) :: d1 integer, intent(in) :: d2 real(kind=wp), intent(in), dimension(N,2) :: xy Return Value real(kind=wp),\n  dimension(N,N)","title":"assembleElementalMatrix – learn_dg","loc":"interface/assembleelementalmatrix.html"},{"tags":"","text":"public interface initialize_global_mats Subroutines initialize_global_mats Subroutines public subroutine initialize_global_mats(num_nodes, GlobalA, GlobalB, GlobalX) Arguments Type Intent Optional Attributes Name integer, intent(in) :: num_nodes real(kind=wp), intent(out), dimension(:,:), allocatable :: GlobalA real(kind=wp), intent(out), dimension(:), allocatable :: GlobalB real(kind=wp), intent(out), dimension(:), allocatable :: GlobalX","title":"initialize_global_mats – learn_dg","loc":"interface/initialize_global_mats.html"},{"tags":"","text":"public interface assemble Subroutines assemble1D assemble2D Subroutines public subroutine assemble1D(points, cells, diff, vel, GlobalA) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: points integer, intent(in), dimension(:,:) :: cells real(kind=wp), intent(in) :: diff real(kind=wp), intent(in) :: vel real(kind=wp), intent(out), dimension(:,:) :: GlobalA public subroutine assemble2D(points, cells, diff, vel, GlobalA) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:,:) :: points integer, intent(in), dimension(:,:) :: cells real(kind=wp), intent(in) :: diff real(kind=wp), intent(in), dimension(2) :: vel real(kind=wp), intent(out), dimension(:,:) :: GlobalA","title":"assemble – learn_dg","loc":"interface/assemble.html"},{"tags":"","text":"public interface set_BCs Subroutines set_BCs Subroutines public subroutine set_BCs(points, GlobalB, GlobalA) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: points Array of nodal coordinates real(kind=wp), intent(out), dimension(:) :: GlobalB Global RHS Vector real(kind=wp), intent(out), dimension(:,:) :: GlobalA","title":"set_BCs – learn_dg","loc":"interface/set_bcs.html"},{"tags":"","text":"private subroutine assembleElementalMatrix1D_c(N, d1, d2, xy, Ie) bind(c, name=\"0\") Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in), value :: N integer(kind=c_int), intent(in), value :: d1 integer(kind=c_int), intent(in), value :: d2 real(kind=c_double), intent(in) :: xy (N) real(kind=c_double), intent(inout) :: Ie (N,N) Source Code assembleElementalMatrix1D_c Source Code subroutine assembleElementalMatrix1D_c ( N , d1 , d2 , xy , Ie ) & bind ( c , name = 'assembleElementalMatrix1D_c' ) integer ( c_int ), intent ( in ), value :: N , d1 , d2 real ( c_double ), intent ( in ) :: xy ( N ) real ( c_double ), intent ( inout ) :: Ie ( N , N ) integer :: ii Ie = assembleElementalMatrix ( N , d1 , d2 , xy ) return end subroutine assembleElementalMatrix1D_c","title":"assembleElementalMatrix1D_c – learn_dg","loc":"proc/assembleelementalmatrix1d_c.html"},{"tags":"","text":"private subroutine assembleElementalMatrix2D_c(N, d1, d2, xy, Ie) bind(c, name=\"0\") Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in), value :: N integer(kind=c_int), intent(in), value :: d1 integer(kind=c_int), intent(in), value :: d2 real(kind=c_double), intent(in) :: xy (N,2) real(kind=c_double), intent(inout) :: Ie (N,N) Source Code assembleElementalMatrix2D_c Source Code subroutine assembleElementalMatrix2D_c ( & N , d1 , d2 , xy , Ie ) & bind ( c , name = 'assembleElementalMatrix2D_c' ) integer ( c_int ), intent ( in ), value :: N , d1 , d2 real ( c_double ), intent ( in ) :: xy ( N , 2 ) real ( c_double ), intent ( inout ) :: Ie ( N , N ) integer :: ii Ie = assembleElementalMatrix ( N , d1 , d2 , xy ) return end subroutine assembleElementalMatrix2D_c","title":"assembleElementalMatrix2D_c – learn_dg","loc":"proc/assembleelementalmatrix2d_c.html"},{"tags":"","text":"private subroutine assemble1D_c(num_cells, num_pts_per_cell, num_pts, points, cells, diff, vel, GlobalA) bind(c, name=\"0\") Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in), value :: num_cells integer(kind=c_int), intent(in), value :: num_pts_per_cell integer(kind=c_int), intent(in), value :: num_pts real(kind=c_double), intent(in) :: points (num_pts) integer(kind=c_int), intent(in) :: cells (num_cells,num_pts_per_cell) real(kind=c_double), intent(in), value :: diff real(kind=c_double), intent(in), value :: vel real(kind=c_double), intent(inout) :: GlobalA (num_pts,num_pts) Source Code assemble1D_c Source Code subroutine assemble1D_c ( & num_cells , num_pts_per_cell , num_pts , points , cells , & diff , vel , GlobalA ) & bind ( c , name = 'assemble1D_c' ) integer ( c_int ), intent ( in ), value :: num_cells , num_pts_per_cell , num_pts integer ( c_int ), intent ( in ) :: cells ( num_cells , num_pts_per_cell ) real ( c_double ), intent ( in ), value :: diff , vel real ( c_double ), intent ( in ) :: points ( num_pts ) real ( c_double ), intent ( inout ) :: GlobalA ( num_pts , num_pts ) call assemble ( points , cells , diff , vel , GlobalA ) return end subroutine assemble1D_c","title":"assemble1D_c – learn_dg","loc":"proc/assemble1d_c.html"},{"tags":"","text":"private subroutine assemble2D_c(num_cells, num_pts_per_cell, num_pts, points, cells, diff, vel, GlobalA) bind(c, name=\"0\") Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in), value :: num_cells integer(kind=c_int), intent(in), value :: num_pts_per_cell integer(kind=c_int), intent(in), value :: num_pts real(kind=c_double), intent(in) :: points (num_pts,2) integer(kind=c_int), intent(in) :: cells (num_cells,num_pts_per_cell) real(kind=c_double), intent(in), value :: diff real(kind=c_double), intent(in) :: vel (2) real(kind=c_double), intent(inout) :: GlobalA (num_pts,num_pts) Source Code assemble2D_c Source Code subroutine assemble2D_c ( num_cells , num_pts_per_cell , num_pts , & & points , cells , diff , vel , GlobalA ) bind ( c , name = 'assemble2D_c' ) integer ( c_int ), intent ( in ), value :: num_cells , num_pts_per_cell , num_pts integer ( c_int ), intent ( in ) :: cells ( num_cells , num_pts_per_cell ) real ( c_double ), intent ( in ), value :: diff real ( c_double ), intent ( in ) :: vel ( 2 ), points ( num_pts , 2 ) real ( c_double ), intent ( inout ) :: GlobalA ( num_pts , num_pts ) call assemble ( points , cells , diff , vel , GlobalA ) return end subroutine assemble2D_c","title":"assemble2D_c – learn_dg","loc":"proc/assemble2d_c.html"},{"tags":"","text":"function integrate_basis_1d_Ie(N, ii, jj, dii, djj, xy) result(integral) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N integer, intent(in) :: ii integer, intent(in) :: jj integer, intent(in) :: dii integer, intent(in) :: djj real(kind=wp), intent(in), dimension(:) :: xy Return Value real(kind=wp) Source Code integrate_basis_1d_Ie Source Code function integrate_basis_1d_Ie ( N , ii , jj , dii , djj , xy ) result ( integral ) integer , intent ( in ) :: N , ii , jj , dii , djj real ( wp ), intent ( in ), dimension (:) :: xy real ( wp ) :: integral integer :: kk integer :: order , basis_num1 , basis_num2 real ( wp ), dimension ( N + 1 , N + 1 ) :: Vinv order = N basis_num1 = ii basis_num2 = jj Vinv = getAlpha ( order + 1 ) ! Check to make sure xy is an array of size (N+1) if ( size ( xy ) /= order + 1 ) then write ( * , * ) 'The shape of `xy` is outside the acceptable range for a' write ( * , * ) '1D basis function.' write ( * , * ) 'Shape(xy) should be [' , 2 , order + 1 , '], not ' , shape ( xy ) endif ! call integrate(local_wrapper, [-1.0_wp, 1.0_wp], integral) integral = integrate ( local_wrapper , [ - 1._wp , 1._wp ]) return contains pure function local_wrapper ( s ) result ( y ) real ( wp ), intent ( in ) :: s (:) real ( wp ), allocatable :: y (:) real ( wp ), allocatable :: J (:) allocate ( J , mold = s ) allocate ( y , mold = s ) call XorJ ( s , 1 , J ) y = 1.0_wp ! Here we have to be careful because J is not always needed in the ! first two function calls. Instead of using if statements, we can ! use an exponent so that when dx_ == 0, J is 1 y = y * basis_1D ( s , Vinv (:, basis_num1 ), dii ) / ( J ** dble ( dii )) y = y * basis_1D ( s , Vinv (:, basis_num2 ), djj ) / ( J ** dble ( djj )) y = y * J deallocate ( J ) return end function local_wrapper pure subroutine XorJ ( s , dx , out ) integer , intent ( in ) :: dx real ( wp ), intent ( in ), dimension (:) :: s real ( wp ), intent ( out ), dimension (:) :: out integer :: ii out = 0.0_wp do ii = 1 , size ( xy ) out = out + basis_1D ( s , Vinv (:, ii ), dx ) * xy ( ii ) enddo return end subroutine XorJ end function integrate_basis_1d_Ie","title":"integrate_basis_1d_Ie – learn_dg","loc":"proc/integrate_basis_1d_ie.html"},{"tags":"","text":"subroutine assemble1D(points, cells, diff, vel, GlobalA) Assemble the global stiffness matrix based on element connectivity Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: points Array of nodal coordinates integer, intent(in), dimension(:,:) :: cells Element connectivity real(kind=wp), intent(in) :: diff Diffusivity coefficient [m/s&#94;2] real(kind=wp), intent(in) :: vel Velocity [m/s] real(kind=wp), intent(out), dimension(:,:) :: GlobalA Global Stiffness matrix Source Code assemble1D Source Code subroutine assemble1D ( points , cells , diff , vel , GlobalA ) !* Assemble the global stiffness matrix based on element connectivity integer , intent ( in ), dimension (:,:) :: cells !! Element connectivity real ( wp ), intent ( in ) :: diff !! Diffusivity coefficient [m/s&#94;2] real ( wp ), intent ( in ) :: vel !! Velocity [m/s] real ( wp ), intent ( in ), dimension (:) :: points !! Array of nodal coordinates real ( wp ), intent ( out ), dimension (:,:) :: GlobalA !! Global Stiffness matrix integer :: ii , num_cells , num_pts real ( wp ), parameter :: eps = epsilon ( 1 e0 ) real ( wp ), allocatable :: xy (:), Ie (:,:) GlobalA = 0._wp num_cells = size ( cells , 1 ) ! Add elemental stiffness matrices to Global Stiffness Matrix !$OMP PARALLEL DEFAULT(SHARED) PRIVATE(ii, xy, Ie) REDUCTION(+:GlobalA) !$OMP DO do ii = 1 , num_cells num_pts = size ( cells ( ii ,:)) ! Reallocate elemental stiffness matrix allocate ( xy ( num_pts ), Ie ( num_pts , num_pts )) xy = points ( cells ( ii ,:)) Ie = assembleElementalMatrix1D ( num_pts , 1 , 1 , xy ) ! call r8mat_print(num_pts, num_pts, Ie, 'Elemental Stiffness Matrix:') GlobalA ( cells ( ii ,:), cells ( ii ,:)) = & GlobalA ( cells ( ii ,:), cells ( ii ,:)) - diff * Ie if ( abs ( vel ) . gt . eps ) then Ie = assembleElementalMatrix1D ( num_pts , 0 , 1 , xy ) ! call r8mat_print(num_pts, num_pts, Ie, 'Elemental Stiffness Matrix:') GlobalA ( cells ( ii ,:), cells ( ii ,:)) = & GlobalA ( cells ( ii ,:), cells ( ii ,:)) - vel * Ie endif ! Deallocate elemental stiffness matrix after every loop deallocate ( Ie , xy ) ! stop enddo !$OMP END DO !$OMP END PARALLEL ! call r8mat_print(num_nodes, num_nodes, GlobalA, 'Global Stiffness Matrix:') ! stop return end subroutine assemble1D","title":"assemble1D – learn_dg","loc":"proc/assemble1d.html"},{"tags":"","text":"subroutine set_BCs(points, GlobalB, GlobalA) Set boundary conditions in GlobalA and GlobalB using two\n   Dirchlet boundaries Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: points Array of nodal coordinates real(kind=wp), intent(out), dimension(:) :: GlobalB Global RHS Vector real(kind=wp), intent(out), dimension(:,:) :: GlobalA Global Mass Matrix Source Code set_BCs Source Code subroutine set_BCs ( points , GlobalB , GlobalA ) !*  Set boundary conditions in GlobalA and GlobalB using two !   Dirchlet boundaries real ( wp ), intent ( in ), dimension (:) :: points !! Array of nodal coordinates real ( wp ), intent ( out ), dimension (:) :: GlobalB !! Global RHS Vector real ( wp ), intent ( out ), dimension (:,:) :: GlobalA !! Global Mass Matrix integer , dimension ( 1 ) :: iloc !! Index variable to locate node numbers based on points ! Left Boundary Dirchlet BC iloc = minloc ( points ) GlobalA ( iloc ,:) = 0._wp GlobalA ( iloc , iloc ) = 1._wp GlobalB ( iloc ) = 0._wp ! Right Boundary Dirchlet BC iloc = maxloc ( points ) GlobalA ( iloc ,:) = 0._wp GlobalA ( iloc , iloc ) = 1._wp GlobalB ( iloc ) = 1._wp ! call r8mat_print(num_nodes, 1, GlobalB, 'Global RHS:') ! stop return end subroutine set_BCs","title":"set_BCs – learn_dg","loc":"proc/set_bcs.html"},{"tags":"","text":"private function integrate1D(fun, xbnds) result(result) Arguments Type Intent Optional Attributes Name procedure( fun1d_interf ) :: fun real(kind=wp), intent(in) :: xbnds (2) Return Value real(kind=wp) Source Code integrate1D Source Code module function integrate1D ( fun , xbnds ) result ( result ) ! This routine uses gauss-legendre quadrature to integrate a 1D ! line function ! Input/Output dummy variables real ( wp ), intent ( in ) :: xbnds ( 2 ) real ( wp ) :: result procedure ( fun1d_interf ) :: fun ! Local variables integer , parameter :: N_start = 2 integer :: N real ( wp ) :: result_old , error real ( wp ), parameter :: eps = epsilon ( 0 e0 ) real ( wp ), allocatable :: x (:), w (:), y (:) N = N_start result = 0.0_wp error = 1.0_wp do result_old = result allocate ( x ( N ), w ( N ), y ( N )) call gaussquad ( N , x , w ) y = fun ( x ) result = dot_product ( y , w ) deallocate ( x , w , y ) ! error = norm2([result, result_old]) error = sqrt (( result - result_old ) ** 2.0_wp ) ! error = abs((result-result_old)/(result_old+eps)) ! print*, N, result, error ! print*, N, result, result_old, error, eps ! Check if error is acceptable, as well as whether the loop ! was gone through at least twice (N = 3, 4, 5...) if ( N > N_start . and . & norm2 ( [ error ] ) <= eps ) then ! print'(a,i3,a,e13.5)',  'Fun integrated in ', N, & !                         ' iterations. Error = ', error exit else N = N + 1 endif enddo return end function integrate1D","title":"integrate1D – learn_dg","loc":"proc/integrate1d.html"},{"tags":"","text":"private function integrate2D(fun, xbnds, ybnds) result(out) Arguments Type Intent Optional Attributes Name procedure( fun2d_interf ) :: fun real(kind=wp), intent(in) :: xbnds (2) real(kind=wp), intent(in) :: ybnds (2) Return Value real(kind=wp)","title":"integrate2D – learn_dg","loc":"proc/integrate2d.html"},{"tags":"","text":"public interface integrate Module Procedures integrate1D integrate2D Module Procedures private function integrate1D (fun, xbnds) result(result) Arguments Type Intent Optional Attributes Name procedure( fun1d_interf ) :: fun real(kind=wp), intent(in) :: xbnds (2) Return Value real(kind=wp) private function integrate2D (fun, xbnds, ybnds) result(out) Arguments Type Intent Optional Attributes Name procedure( fun2d_interf ) :: fun real(kind=wp), intent(in) :: xbnds (2) real(kind=wp), intent(in) :: ybnds (2) Return Value real(kind=wp)","title":"integrate – learn_dg","loc":"interface/integrate.html"},{"tags":"","text":"interface private function fun2d_interf(x, y) result(z) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x (:,:) real(kind=wp), intent(in) :: y (:,:) Return Value real(kind=wp),\n  allocatable,(:,:)","title":"fun2d_interf – learn_dg","loc":"interface/fun2d_interf.html"},{"tags":"","text":"interface private function fun1d_interf(xx) result(yy) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: xx (:) Return Value real(kind=wp),\n  allocatable,(:)","title":"fun1d_interf – learn_dg","loc":"interface/fun1d_interf.html"},{"tags":"","text":"interface private module subroutine gaussquad(N, x, w) Implementation → Arguments Type Intent Optional Attributes Name integer, intent(in) :: N real(kind=wp), intent(out) :: x (N) real(kind=wp), intent(out) :: w (N)","title":"gaussquad – learn_dg","loc":"interface/gaussquad.html"},{"tags":"","text":"subroutine lgwt(a, b, num_pts, x, w) This function is a fortran90 port of the matlab function,\n   lgwt.m The source code of lgwt.m was originally found at:\n   http://www.mathworks.com/matlabcentral/fileexchange/4540 Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a real(kind=wp), intent(in) :: b integer, intent(in) :: num_pts real(kind=wp), intent(out) :: x (:) real(kind=wp), intent(out) :: w (:) Source Code lgwt Source Code subroutine lgwt ( a , b , num_pts , x , w ) !*  This function is a fortran90 port of the matlab function, !   lgwt.m The source code of lgwt.m was originally found at: !   http://www.mathworks.com/matlabcentral/fileexchange/4540 ! Variables in/out integer , intent ( in ) :: num_pts real ( wp ), intent ( in ) :: a , b real ( wp ), intent ( out ) :: x (:), w (:) ! Local variables integer :: ii , jj , N , N1 , N2 ! real(wp), parameter:: eps=sqrt(epsilon(1.0_wp)) real ( wp ), parameter :: eps = 1 d - 10 real ( wp ), dimension (:), allocatable :: xu , array1 , y , y0 , Lpp real ( wp ), dimension (:, :), allocatable :: L , Lp real ( wp ), parameter :: pi = 4.0_wp * datan ( 1.0_wp ) N = num_pts - 1 N1 = N + 1 N2 = N + 2 ! Allocate and initialize arrays allocate ( xu ( N1 ), array1 ( N1 ), y ( N1 ), y0 ( N1 )) allocate ( L ( N1 , N2 ), Lp ( N1 , N2 ), Lpp ( N1 )) L = 0.0_wp Lp = 0.0_wp call linspace ( - 1.0_wp , 1.0_wp , xu ) array1 = [ ( ii , ii = 0 , N ) ] ! Initial guess of the roots of the Legendre polynomial of order N y = cos (( 2.0_wp * dble ( array1 ) + 1.0_wp ) * & pi / ( 2.0_wp * dble ( N ) + 2.0_wp )) + & ( 0.27_wp / dble ( N1 )) * sin ( pi * xu * dble ( N ) / dble ( N2 )) y0 = 2.0_wp outer : do L (:, 1 ) = 1.0_wp Lp (:, 1 ) = 0.0_wp L (:, 2 ) = y Lp (:, 2 ) = 1.0_wp inner : do jj = 2 , N1 L (:, jj + 1 ) = ( & ( 2.0_wp * dble ( jj ) - 1.0_wp ) * y * L (:, jj ) - & dble ( jj - 1 ) * L (:, jj - 1 )) & / dble ( jj ) enddo inner Lpp = dble ( N2 ) * ( L (:, N1 ) - y * L (:, N2 )) & / ( 1.0_wp - y ** 2.0_wp ) y0 = y y = y0 - L (:, N2 ) / Lpp if ( norm2 ( y - y0 ) < eps ) then exit outer endif enddo outer x = ( a * ( 1.0_wp - y ) + b * ( 1.0_wp + y ) ) / 2.0_wp w = ( b - a ) / (( 1.0_wp - y ** 2.0_wp ) * Lpp ** 2.0_wp ) * & ( dble ( N2 ) / dble ( N1 )) ** 2.0_wp return end subroutine lgwt","title":"lgwt – learn_dg","loc":"proc/lgwt.html"},{"tags":"","text":"subroutine cgwt(num_pts, x, w) Arguments Type Intent Optional Attributes Name integer, intent(in) :: num_pts real(kind=wp), intent(out), dimension(:) :: x real(kind=wp), intent(out), dimension(:) :: w Source Code cgwt Source Code subroutine cgwt ( num_pts , x , w ) ! This function determines the points and weights associated ! with Chebyshev-Gauss quadrature ! Variables in/out integer , intent ( in ) :: num_pts real ( wp ), intent ( out ), dimension (:) :: x , w ! Local variables integer :: ii real ( wp ), parameter :: pi = 4._wp * datan ( 1._wp ) x = cos ( ( dble ( 2 * [( ii , ii = 1 , num_pts )] - 1 ) ) / dble ( 2 * num_pts ) * pi ) w = pi / dble ( num_pts ) / (( 1.0_wp - x ** 2._wp ) ** ( - 0.5_wp )) ! print*, x ! print*, w ! stop return end subroutine cgwt","title":"cgwt – learn_dg","loc":"proc/cgwt.html"},{"tags":"","text":"subroutine gaussquad_rosetta(n, r1, r2) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=wp), intent(out) :: r1 (n) real(kind=wp), intent(out) :: r2 (n) Source Code gaussquad_rosetta Source Code subroutine gaussquad_rosetta ( n , r1 , r2 ) ! This code was originally found at the following website: !  http://rosettacode.org/wiki/Numerical_integration/Gauss-Legendre_Quadrature#Fortran integer , intent ( in ) :: n real ( wp ), intent ( out ) :: r1 ( n ), r2 ( n ) integer :: k real ( wp ), parameter :: pi = 4._wp * atan ( 1._wp ) real ( wp ) :: x , f , df , dx integer :: i , iter real ( wp ), allocatable :: p0 (:), p1 (:), tmp (:) p0 = [ 1._wp ] p1 = [ 1._wp , 0._wp ] do k = 2 , n tmp = (( 2 * k - 1 ) * [ p1 , 0._wp ] - ( k - 1 ) * [ 0._wp , 0._wp , p0 ]) / k p0 = p1 ; p1 = tmp enddo outer : do i = 1 , n x = cos ( pi * ( i - 0.25_wp ) / ( n + 0.5_wp )) inner : do iter = 1 , 10 f = p1 ( 1 ); df = 0._wp deep : do k = 2 , size ( p1 ) df = f + x * df f = p1 ( k ) + x * f enddo deep dx = f / df x = x - dx if ( abs ( dx ) < 10 * epsilon ( dx )) exit enddo inner r1 ( i ) = x r2 ( i ) = 2 / (( 1 - x ** 2 ) * df ** 2 ) enddo outer return end subroutine gaussquad_rosetta","title":"gaussquad_rosetta – learn_dg","loc":"proc/gaussquad_rosetta.html"},{"tags":"","text":"public subroutine read_gmsh_file_1D(num_nodes, nodes2vertex, cells, points, dg) Reads the input mesh file (gmsh .msh format) and returns the\n   number of nodes, element connectivity, and the coordinates of\n   the nodes in 1D Arguments Type Intent Optional Attributes Name integer, intent(out) :: num_nodes Number of nodes in mesh integer, intent(out), dimension(:), allocatable :: nodes2vertex Array containing node to vertex connectivity (only interesting w.r.t discontinuous galerkin) integer, intent(out), dimension(:,:), allocatable :: cells Array containing node connectivity of each element real(kind=wp), intent(out), dimension(:), allocatable :: points Array containing node coordinates logical, intent(in) :: dg Logical switch is continuous galerkin or discontinuous galerkin Source Code read_gmsh_file_1D Source Code subroutine read_gmsh_file_1D ( num_nodes , & nodes2vertex , & cells , & points , & dg ) !*  Reads the input mesh file (gmsh .msh format) and returns the !   number of nodes, element connectivity, and the coordinates of !   the nodes in 1D integer , intent ( out ) :: num_nodes !! Number of nodes in mesh integer , intent ( out ), dimension (:), allocatable :: nodes2vertex !! Array containing node to vertex connectivity (only interesting w.r.t discontinuous galerkin) integer , intent ( out ), dimension (:,:), allocatable :: cells !! Array containing node connectivity of each element real ( wp ), intent ( out ), dimension (:), allocatable :: points !! Array containing node coordinates logical , intent ( in ) :: dg !! Logical switch is continuous galerkin or discontinuous galerkin integer :: ii , ios , vertex , num_elements , num_vertexes , d_int integer , dimension (:,:), allocatable :: vertex_conn real ( wp ) :: d_real character ( 80 ) :: filename character ( 80 ) :: blank_string call get_command_argument ( 1 , filename ) if ( len_trim ( filename ) == 0 ) then call print_header () endif open ( unit = 21 , file = filename , iostat = ios , status = \"old\" , action = \"read\" ) if ( ios /= 0 ) then print * , filename print * , ios stop \"Error opening file \" endif ! Read initial header information - assuming file is in the correct format do read ( 21 , * ) blank_string if ( trim ( blank_string ) == '$Nodes' ) exit enddo ! Read number of nodes read ( 21 , * ) num_vertexes allocate ( points ( num_vertexes )) if ( . not . dg ) then num_nodes = num_vertexes else num_nodes = 2 * num_vertexes - 2 endif ! Read coordinate information for each vertex do ii = 1 , num_vertexes read ( 21 , * ) d_int , points ( ii ), d_real , d_real enddo allocate ( nodes2vertex ( num_nodes )) nodes2vertex = 0 if ( dg ) then vertex = 1 do ii = 1 , num_nodes nodes2vertex ( ii ) = vertex if ( ii == 1 . or . ii == num_nodes ) then vertex = vertex + 1 elseif ( mod ( ii , 2 ) == 0 ) then vertex = vertex + 1 endif enddo else nodes2vertex = [( ii , ii = 1 , num_nodes )] endif ! do ii = 1, num_nodes !   print*, ii, nodes2vertex(ii), points(nodes2vertex(ii)) ! enddo ! print*, ! stop ! Two dummy lines : !   $EndNodes !   $Elements read ( 21 , * ) read ( 21 , * ) read ( 21 , * ) num_elements num_elements = num_elements - 2 allocate ( cells ( num_elements , 2 )) allocate ( vertex_conn ( num_elements , 2 )) ! Two dummy lines - Associated with 'point' elements read ( 21 , * ) read ( 21 , * ) do ii = 1 , num_elements read ( 21 , * ) d_int , d_int , d_int , d_int , d_int , vertex_conn ( ii , 1 : 2 ) ! print*, pack(vertex_conn, vertex_conn == nodes2vertex) enddo ! print*, pack([( ii, ii = 1, num_nodes )], & !         nodes2vertex == nodes2vertex(3) & !         .or. nodes2vertex == nodes2vertex(5)) ! stop if ( . not . dg ) then cells = vertex_conn else ! do ii = 1, num_elements !   cells(ii,:) = pack([( ii, ii = 1, num_nodes )], & !                     nodes2vertex == vertex_conn(ii,1)) !   print*, loc(2._wp) !   print*, loc(nodes2vertex == vertex_conn(ii,2)) !   print*, vertex_conn(ii,:), cells(ii,:) !   print*, ! enddo endif ! print*, ! do ii = 1, size(points) !   print*, points(ii) ! enddo ! print*, close ( unit = 21 , iostat = ios ) if ( ios /= 0 ) stop \"Error closing file unit 21\" return end subroutine read_gmsh_file_1D","title":"read_gmsh_file_1D – learn_dg","loc":"proc/read_gmsh_file_1d.html"},{"tags":"","text":"public subroutine write_out_solution(num_nodes, points, GlobalX) Arguments Type Intent Optional Attributes Name integer, intent(in) :: num_nodes real(kind=wp), intent(in), dimension(:) :: points real(kind=wp), intent(in), dimension(:) :: GlobalX Source Code write_out_solution Source Code subroutine write_out_solution ( num_nodes , points , GlobalX ) integer , intent ( in ) :: num_nodes real ( wp ), intent ( in ), dimension (:) :: points , GlobalX integer :: ii , ios open ( unit = 21 , file = 'data.out' , iostat = ios , status = \"replace\" , action = \"write\" ) if ( ios /= 0 ) then print * , ios stop \"Error opening file data.out\" endif do ii = 1 , num_nodes write ( 21 , * ) points ( ii ), GlobalX ( ii ) enddo close ( unit = 21 , iostat = ios ) if ( ios /= 0 ) then print * , ios stop \"Error closing file unit data.out\" endif return end subroutine write_out_solution","title":"write_out_solution – learn_dg","loc":"proc/write_out_solution.html"},{"tags":"","text":"private subroutine print_header() Arguments None Source Code print_header Source Code subroutine print_header () ! print*, ! print*, '  _____  ______ _____      _             _     ' ! print*, ' |  __ \\|  ____|  __ \\    | |           | |    ' ! print*, ' | |__) | |__  | |  | |___| |_ __ _  ___| | __ ' ! print*, ' |  _  /|  __| | |  | / __| __/ _` |/ __| |/ / ' ! print*, ' | | \\ \\| |____| |__| \\__ \\ || (_| | (__|   <  ' ! print*, ' |_|  \\_\\______|_____/|___/\\__\\__,_|\\___|_|\\_\\ ' ! print*, ! print*, ! print*, ' Developed by Chris Coutinho                   ' ! print*, print * , print * , '     ____  __________       __             __   ' print * , '    / __ \\/ ____/ __ \\_____/ /_____ ______/ /__ ' print * , '   / /_/ / __/ / / / / ___/ __/ __ `/ ___/ //_/ ' print * , '  / _, _/ /___/ /_/ (__  ) /_/ /_/ / /__/ ,<    ' print * , ' /_/ |_/_____/_____/____/\\__/\\__,_/\\___/_/|_|   ' print * , print * , print * , ' Developed by Chris Coutinho                   ' print * , print * , 'No Input file supplied' print * , stop end subroutine print_header","title":"print_header – learn_dg","loc":"proc/print_header.html"},{"tags":"","text":"public interface basis_1D Functions basis_1D Functions public pure function basis_1D(x, alpha, dx) result(y) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: x real(kind=wp), intent(in), dimension(:) :: alpha integer, intent(in) :: dx Return Value real(kind=wp),\n  dimension(:), allocatable","title":"basis_1D – learn_dg","loc":"interface/basis_1d.html"},{"tags":"","text":"public interface getXY Functions getXY_2D Functions public pure function getXY_2D(N) result(xy) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N Return Value real(kind=wp),\n  dimension(N,2)","title":"getXY – learn_dg","loc":"interface/getxy.html"},{"tags":"","text":"public interface pascal_single_row Functions pascal_row_2D Functions public pure function pascal_row_2D(N, x, y) result(row) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N real(kind=wp), intent(in) :: x real(kind=wp), intent(in) :: y Return Value real(kind=wp),\n  dimension(N+1)","title":"pascal_single_row – learn_dg","loc":"interface/pascal_single_row.html"},{"tags":"","text":"public interface pascal_row Functions pascal_1D_line pascal_2D_quad Functions public pure function pascal_1D_line(N, x) result(row) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N real(kind=wp), intent(in) :: x Return Value real(kind=wp),\n  dimension(N+1) public pure function pascal_2D_quad(N, x, y) result(row) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N real(kind=wp), intent(in) :: x real(kind=wp), intent(in) :: y Return Value real(kind=wp),\n  dimension((N+1)**2)","title":"pascal_row – learn_dg","loc":"interface/pascal_row.html"},{"tags":"","text":"public interface getArow Functions getArow1D getArow2D Functions public pure function getArow1D(N, xi) result(row) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N real(kind=wp), intent(in) :: xi Return Value real(kind=wp),\n  dimension(N) public pure function getArow2D(N, xi, eta) result(row) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N real(kind=wp), intent(in) :: xi real(kind=wp), intent(in) :: eta Return Value real(kind=wp),\n  dimension(N)","title":"getArow – learn_dg","loc":"interface/getarow.html"},{"tags":"","text":"public interface getAlpha2D Functions getAlpha2D Functions public function getAlpha2D(N) result(alpha) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N Return Value real(kind=wp),\n  dimension(N,N)","title":"getAlpha2D – learn_dg","loc":"interface/getalpha2d.html"},{"tags":"","text":"public interface getAlpha1D Functions getAlpha1D Functions public function getAlpha1D(N) result(alpha) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N Return Value real(kind=wp),\n  dimension(N,N)","title":"getAlpha1D – learn_dg","loc":"interface/getalpha1d.html"},{"tags":"","text":"public interface getJacobian Functions getJacobian_2D Functions public function getJacobian_2D(N, xi, eta, xy, alpha) result(J) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N real(kind=wp), intent(in) :: xi real(kind=wp), intent(in) :: eta real(kind=wp), intent(in), dimension(N,2) :: xy real(kind=wp), intent(in), dimension(N,N) :: alpha Return Value real(kind=wp),\n  dimension(2,2)","title":"getJacobian – learn_dg","loc":"interface/getjacobian.html"},{"tags":"","text":"public subroutine pascal_1D_line_c(N, x, row) bind(c, name=\"0\") Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in), value :: N real(kind=c_double), intent(in), value :: x real(kind=c_double), intent(out) :: row (N+1) Source Code pascal_1D_line_c Source Code module subroutine pascal_1D_line_c ( N , x , row ) bind ( c , name = 'pascal_1D_line_c' ) integer ( c_int ), intent ( in ), value :: N real ( c_double ), intent ( in ), value :: x real ( c_double ), intent ( out ) :: row ( N + 1 ) row = pascal_row ( N , x ) return end subroutine pascal_1D_line_c","title":"pascal_1D_line_c – learn_dg","loc":"proc/pascal_1d_line_c.html"},{"tags":"","text":"private subroutine pascal_single_row_c(N, x, y, row) bind(c, name=\"0\") Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in), value :: N real(kind=c_double), intent(in), value :: x real(kind=c_double), intent(in), value :: y real(kind=c_double), intent(out) :: row (N+1) Source Code pascal_single_row_c Source Code module subroutine pascal_single_row_c ( N , x , y , row ) bind ( c , name = 'pascal_single_row_c' ) integer ( c_int ), intent ( in ), value :: N real ( c_double ), intent ( in ), value :: x real ( c_double ), intent ( in ), value :: y real ( c_double ), intent ( out ) :: row ( N + 1 ) row = pascal_single_row ( N , x , y ) return end subroutine pascal_single_row_c","title":"pascal_single_row_c – learn_dg","loc":"proc/pascal_single_row_c.html"},{"tags":"","text":"public subroutine pascal_2D_quad_c(N, x, y, row) bind(c, name=\"0\") Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in), value :: N real(kind=c_double), intent(in), value :: x real(kind=c_double), intent(in), value :: y real(kind=c_double), intent(out) :: row ((N+1)**2) Source Code pascal_2D_quad_c Source Code module subroutine pascal_2D_quad_c ( N , x , y , row ) bind ( c , name = 'pascal_2D_quad_c' ) integer ( c_int ), intent ( in ), value :: N real ( c_double ), intent ( in ), value :: x real ( c_double ), intent ( in ), value :: y real ( c_double ), intent ( out ) :: row (( N + 1 ) ** 2 ) row = pascal_row ( N , x , y ) return end subroutine pascal_2D_quad_c","title":"pascal_2D_quad_c – learn_dg","loc":"proc/pascal_2d_quad_c.html"},{"tags":"","text":"pure function pascal_row_2D(N, x, y) result(row) Generates a row of Pascal's triangle in 2D Pascal's triangle in 2D looks like this:\n    [1] \n    [x,~ y] \n    [x&#94;2,~ x y,~ y&#94;2] \n    [x&#94;3,~ x&#94;2y,~ xy&#94;2,~ y&#94;3] \n    [x&#94;4,~ x&#94;3y,~ x&#94;2y&#94;2,~ xy&#94;3, y&#94;4] \n    \\vdots \n    [x&#94;N,~ x&#94;{N-1}y,~ \\cdots,~ xy&#94;{N-1},~ y&#94;N]  The rows are zero-indexed, therefore, the third row (index=2)\n would be x&#94;2, x\\cdot y, y&#94;2 Arguments Type Intent Optional Attributes Name integer, intent(in) :: N Row number of pascal's 2D triange (0-indexed) real(kind=wp), intent(in) :: x X-value used in triange real(kind=wp), intent(in) :: y Y-Value used in triange Return Value real(kind=wp),\n  dimension(N+1) Output row of triange Source Code pascal_row_2D Source Code pure function pascal_row_2D ( N , x , y ) result ( row ) !* ! Generates a row of Pascal's triangle in 2D ! ! Pascal's triangle in 2D looks like this: !    [1]  !    [x,~ y]  !    [x&#94;2,~ x y,~ y&#94;2]  !    [x&#94;3,~ x&#94;2y,~ xy&#94;2,~ y&#94;3]  !    [x&#94;4,~ x&#94;3y,~ x&#94;2y&#94;2,~ xy&#94;3, y&#94;4]  !    \\vdots  !    [x&#94;N,~ x&#94;{N-1}y,~ \\cdots,~ xy&#94;{N-1},~ y&#94;N]  ! ! The rows are zero-indexed, therefore, the third row (index=2) ! would be x&#94;2, x\\cdot y, y&#94;2 integer , intent ( in ) :: N !! Row number of pascal's 2D triange (0-indexed) real ( wp ), intent ( in ) :: x !! X-value used in triange real ( wp ), intent ( in ) :: y !! Y-Value used in triange real ( wp ), dimension ( N + 1 ) :: row !! Output row of triange integer :: ii ! Produces the elements of an array: [x&#94;N, x&#94;(N-1)*y, x&#94;(N-2)*y&#94;2, ..., y&#94;N] row = [( x ** ( N - ii ) * y ** ( ii ), ii = 0 , N )] return end function pascal_row_2D","title":"pascal_row_2D – learn_dg","loc":"proc/pascal_row_2d.html"},{"tags":"","text":"public pure function eye(N) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N Return Value real(kind=wp),\n  dimension(N,N) Source Code eye Source Code pure function eye ( N ) ! Generates an identity matrix of size (N,N) integer , intent ( in ) :: N real ( wp ), dimension ( N , N ) :: eye integer :: ii eye = 0._wp forall ( ii = 1 : N ) eye ( ii , ii ) = 1._wp return end function eye","title":"eye – learn_dg","loc":"proc/eye.html"},{"tags":"","text":"public pure function inv2(J) result(invJ) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(2,2) :: J Return Value real(kind=wp),\n  dimension(2,2) Source Code inv2 Source Code pure function inv2 ( J ) result ( invJ ) ! Computes the inverse of a 2x2 matrix real ( wp ), dimension ( 2 , 2 ), intent ( in ) :: J real ( wp ), dimension ( 2 , 2 ) :: invJ invJ = reshape ( [ J ( 2 , 2 ), - J ( 2 , 1 ), - J ( 1 , 2 ), J ( 1 , 1 )], [ 2 , 2 ] ) invJ = invJ / det2 ( J ) return end function inv2","title":"inv2 – learn_dg","loc":"proc/inv2.html"},{"tags":"","text":"public pure function det2(A) result(det) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(2,2) :: A Return Value real(kind=wp) Source Code det2 Source Code pure function det2 ( A ) result ( det ) ! Computes the determinant of a 2x2 matrix real ( wp ), dimension ( 2 , 2 ), intent ( in ) :: A real ( wp ) :: det det = A ( 1 , 1 ) * A ( 2 , 2 ) - A ( 1 , 2 ) * A ( 2 , 1 ) return end function det2","title":"det2 – learn_dg","loc":"proc/det2.html"},{"tags":"","text":"public subroutine linsolve_quick(n, a, nrhs, b, x) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=wp), intent(in), dimension(n, n) :: a integer, intent(in) :: nrhs real(kind=wp), intent(in), dimension(n, nrhs) :: b real(kind=wp), intent(out), dimension(n, nrhs) :: x Source Code linsolve_quick Source Code subroutine linsolve_quick ( n , a , nrhs , b , x ) ! Quick wrapper around linsolve integer , intent ( in ) :: n , nrhs real ( wp ), intent ( in ), dimension ( n , n ) :: a real ( wp ), intent ( in ), dimension ( n , nrhs ) :: b real ( wp ), intent ( out ), dimension ( n , nrhs ) :: x integer , dimension ( n ) :: P real ( wp ), dimension ( n , n ) :: LU call linsolve ( n , a , nrhs , b , x , LU , P , . False .) return end subroutine linsolve_quick","title":"linsolve_quick – learn_dg","loc":"proc/linsolve_quick.html"},{"tags":"","text":"public subroutine linsolve(n, a, nrhs, b, x, LU, P, toggle) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=wp), intent(in), dimension(n, n) :: a integer, intent(in) :: nrhs real(kind=wp), intent(in), dimension(n, nrhs) :: b real(kind=wp), intent(out), dimension(n, nrhs) :: x real(kind=wp), intent(inout), dimension(n, n) :: LU integer, intent(inout), dimension(n) :: P logical, intent(in) :: toggle Source Code linsolve Source Code subroutine linsolve ( n , a , nrhs , b , x , LU , P , toggle ) ! Linsolve is a wrapper of dgesv, the main linear solver routine for ! general dense matrices in LAPACK. This routine splits dgesv into ! its two primary components: ! !       dgetrf - Decomposes A into P*L*U !       dgetrs - Uses P*L*U to solve for x (Ax=b => (P*L*U)x=b) ! ! Splitting these two up like this allows you to save the decomposed ! version of 'A' so that you don't have to do it again. If 'toggle' ! is equal to true, then the decomposition has already occured and ! LU can be trusted - OK to skip dgetrf ! Dummy variables integer , intent ( in ) :: n , nrhs integer , intent ( inout ), dimension ( n ) :: P real ( wp ), intent ( in ), dimension ( n , n ) :: a real ( wp ), intent ( in ), dimension ( n , nrhs ) :: b real ( wp ), intent ( out ), dimension ( n , nrhs ) :: x real ( wp ), intent ( inout ), dimension ( n , n ) :: LU logical , intent ( in ) :: toggle ! Local variables integer :: info integer , dimension ( n ) :: my_P real ( wp ), dimension ( n , n ) :: my_a real ( wp ), dimension ( n , nrhs ) :: my_b my_a = a my_b = b if ( . not . toggle ) then call dgetrf ( n , n , my_a , n , my_P , info ) if ( info /= 0 ) then write ( * , '(a)' ) ' ' write ( * , '(a)' ) 'DGETRF' write ( * , '(a,i8)' ) '  Factorization failed, INFO = ' , info stop endif LU = my_a P = my_P endif call dgetrs ( 'No transpose' , n , nrhs , LU , n , P , my_b , n , info ) if ( info /= 0 ) then write ( * , '(a)' ) ' ' write ( * , '(a)' ) 'DGETRS' write ( * , '(a,i8)' ) '  Back substitution failed, INFO = ' , info stop endif x = my_b return end subroutine linsolve","title":"linsolve – learn_dg","loc":"proc/linsolve.html"},{"tags":"","text":"public subroutine r8mat_print(m, n, a, title) R8MAT_PRINT prints an R8MAT. Discussion: An R8MAT is a two dimensional matrix of double precision real values. Licensing: This code is distributed under the GNU LGPL license. Modified: 12 September 2004 Author: John Burkardt Parameters: Input, integer M, the number of rows in A.\n\nInput, integer N, the number of columns in A.\n\nInput, real ( kind = 8 ) A(M,N), the matrix.\n\nInput, character ( len = * ) TITLE, a title to be printed. Arguments Type Intent Optional Attributes Name integer(kind=4) :: m integer(kind=4) :: n real(kind=8) :: a (m,n) character(len=*) :: title Source Code r8mat_print Source Code subroutine r8mat_print ( m , n , a , title ) ! ************************************************************************** ! !* R8MAT_PRINT prints an R8MAT. ! !  Discussion: ! !    An R8MAT is a two dimensional matrix of double precision real values. ! !  Licensing: ! !    This code is distributed under the GNU LGPL license. ! !  Modified: ! !    12 September 2004 ! !  Author: ! !    John Burkardt ! !  Parameters: ! !    Input, integer M, the number of rows in A. ! !    Input, integer N, the number of columns in A. ! !    Input, real ( kind = 8 ) A(M,N), the matrix. ! !    Input, character ( len = * ) TITLE, a title to be printed. implicit none integer ( kind = 4 ) m integer ( kind = 4 ) n real ( kind = 8 ) a ( m , n ) character ( len = * ) title call r8mat_print_some ( m , n , a , 1 , 1 , m , n , title ) return end subroutine r8mat_print","title":"r8mat_print – learn_dg","loc":"proc/r8mat_print.html"},{"tags":"","text":"private subroutine r8mat_print_some(m, n, a, ilo, jlo, ihi, jhi, title) R8MAT_PRINT_SOME prints some of an R8MAT. Discussion: An R8MAT is a two dimensional matrix of double precision real values. Licensing: This code is distributed under the GNU LGPL license. Modified: 26 March 2005 Author: John Burkardt Parameters: Input, integer M, N, the number of rows and columns.\n\nInput, real ( kind = 8 ) A(M,N), an M by N matrix to be printed.\n\nInput, integer ILO, JLO, the first row and column to print.\n\nInput, integer IHI, JHI, the last row and column to print.\n\nInput, character ( len = * ) TITLE, an optional title. Arguments Type Intent Optional Attributes Name integer(kind=4) :: m integer(kind=4) :: n real(kind=8) :: a (m,n) integer(kind=4) :: ilo integer(kind=4) :: jlo integer(kind=4) :: ihi integer(kind=4) :: jhi character(len=*) :: title Source Code r8mat_print_some Source Code subroutine r8mat_print_some ( m , n , a , ilo , jlo , ihi , jhi , title ) ! ************************************************************************** ! !* R8MAT_PRINT_SOME prints some of an R8MAT. ! !  Discussion: ! !    An R8MAT is a two dimensional matrix of double precision real values. ! !  Licensing: ! !    This code is distributed under the GNU LGPL license. ! !  Modified: ! !    26 March 2005 ! !  Author: ! !    John Burkardt ! !  Parameters: ! !    Input, integer M, N, the number of rows and columns. ! !    Input, real ( kind = 8 ) A(M,N), an M by N matrix to be printed. ! !    Input, integer ILO, JLO, the first row and column to print. ! !    Input, integer IHI, JHI, the last row and column to print. ! !    Input, character ( len = * ) TITLE, an optional title. implicit none integer ( kind = 4 ), parameter :: incx = 5 integer ( kind = 4 ) m integer ( kind = 4 ) n real ( kind = 8 ) a ( m , n ) character ( len = 14 ) ctemp ( incx ) integer ( kind = 4 ) i integer ( kind = 4 ) i2hi integer ( kind = 4 ) i2lo integer ( kind = 4 ) ihi integer ( kind = 4 ) ilo integer ( kind = 4 ) inc integer ( kind = 4 ) j integer ( kind = 4 ) j2 integer ( kind = 4 ) j2hi integer ( kind = 4 ) j2lo integer ( kind = 4 ) jhi integer ( kind = 4 ) jlo character ( len = * ) title if ( 0 < len_trim ( title ) ) then write ( * , '(a)' ) ' ' write ( * , '(a)' ) trim ( title ) endif do j2lo = max ( jlo , 1 ), min ( jhi , n ), incx j2hi = j2lo + incx - 1 j2hi = min ( j2hi , n ) j2hi = min ( j2hi , jhi ) inc = j2hi + 1 - j2lo write ( * , '(a)' ) ' ' do j = j2lo , j2hi j2 = j + 1 - j2lo write ( ctemp ( j2 ), '(i8,6x)' ) j enddo write ( * , '(''  Col   '',5a14)' ) ctemp ( 1 : inc ) write ( * , '(a)' ) '  Row' write ( * , '(a)' ) ' ' i2lo = max ( ilo , 1 ) i2hi = min ( ihi , m ) do i = i2lo , i2hi do j2 = 1 , inc j = j2lo - 1 + j2 if ( a ( i , j ) == real ( int ( a ( i , j ) ), kind = 8 ) ) then write ( ctemp ( j2 ), '(f8.0,6x)' ) a ( i , j ) else write ( ctemp ( j2 ), '(g14.6)' ) a ( i , j ) endif enddo write ( * , '(i5,1x,5a14)' ) i , ( ctemp ( j ), j = 1 , inc ) enddo enddo write ( * , '(a)' ) ' ' return end subroutine r8mat_print_some","title":"r8mat_print_some – learn_dg","loc":"proc/r8mat_print_some.html"},{"tags":"","text":"function assembleElementalMatrix1D(N, d1, d2, xy) result(Ie) Routine to calculate the elemental mass/stiffness matrix\n   based on the derivatives of the basis functions. Currently only zero-th and first order derivatives are\n   supported. Second order derivatives need to be reduced to\n   first order derivatives in the problem formulation using\n   Green's Theorem (i.e. derivation by parts) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N Number of nodes in basis function integer, intent(in) :: d1 Derivative of the first basis function integer, intent(in) :: d2 Derivative of the second basis function real(kind=wp), intent(in), dimension(N) :: xy Coordinates of the 1D line element Return Value real(kind=wp),\n  dimension(N,N) Output elemental matrix Source Code assembleElementalMatrix1D Source Code module function assembleElementalMatrix1D ( N , d1 , d2 , xy ) result ( Ie ) !*  Routine to calculate the elemental mass/stiffness matrix !   based on the derivatives of the basis functions. ! !   Currently only zero-th and first order derivatives are !   supported. Second order derivatives need to be reduced to !   first order derivatives in the problem formulation using !   Green's Theorem (i.e. derivation by parts) integer , intent ( in ) :: N !! Number of nodes in basis function integer , intent ( in ) :: d1 !! Derivative of the first basis function integer , intent ( in ) :: d2 !! Derivative of the second basis function real ( wp ), intent ( in ), dimension ( N ) :: xy !! Coordinates of the 1D line element real ( wp ), dimension ( N , N ) :: Ie !! Output elemental matrix integer :: ii , jj , order Ie = 0._wp order = N - 1 do ii = 1 , N Ie ( ii , :) = [( integrate_basis_1d_Ie ( order , ii , jj , d1 , d2 , xy ), jj = 1 , order + 1 )] enddo return end function assembleElementalMatrix1D","title":"assembleElementalMatrix1D – learn_dg","loc":"proc/assembleelementalmatrix1d.html"},{"tags":"","text":"subroutine initialize_global_mats(num_nodes, GlobalA, GlobalB, GlobalX) This routine initalizes the global stiffness matrix, global\n   rhs vector, and global solution vector based on the number of\n   nodes in the system This is a Another                               bullet point This might be a number 2. Also a number? Some  \\LaTeX :  \\frac{\\partial u}{\\partial t} = 0  Arguments Type Intent Optional Attributes Name integer, intent(in) :: num_nodes The number of nodes in the system real(kind=wp), intent(out), dimension(:,:), allocatable :: GlobalA Global mass matrix real(kind=wp), intent(out), dimension(:), allocatable :: GlobalB Global RHS Vector real(kind=wp), intent(out), dimension(:), allocatable :: GlobalX Global solution vector Source Code initialize_global_mats Source Code module subroutine initialize_global_mats ( num_nodes , & GlobalA , & GlobalB , & GlobalX ) !*  This routine initalizes the global stiffness matrix, global !   rhs vector, and global solution vector based on the number of !   nodes in the system ! ! * This is a Another                               bullet point ! ! 1. This might be a number 2. Also a number? ! ! Some  \\LaTeX :  \\frac{\\partial u}{\\partial t} = 0  integer , intent ( in ) :: num_nodes !! The number of nodes in the system real ( wp ), intent ( out ), dimension (:), allocatable :: GlobalB !! Global RHS Vector real ( wp ), intent ( out ), dimension (:), allocatable :: GlobalX !! Global solution vector real ( wp ), intent ( out ), dimension (:,:), allocatable :: GlobalA !! Global mass matrix allocate ( GlobalA ( num_nodes , num_nodes )) allocate ( GlobalB ( num_nodes )) allocate ( GlobalX ( num_nodes )) ! Intial Conditions GlobalA = 0._wp GlobalX = 0._wp GlobalB = 0._wp return end subroutine initialize_global_mats","title":"initialize_global_mats – learn_dg","loc":"proc/initialize_global_mats.html"},{"tags":"","text":"function assembleElementalMatrix2D(N, d1, d2, xy) result(Ie) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N integer, intent(in) :: d1 integer, intent(in) :: d2 real(kind=wp), intent(in), dimension(N,2) :: xy Return Value real(kind=wp),\n  dimension(N,N) Source Code assembleElementalMatrix2D Source Code module function assembleElementalMatrix2D ( N , d1 , d2 , xy ) result ( Ie ) ! Dummy variables integer , intent ( in ) :: N , d1 , d2 real ( wp ), dimension ( N , 2 ), intent ( in ) :: xy real ( wp ), dimension ( N , N ) :: Ie ! Local variables integer :: node1 , node2 real ( wp ), dimension ( N , N ), target :: alpha ! Get the coefficients of the basis functions (alpha) ! Supported 2D basis functions: !   Bi-linear quadrilaterals (N=4) !   Bi-quadratic quadrilaterals (N=9) !   Bi-cubic quadrilaterals (N=16) !   Bi-quartic quadrilaterals (N=25) alpha = getAlpha ( N ) Ie = 0._wp outer : do node1 = 1 , N inner : do node2 = 1 , N ! fun is now implicitly defined using the following: node1, node2, d1, and d2 Ie ( node1 , node2 ) = Ie ( node1 , node2 ) + integrate ( fun , [ - 1._wp , 1._wp ], [ - 1._wp , 1._wp ]) enddo inner enddo outer return contains function fun ( xi , eta ) result ( out ) ! Dummy variables real ( wp ), dimension (:,:), intent ( in ) :: xi , eta real ( wp ), dimension (:,:), allocatable :: out ! Local variables integer :: ii , jj , num_pts real ( wp ), parameter :: eps = epsilon ( 0 e0 ) real ( wp ) :: fun1 , fun2 real ( wp ), dimension ( 2 ) :: dfun1 , dfun2 real ( wp ) :: detJ real ( wp ), dimension ( 2 , 2 ) :: J , invJ real ( wp ), dimension (:), pointer :: alpha_row ! Initialize function output. Actual number of pts is num_pts*num_pts, ! because the meshgrid goes in both x and y directions. Only need one. num_pts = size ( xi , 1 ) allocate ( out ( num_pts , num_pts )) out = 0._wp outer : do ii = 1 , num_pts inner : do jj = 1 , num_pts ! Calculate Jacobian, inverse Jacobian, and determinant of finite ! element at (xi,eta) J = getJacobian ( N , xi ( ii , jj ), eta ( ii , jj ), xy , alpha ) invJ = inv2 ( J ) detJ = det2 ( J ) alpha_row => alpha (:, node1 ) ! If fun1 is just N_i, use dot_product to determine N_i if ( d1 == 0 ) then fun1 = dot_product ( alpha_row , getArow ( N , xi ( ii , jj ), eta ( ii , jj ))) else ! If fun1 contains a derivative, need to calc N_i,xi and N_i,eta dfun1 ( 1 ) = ( & dot_product ( alpha_row , getArow ( N , xi ( ii , jj ) + eps , eta ( ii , jj ))) - & dot_product ( alpha_row , getArow ( N , xi ( ii , jj ) - eps , eta ( ii , jj ))) & ) / ( 2._wp * eps ) dfun1 ( 2 ) = ( & dot_product ( alpha_row , getArow ( N , xi ( ii , jj ), eta ( ii , jj ) + eps )) - & dot_product ( alpha_row , getArow ( N , xi ( ii , jj ), eta ( ii , jj ) - eps )) & ) / ( 2._wp * eps ) ! N_i,x = dxi/dx * N_i,xi + deta/dx * N_i,eta fun1 = dot_product ( invJ ( d1 ,:), dfun1 ) endif alpha_row => alpha (:, node2 ) ! If fun2 is just N_i, use dot_product to determine N_i if ( d2 == 0 ) then fun2 = dot_product ( alpha_row , getArow ( N , xi ( ii , jj ), eta ( ii , jj ))) else ! If fun2 contains a derivative, need to calc N_i,xi and N_i,eta dfun2 ( 1 ) = ( & dot_product ( alpha_row , getArow ( N , xi ( ii , jj ) + eps , eta ( ii , jj ))) - & dot_product ( alpha_row , getArow ( N , xi ( ii , jj ) - eps , eta ( ii , jj ))) & ) / ( 2._wp * eps ) dfun2 ( 2 ) = ( & dot_product ( alpha_row , getArow ( N , xi ( ii , jj ), eta ( ii , jj ) + eps )) - & dot_product ( alpha_row , getArow ( N , xi ( ii , jj ), eta ( ii , jj ) - eps )) & ) / ( 2._wp * eps ) ! N_i,y = dxi/dy * N_i,xi + deta/dy * N_i,eta fun2 = dot_product ( invJ ( d2 ,:), dfun2 ) endif out ( ii , jj ) = fun1 * fun2 * detJ enddo inner enddo outer return end function fun end function assembleElementalMatrix2D","title":"assembleElementalMatrix2D – learn_dg","loc":"proc/assembleelementalmatrix2d.html"},{"tags":"","text":"subroutine assemble2D(points, cells, diff, vel, GlobalA) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:,:) :: points integer, intent(in), dimension(:,:) :: cells real(kind=wp), intent(in) :: diff real(kind=wp), intent(in), dimension(2) :: vel real(kind=wp), intent(out), dimension(:,:) :: GlobalA Source Code assemble2D Source Code module subroutine assemble2D ( points , cells , diff , vel , GlobalA ) integer , intent ( in ), dimension (:,:) :: cells real ( wp ), intent ( in ) :: diff real ( wp ), intent ( in ), dimension ( 2 ) :: vel real ( wp ), intent ( in ), dimension (:,:) :: points real ( wp ), intent ( out ), dimension (:,:) :: GlobalA integer :: ii , jj integer :: num_cells , num_pts real ( wp ), parameter :: eps = epsilon ( 0 e0 ) real ( wp ), dimension (:,:), allocatable :: Ie , xy GlobalA = 0._wp num_cells = size ( cells , 1 ) num_pts = size ( cells , 2 ) allocate ( xy ( num_pts , 2 ), Ie ( num_pts , num_pts )) ! NOTE: This is assuming that all elements have the same number of points !$OMP PARALLEL DEFAULT(SHARED) PRIVATE(ii, xy, Ie) REDUCTION(+:GlobalA) !$OMP DO outer : do ii = 1 , num_cells xy = points ( cells ( ii ,:), :) ! *** Elemental matrix for diffusion in X and Y *** Ie = assembleElementalMatrix ( num_pts , 1 , 1 , xy ) + & & assembleElementalMatrix ( num_pts , 2 , 2 , xy ) GlobalA ( cells ( ii ,:), cells ( ii ,:)) = & & GlobalA ( cells ( ii ,:), cells ( ii ,:)) - diff * Ie ! Add elemental matrix for velcity in X (1) and Y (2) to GlobalA adv : do jj = 1 , 2 if ( abs ( vel ( jj )) . gt . eps ) then Ie = assembleElementalMatrix ( num_pts , 0 , jj , xy ) GlobalA ( cells ( ii ,:), cells ( ii ,:)) = & & GlobalA ( cells ( ii ,:), cells ( ii ,:)) - vel ( jj ) * Ie endif enddo adv enddo outer !$OMP END DO !$OMP END PARALLEL deallocate ( Ie , xy ) return end subroutine assemble2D","title":"assemble2D – learn_dg","loc":"proc/assemble2d.html"},{"tags":"","text":"module subroutine gaussquad(N, x, w) Interface → Arguments Type Intent Optional Attributes Name integer, intent(in) :: N real(kind=wp), intent(out), dimension(N) :: x real(kind=wp), intent(out), dimension(N) :: w Source Code gaussquad Source Code module subroutine gaussquad ( N , x , w ) integer , intent ( in ) :: N real ( wp ), intent ( out ), dimension ( N ) :: x , w select case ( N ) case ( 1 ) x = [ 0._wp ] w = [ 2._wp ] case ( 2 ) x = [ - 0.5773502691896257_wp , & 0.5773502691896257_wp ] w = [ 1._wp , & 1._wp ] case ( 3 ) x = [ - 0.7745966692414834_wp , & 0._wp , & 0.7745966692414834_wp ] w = [ 0.5555555555555556_wp , & 0.8888888888888888_wp , & 0.5555555555555556_wp ] case ( 4 ) x = [ - 0.8611363115940526_wp , & - 0.3399810435848563_wp , & 0.3399810435848563_wp , & 0.8611363115940526_wp ] w = [ 0.3478548451374538_wp , & 0.6521451548625461_wp , & 0.6521451548625461_wp , & 0.3478548451374538_wp ] case ( 5 ) x = [ - 0.9061798459386640_wp , & - 0.5384693101056831_wp , & 0._wp , & 0.5384693101056831_wp , & 0.9061798459386640_wp ] w = [ 0.2369268850561891_wp , & 0.4786286704993665_wp , & 0.5688888888888889_wp , & 0.4786286704993665_wp , & 0.2369268850561891_wp ] case default ! call lgwt(-1._wp, 1._wp, N, x, w) ! call cgwt(N, x, w) call gaussquad_rosetta ( N , x , w ) end select return end subroutine gaussquad","title":"gaussquad – learn_dg","loc":"proc/gaussquad.html"},{"tags":"","text":"pure function getArow1D(N, xi) result(row) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N real(kind=wp), intent(in) :: xi Return Value real(kind=wp),\n  dimension(N) Source Code getArow1D Source Code pure module function getArow1D ( N , xi ) result ( row ) integer , intent ( in ) :: N real ( wp ), intent ( in ) :: xi real ( wp ), dimension ( N ) :: row row = pascal_row ( N - 1 , xi ) return end function getArow1D","title":"getArow1D – learn_dg","loc":"proc/getarow1d.html"},{"tags":"","text":"function getx(N) result(x) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N Return Value real(kind=wp),\n  dimension(N) Source Code getx Source Code module function getx ( N ) result ( x ) integer , intent ( in ) :: N real ( wp ), dimension ( N ) :: x call linspace ( - 1.d0 , 1.d0 , x ) ! Gmsh orders all their lines as endpoint1, endpoint2, internal... ! Therefore, need to reorder if numpts is more than 2 if ( N > 2 ) x = [ x ( 1 ), x ( N ), x ( 2 : N - 1 )] return end function getx","title":"getx – learn_dg","loc":"proc/getx.html"},{"tags":"","text":"function getAlpha1D(N) result(alpha) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N Return Value real(kind=wp),\n  dimension(N,N) Source Code getAlpha1D Source Code module function getAlpha1D ( N ) result ( alpha ) integer , intent ( in ) :: N real ( wp ), dimension ( N , N ) :: alpha real ( wp ), dimension ( N , N ) :: A , B A = getA ( N ) B = eye ( N ) call linsolve_quick ( N , A , N , B , alpha ) return contains function getA ( N ) result ( A ) integer , intent ( in ) :: N real ( wp ), dimension ( N , N ) :: A integer :: ii real ( wp ), dimension ( N ) :: x x = getx ( N ) do ii = 1 , N A ( ii ,:) = getArow1D ( N , x ( ii )) enddo return end function getA end function getAlpha1D","title":"getAlpha1D – learn_dg","loc":"proc/getalpha1d.html"},{"tags":"","text":"pure function pascal_1D_line(N, x) result(row) Generates the elements of an array associated with a univarate\n Lagrange polynomial. Arguments Type Intent Optional Attributes Name integer, intent(in) :: N real(kind=wp), intent(in) :: x Return Value real(kind=wp),\n  dimension(N+1) Source Code pascal_1D_line Source Code pure module function pascal_1D_line ( N , x ) result ( row ) !* ! Generates the elements of an array associated with a univarate ! Lagrange polynomial. integer , intent ( in ) :: N real ( wp ), intent ( in ) :: x real ( wp ), dimension ( N + 1 ) :: row integer :: ii row = [( x ** ( ii - 1 ), ii = 1 , N + 1 )] return end function pascal_1D_line","title":"pascal_1D_line – learn_dg","loc":"proc/pascal_1d_line.html"},{"tags":"","text":"pure function basis_1D(x, alpha, dx) result(y) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: x real(kind=wp), intent(in), dimension(:) :: alpha integer, intent(in) :: dx Return Value real(kind=wp),\n  dimension(:),allocatable Source Code basis_1D Source Code pure module function basis_1D ( x , alpha , dx ) result ( y ) ! Input/output variables integer , intent ( in ) :: dx real ( wp ), intent ( in ), dimension (:) :: x real ( wp ), intent ( in ), dimension (:) :: alpha real ( wp ), dimension (:), allocatable :: y , yx ! Local variables integer :: ii , N allocate ( y , mold = x ) allocate ( yx , mold = x ) N = size ( alpha ) y = 0._wp do ii = 1 + dx , N yx = dble (( ii - 1 ) ** dx ) * alpha ( ii ) * x ** dble ( ii - 1 - dx ) y = y + yx enddo return end function basis_1D","title":"basis_1D – learn_dg","loc":"proc/basis_1d.html"},{"tags":"","text":"pure function getXY_2D(N) result(xy) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N Return Value real(kind=wp),\n  dimension(N,2) Source Code getXY_2D Source Code pure module function getXY_2D ( N ) result ( xy ) integer , intent ( in ) :: N real ( wp ), dimension ( N , 2 ) :: xy ! Keep a copy of 0, 1, and 1/3 handy so no need to retype it all the time real ( wp ), parameter :: zero = 0._wp real ( wp ), parameter :: one = 1._wp real ( wp ), parameter :: half = 1._wp / 2._wp real ( wp ), parameter :: third = 1._wp / 3._wp select case ( N ) case ( 4 ) xy ( 1 ,:) = [ - one , - one ] ! Node 1 xy ( 2 ,:) = [ one , - one ] ! Node 2 xy ( 3 ,:) = [ one , one ] ! Node 3 xy ( 4 ,:) = [ - one , one ] ! Node 4 case ( 9 ) xy ( 1 ,:) = [ - one , - one ] ! Node 1 xy ( 2 ,:) = [ one , - one ] ! Node 2 xy ( 3 ,:) = [ one , one ] ! Node 3 xy ( 4 ,:) = [ - one , one ] ! Node 4 xy ( 5 ,:) = [ zero , - one ] ! Node 5 xy ( 6 ,:) = [ one , zero ] ! Node 6 xy ( 7 ,:) = [ zero , one ] ! Node 7 xy ( 8 ,:) = [ - one , zero ] ! Node 8 xy ( 9 ,:) = [ zero , zero ] ! Node 9 case ( 16 ) xy ( 1 ,:) = [ - one , - one ] ! Node 1 xy ( 2 ,:) = [ one , - one ] ! Node 2 xy ( 3 ,:) = [ one , one ] ! Node 3 xy ( 4 ,:) = [ - one , one ] ! Node 4 xy ( 5 ,:) = [ - third , - one ] ! Node 5 xy ( 6 ,:) = [ third , - one ] ! Node 6 xy ( 7 ,:) = [ one , - third ] ! Node 7 xy ( 8 ,:) = [ one , third ] ! Node 8 xy ( 9 ,:) = [ third , one ] ! Node 9 xy ( 10 ,:) = [ - third , one ] ! Node 10 xy ( 11 ,:) = [ - one , third ] ! Node 11 xy ( 12 ,:) = [ - one , - third ] ! Node 12 xy ( 13 ,:) = [ - third , - third ] ! Node 13 xy ( 14 ,:) = [ third , - third ] ! Node 14 xy ( 15 ,:) = [ third , third ] ! Node 15 xy ( 16 ,:) = [ - third , third ] ! Node 16 case ( 25 ) xy ( 1 ,:) = [ - one , - one ] ! Node 1 xy ( 2 ,:) = [ one , - one ] ! Node 2 xy ( 3 ,:) = [ one , one ] ! Node 3 xy ( 4 ,:) = [ - one , one ] ! Node 4 xy ( 5 ,:) = [ - half , - one ] ! Node 5 xy ( 6 ,:) = [ zero , - one ] ! Node 6 xy ( 7 ,:) = [ half , - one ] ! Node 7 xy ( 8 ,:) = [ one , - half ] ! Node 8 xy ( 9 ,:) = [ one , zero ] ! Node 9 xy ( 10 ,:) = [ one , half ] ! Node 10 xy ( 11 ,:) = [ half , one ] ! Node 11 xy ( 12 ,:) = [ zero , one ] ! Node 12 xy ( 13 ,:) = [ - half , one ] ! Node 13 xy ( 14 ,:) = [ - one , half ] ! Node 14 xy ( 15 ,:) = [ - one , zero ] ! Node 15 xy ( 16 ,:) = [ - one , - half ] ! Node 16 xy ( 17 ,:) = [ - half , - half ] ! Node 17 xy ( 18 ,:) = [ half , - half ] ! Node 18 xy ( 19 ,:) = [ half , half ] ! Node 19 xy ( 20 ,:) = [ - half , half ] ! Node 20 xy ( 21 ,:) = [ zero , - half ] ! Node 21 xy ( 22 ,:) = [ half , zero ] ! Node 22 xy ( 23 ,:) = [ zero , half ] ! Node 23 xy ( 24 ,:) = [ - half , zero ] ! Node 24 xy ( 25 ,:) = [ zero , zero ] ! Node 25 case default ! TODO: I need to change this to a subroutine and ! include an output error variable - Pure can't print output xy = 0.d0 ! print*, 'getXY_2D called with N = ', N ! print*, 'That`s not implemented' end select return end function getXY_2D","title":"getXY_2D – learn_dg","loc":"proc/getxy_2d.html"},{"tags":"","text":"pure function getArow2D(N, xi, eta) result(row) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N real(kind=wp), intent(in) :: xi real(kind=wp), intent(in) :: eta Return Value real(kind=wp),\n  dimension(N) Source Code getArow2D Source Code pure module function getArow2D ( N , xi , eta ) result ( row ) integer , intent ( in ) :: N real ( wp ), intent ( in ) :: xi , eta real ( wp ), dimension ( N ) :: row select case ( N ) case ( 4 ) row = pascal_row ( 1 , xi , eta ) case ( 9 ) row = pascal_row ( 2 , xi , eta ) case ( 16 ) row = pascal_row ( 3 , xi , eta ) case ( 25 ) row = pascal_row ( 4 , xi , eta ) case default row = 0.d0 ! print*, 'getArow2D called with N = ', N ! print*, 'That N is not yet implemented' end select return end function getArow2D","title":"getArow2D – learn_dg","loc":"proc/getarow2d.html"},{"tags":"","text":"function getAlpha2D(N) result(alpha) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N Return Value real(kind=wp),\n  dimension(N,N) Source Code getAlpha2D Source Code module function getAlpha2D ( N ) result ( alpha ) integer , intent ( in ) :: N real ( wp ), dimension ( N , N ) :: alpha integer :: ii real ( wp ), dimension ( N , N ) :: A , B A = getA ( N ) B = eye ( N ) call linsolve_quick ( N , A , N , B , alpha ) return contains function getA ( N ) result ( A ) integer , intent ( in ) :: N real ( wp ), dimension ( N , N ) :: A integer :: ii real ( wp ), dimension ( N , 2 ) :: xy xy = getXY_2D ( N ) do ii = 1 , N A ( ii ,:) = getArow ( N , xy ( ii , 1 ), xy ( ii , 2 )) enddo return end function getA end function getAlpha2D","title":"getAlpha2D – learn_dg","loc":"proc/getalpha2d.html"},{"tags":"","text":"pure function pascal_2D_quad(N, x, y) result(row) Generates an array of points related to a quadrilateral using Pascal's\n triangle in 2D, where rows are 0-indexed Pascal's triangle in 2D looks like this, with points used in bi-quadratic quadrilateral in bold:\n    [\\mathbf{1}] \n    [\\mathbf{x},~ \\mathbf{y}] \n    [\\mathbf{x&#94;2},~ \\mathbf{x y},~ \\mathbf{y&#94;2}] \n    [x&#94;3,~ \\mathbf{x&#94;2y},~ \\mathbf{xy&#94;2},~ y&#94;3] \n    [x&#94;4,~ x&#94;3y,~ \\mathbf{x&#94;2y&#94;2},~ xy&#94;3, y&#94;4] \n    \\vdots \n    [x&#94;N,~ x&#94;{N-1}y,~ \\cdots ~,~ xy&#94;{N-1},~ y&#94;N]  Arguments Type Intent Optional Attributes Name integer, intent(in) :: N Order of the qaudrilateral real(kind=wp), intent(in) :: x X-coordinate of node used in calculation real(kind=wp), intent(in) :: y Y-coordinate of node used in calculation Return Value real(kind=wp),\n  dimension((N+1)**2) Output row Source Code pascal_2D_quad Source Code pure module function pascal_2D_quad ( N , x , y ) result ( row ) !* ! Generates an array of points related to a quadrilateral using Pascal's ! triangle in 2D, where rows are 0-indexed ! ! Pascal's triangle in 2D looks like this, with points used in bi-quadratic quadrilateral in bold: !    [\\mathbf{1}]  !    [\\mathbf{x},~ \\mathbf{y}]  !    [\\mathbf{x&#94;2},~ \\mathbf{x y},~ \\mathbf{y&#94;2}]  !    [x&#94;3,~ \\mathbf{x&#94;2y},~ \\mathbf{xy&#94;2},~ y&#94;3]  !    [x&#94;4,~ x&#94;3y,~ \\mathbf{x&#94;2y&#94;2},~ xy&#94;3, y&#94;4]  !    \\vdots  !    [x&#94;N,~ x&#94;{N-1}y,~ \\cdots ~,~ xy&#94;{N-1},~ y&#94;N]  integer , intent ( in ) :: N !! Order of the qaudrilateral real ( wp ), intent ( in ) :: x !! X-coordinate of node used in calculation real ( wp ), intent ( in ) :: y !! Y-coordinate of node used in calculation real ( wp ), dimension (( N + 1 ) ** 2 ) :: row !! Output row integer :: ii real ( wp ), dimension (:), allocatable :: temp_pre , temp_post row = 0.d0 ! Collects the first N rows of a 2D pascal triangle as function of x and y temp_pre = [( pascal_row_2D ( ii , x , y ), ii = 0 , N )] temp_post = [( pascal_2D_quad_post ( N , ii , x , y ), ii = N + 1 , 2 * N )] row = [ temp_pre , temp_post ] return contains pure function pascal_2D_quad_post ( N_ , ii_ , x_ , y_ ) result ( row_ ) integer , intent ( in ) :: N_ , ii_ real ( wp ), intent ( in ) :: x_ , y_ real ( wp ), dimension ( 2 * N_ - ii_ + 1 ) :: row_ integer :: start , finish real ( wp ), dimension (:), allocatable :: temp temp = pascal_row_2D ( ii_ , x_ , y_ ) start = ii_ - N_ + 1 finish = N_ + 1 row_ = temp ( start : finish ) return end function pascal_2D_quad_post end function pascal_2D_quad","title":"pascal_2D_quad – learn_dg","loc":"proc/pascal_2d_quad.html"},{"tags":"","text":"function getJacobian_2D(N, xi, eta, xy, alpha) result(J) Calculates the Jacobian of a quadrilateral element at a point The Jacobian of an element is defined as:\n  \\boldsymbol{J} = \\boldsymbol{P} \\boldsymbol{X}  Arguments Type Intent Optional Attributes Name integer, intent(in) :: N Number of points in element real(kind=wp), intent(in) :: xi Value of xi coordinate in isoparametric element real(kind=wp), intent(in) :: eta Value of eta coordinate in isoparametric element real(kind=wp), intent(in), dimension(N,2) :: xy Array of x and y coordinates for the element real(kind=wp), intent(in), dimension(N,N) :: alpha Array of coefficients used to define basis functions Return Value real(kind=wp),\n  dimension(2,2) Jacobian of the isoparametric element at (xi,eta) Source Code getJacobian_2D Source Code module function getJacobian_2D ( N , xi , eta , xy , alpha ) result ( J ) !* ! Calculates the Jacobian of a quadrilateral element at a point ! ! The Jacobian of an element is defined as: !  \\boldsymbol{J} = \\boldsymbol{P} \\boldsymbol{X}  ! ! Where: !  \\boldsymbol{P} = \\left[ \\begin{array}{cc} !     \\frac{\\partial H_1}{\\partial \\xi} & \\frac{\\partial H_2}{\\partial \\xi} \\\\ !     \\frac{\\partial H_1}{\\partial \\eta} & \\frac{\\partial H_2}{\\partial \\eta} \\end{array} !       \\cdots !     \\begin{array}{cc} !     \\frac{\\partial H_{N-1}}{\\partial \\xi} & \\frac{\\partial H_{N}}{\\partial \\xi} \\\\ !     \\frac{\\partial H_{N-1}}{\\partial \\eta} & \\frac{\\partial H_{N}}{\\partial \\eta} \\end{array} ! \\right] ! !  \\boldsymbol{X} = \\left[ \\begin{array}{c} !      \\begin{array}{cc} !        x_1 & y_1 \\\\ !        x_2 & y_2 !      \\end{array} \\\\\\\\ !      \\vdots \\\\\\\\ !      \\begin{array}{cc} !        x_{N-1} & y_{N-1} \\\\ !        x_N & y_N !      \\end{array} \\\\ !    \\end{array} \\right] ! ! Thus: ! !  \\boldsymbol{J} =  \\left[ \\begin{array}{cc} !           \\boldsymbol{H}_{\\xi} \\cdot \\boldsymbol{x} & \\boldsymbol{H}_{\\xi} \\cdot \\boldsymbol{y} \\\\ !           \\boldsymbol{H}_{\\eta} \\cdot \\boldsymbol{x} & \\boldsymbol{H}_{\\eta} \\cdot \\boldsymbol{y} \\\\ !         \\end{array} \\right] = \\left[ \\begin{array}{cc} !           \\frac{\\partial \\xi}{\\partial x} & \\frac{\\partial \\xi}{\\partial y} \\\\ !           \\frac{\\partial \\eta}{\\partial x} & \\frac{\\partial \\eta}{\\partial y} \\\\ !         \\end{array} \\right]  ! ! *  \\boldsymbol{H}  : Vector of basis functions ! *  \\boldsymbol{x}  : Vector of X-coordinates for all element nodes ! *  \\boldsymbol{y}  : Vector of Y-coordinates for all element nodes ! ! *  H_i  : Basis function i ! *  x_i  : X-coordinate of node i ! *  y_i  : Y-coordinate of node i integer , intent ( in ) :: N !! Number of points in element real ( wp ), intent ( in ) :: xi !! Value of xi coordinate in isoparametric element real ( wp ), intent ( in ) :: eta !! Value of eta coordinate in isoparametric element real ( wp ), dimension ( N , 2 ), intent ( in ) :: xy !! Array of x and y coordinates for the element real ( wp ), dimension ( N , N ), intent ( in ) :: alpha !! Array of coefficients used to define basis functions real ( wp ), dimension ( 2 , 2 ) :: J !! Jacobian of the isoparametric element at (xi,eta) real ( wp ), parameter :: eps = epsilon ( 0 e0 ) real ( wp ), dimension ( 2 , N ) :: P !! Array of derivatives of each basis function at (xi,eta) real ( wp ), dimension ( N ) :: x !! Row in element coefficient matrix ! P is a matrix containing derivatives of each basis function at (xi,eta) ! P = [dN_1/dxi, dN_2/dxi, dN_3/dxi, ... !      dN_1/deta, dN_2/deta, dN_3/deta, ...] P = 0._wp P ( 1 ,:) = [ getArow ( N , xi + eps , eta ) - & getArow ( N , xi - eps , eta )] P ( 2 ,:) = [ getArow ( N , xi , eta + eps ) - & getArow ( N , xi , eta - eps )] P = P / ( 2._wp * eps ) P = matmul ( P , alpha ) J = matmul ( P , xy ) return end function getJacobian_2D","title":"getJacobian_2D – learn_dg","loc":"proc/getjacobian_2d.html"},{"tags":"","text":"Uses iso_fortran_env mod_legendre Descendants: smod_assemble_1D smod_assemble_2D Interfaces assembleElementalMatrix initialize_global_mats assemble set_BCs Interfaces public interface assembleElementalMatrix public function assembleElementalMatrix1D(N, d1, d2, xy) result(Ie) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N integer, intent(in) :: d1 integer, intent(in) :: d2 real(kind=wp), intent(in), dimension(N) :: xy Return Value real(kind=wp),\n  dimension(N,N) public function assembleElementalMatrix2D(N, d1, d2, xy) result(Ie) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N integer, intent(in) :: d1 integer, intent(in) :: d2 real(kind=wp), intent(in), dimension(N,2) :: xy Return Value real(kind=wp),\n  dimension(N,N) public interface initialize_global_mats public subroutine initialize_global_mats(num_nodes, GlobalA, GlobalB, GlobalX) Arguments Type Intent Optional Attributes Name integer, intent(in) :: num_nodes real(kind=wp), intent(out), dimension(:,:), allocatable :: GlobalA real(kind=wp), intent(out), dimension(:), allocatable :: GlobalB real(kind=wp), intent(out), dimension(:), allocatable :: GlobalX public interface assemble public subroutine assemble1D(points, cells, diff, vel, GlobalA) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: points integer, intent(in), dimension(:,:) :: cells real(kind=wp), intent(in) :: diff real(kind=wp), intent(in) :: vel real(kind=wp), intent(out), dimension(:,:) :: GlobalA public subroutine assemble2D(points, cells, diff, vel, GlobalA) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:,:) :: points integer, intent(in), dimension(:,:) :: cells real(kind=wp), intent(in) :: diff real(kind=wp), intent(in), dimension(2) :: vel real(kind=wp), intent(out), dimension(:,:) :: GlobalA public interface set_BCs public subroutine set_BCs(points, GlobalB, GlobalA) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: points Array of nodal coordinates real(kind=wp), intent(out), dimension(:) :: GlobalB Global RHS Vector real(kind=wp), intent(out), dimension(:,:) :: GlobalA","title":"mod_assembly – learn_dg","loc":"module/mod_assembly.html"},{"tags":"","text":"Uses iso_fortran_env iso_c_binding mod_assembly mod_misc Subroutines assembleElementalMatrix1D_c assembleElementalMatrix2D_c assemble1D_c assemble2D_c Subroutines private subroutine assembleElementalMatrix1D_c (N, d1, d2, xy, Ie) bind(c, name=\"0\") Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in), value :: N integer(kind=c_int), intent(in), value :: d1 integer(kind=c_int), intent(in), value :: d2 real(kind=c_double), intent(in) :: xy (N) real(kind=c_double), intent(inout) :: Ie (N,N) private subroutine assembleElementalMatrix2D_c (N, d1, d2, xy, Ie) bind(c, name=\"0\") Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in), value :: N integer(kind=c_int), intent(in), value :: d1 integer(kind=c_int), intent(in), value :: d2 real(kind=c_double), intent(in) :: xy (N,2) real(kind=c_double), intent(inout) :: Ie (N,N) private subroutine assemble1D_c (num_cells, num_pts_per_cell, num_pts, points, cells, diff, vel, GlobalA) bind(c, name=\"0\") Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in), value :: num_cells integer(kind=c_int), intent(in), value :: num_pts_per_cell integer(kind=c_int), intent(in), value :: num_pts real(kind=c_double), intent(in) :: points (num_pts) integer(kind=c_int), intent(in) :: cells (num_cells,num_pts_per_cell) real(kind=c_double), intent(in), value :: diff real(kind=c_double), intent(in), value :: vel real(kind=c_double), intent(inout) :: GlobalA (num_pts,num_pts) private subroutine assemble2D_c (num_cells, num_pts_per_cell, num_pts, points, cells, diff, vel, GlobalA) bind(c, name=\"0\") Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in), value :: num_cells integer(kind=c_int), intent(in), value :: num_pts_per_cell integer(kind=c_int), intent(in), value :: num_pts real(kind=c_double), intent(in) :: points (num_pts,2) integer(kind=c_int), intent(in) :: cells (num_cells,num_pts_per_cell) real(kind=c_double), intent(in), value :: diff real(kind=c_double), intent(in) :: vel (2) real(kind=c_double), intent(inout) :: GlobalA (num_pts,num_pts)","title":"mod_assembly_c – learn_dg","loc":"module/mod_assembly_c.html"},{"tags":"","text":"Uses iso_fortran_env lib_array Descendants: smod_integration Interfaces integrate fun2d_interf fun1d_interf gaussquad Functions integrate1D integrate2D Interfaces public interface integrate private function integrate1D (fun, xbnds) result(result) Arguments Type Intent Optional Attributes Name procedure( fun1d_interf ) :: fun real(kind=wp), intent(in) :: xbnds (2) Return Value real(kind=wp) private function integrate2D (fun, xbnds, ybnds) result(out) Arguments Type Intent Optional Attributes Name procedure( fun2d_interf ) :: fun real(kind=wp), intent(in) :: xbnds (2) real(kind=wp), intent(in) :: ybnds (2) Return Value real(kind=wp) interface private function fun2d_interf (x, y) result(z) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x (:,:) real(kind=wp), intent(in) :: y (:,:) Return Value real(kind=wp),\n  allocatable, (:,:) interface private function fun1d_interf (xx) result(yy) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: xx (:) Return Value real(kind=wp),\n  allocatable, (:) interface private module subroutine gaussquad (N, x, w) Implementation → Arguments Type Intent Optional Attributes Name integer, intent(in) :: N real(kind=wp), intent(out) :: x (N) real(kind=wp), intent(out) :: w (N) Functions private function integrate1D (fun, xbnds) result(result) Arguments Type Intent Optional Attributes Name procedure( fun1d_interf ) :: fun real(kind=wp), intent(in) :: xbnds (2) Return Value real(kind=wp) private function integrate2D (fun, xbnds, ybnds) result(out) Arguments Type Intent Optional Attributes Name procedure( fun2d_interf ) :: fun real(kind=wp), intent(in) :: xbnds (2) real(kind=wp), intent(in) :: ybnds (2) Return Value real(kind=wp)","title":"mod_integration – learn_dg","loc":"module/mod_integration.html"},{"tags":"","text":"Uses iso_fortran_env lib_array Subroutines read_gmsh_file_1D write_out_solution print_header Subroutines public subroutine read_gmsh_file_1D (num_nodes, nodes2vertex, cells, points, dg) Reads the input mesh file (gmsh .msh format) and returns the\n   number of nodes, element connectivity, and the coordinates of\n   the nodes in 1D Arguments Type Intent Optional Attributes Name integer, intent(out) :: num_nodes Number of nodes in mesh integer, intent(out), dimension(:), allocatable :: nodes2vertex Array containing node to vertex connectivity (only interesting w.r.t discontinuous galerkin) integer, intent(out), dimension(:,:), allocatable :: cells Array containing node connectivity of each element real(kind=wp), intent(out), dimension(:), allocatable :: points Array containing node coordinates logical, intent(in) :: dg Logical switch is continuous galerkin or discontinuous galerkin public subroutine write_out_solution (num_nodes, points, GlobalX) Arguments Type Intent Optional Attributes Name integer, intent(in) :: num_nodes real(kind=wp), intent(in), dimension(:) :: points real(kind=wp), intent(in), dimension(:) :: GlobalX private subroutine print_header () Arguments None","title":"mod_io – learn_dg","loc":"module/mod_io.html"},{"tags":"","text":"Uses iso_fortran_env Descendants: smod_legendre_1D smod_legendre_2D Interfaces basis_1D getXY pascal_single_row pascal_row getArow getAlpha2D getAlpha1D getJacobian Interfaces public interface basis_1D public pure function basis_1D(x, alpha, dx) result(y) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: x real(kind=wp), intent(in), dimension(:) :: alpha integer, intent(in) :: dx Return Value real(kind=wp),\n  dimension(:), allocatable public interface getXY public pure function getXY_2D(N) result(xy) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N Return Value real(kind=wp),\n  dimension(N,2) public interface pascal_single_row public pure function pascal_row_2D(N, x, y) result(row) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N real(kind=wp), intent(in) :: x real(kind=wp), intent(in) :: y Return Value real(kind=wp),\n  dimension(N+1) public interface pascal_row public pure function pascal_1D_line(N, x) result(row) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N real(kind=wp), intent(in) :: x Return Value real(kind=wp),\n  dimension(N+1) public pure function pascal_2D_quad(N, x, y) result(row) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N real(kind=wp), intent(in) :: x real(kind=wp), intent(in) :: y Return Value real(kind=wp),\n  dimension((N+1)**2) public interface getArow public pure function getArow1D(N, xi) result(row) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N real(kind=wp), intent(in) :: xi Return Value real(kind=wp),\n  dimension(N) public pure function getArow2D(N, xi, eta) result(row) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N real(kind=wp), intent(in) :: xi real(kind=wp), intent(in) :: eta Return Value real(kind=wp),\n  dimension(N) public interface getAlpha2D public function getAlpha2D(N) result(alpha) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N Return Value real(kind=wp),\n  dimension(N,N) public interface getAlpha1D public function getAlpha1D(N) result(alpha) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N Return Value real(kind=wp),\n  dimension(N,N) public interface getJacobian public function getJacobian_2D(N, xi, eta, xy, alpha) result(J) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N real(kind=wp), intent(in) :: xi real(kind=wp), intent(in) :: eta real(kind=wp), intent(in), dimension(N,2) :: xy real(kind=wp), intent(in), dimension(N,N) :: alpha Return Value real(kind=wp),\n  dimension(2,2)","title":"mod_legendre – learn_dg","loc":"module/mod_legendre.html"},{"tags":"","text":"Uses iso_c_binding mod_legendre Subroutines pascal_1D_line_c pascal_single_row_c pascal_2D_quad_c Subroutines public subroutine pascal_1D_line_c (N, x, row) bind(c, name=\"0\") Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in), value :: N real(kind=c_double), intent(in), value :: x real(kind=c_double), intent(out) :: row (N+1) private subroutine pascal_single_row_c (N, x, y, row) bind(c, name=\"0\") Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in), value :: N real(kind=c_double), intent(in), value :: x real(kind=c_double), intent(in), value :: y real(kind=c_double), intent(out) :: row (N+1) public subroutine pascal_2D_quad_c (N, x, y, row) bind(c, name=\"0\") Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in), value :: N real(kind=c_double), intent(in), value :: x real(kind=c_double), intent(in), value :: y real(kind=c_double), intent(out) :: row ((N+1)**2)","title":"mod_legendre_c – learn_dg","loc":"module/mod_legendre_c.html"},{"tags":"","text":"Uses iso_fortran_env Functions eye inv2 det2 Subroutines linsolve_quick linsolve Functions public pure function eye (N) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N Return Value real(kind=wp),\n  dimension(N,N) public pure function inv2 (J) result(invJ) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(2,2) :: J Return Value real(kind=wp),\n  dimension(2,2) public pure function det2 (A) result(det) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(2,2) :: A Return Value real(kind=wp) Subroutines public subroutine linsolve_quick (n, a, nrhs, b, x) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=wp), intent(in), dimension(n, n) :: a integer, intent(in) :: nrhs real(kind=wp), intent(in), dimension(n, nrhs) :: b real(kind=wp), intent(out), dimension(n, nrhs) :: x public subroutine linsolve (n, a, nrhs, b, x, LU, P, toggle) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=wp), intent(in), dimension(n, n) :: a integer, intent(in) :: nrhs real(kind=wp), intent(in), dimension(n, nrhs) :: b real(kind=wp), intent(out), dimension(n, nrhs) :: x real(kind=wp), intent(inout), dimension(n, n) :: LU integer, intent(inout), dimension(n) :: P logical, intent(in) :: toggle","title":"mod_linalg – learn_dg","loc":"module/mod_linalg.html"},{"tags":"","text":"Uses iso_fortran_env Subroutines r8mat_print r8mat_print_some Subroutines public subroutine r8mat_print (m, n, a, title) R8MAT_PRINT prints an R8MAT. Arguments Type Intent Optional Attributes Name integer(kind=4) :: m integer(kind=4) :: n real(kind=8) :: a (m,n) character(len=*) :: title private subroutine r8mat_print_some (m, n, a, ilo, jlo, ihi, jhi, title) R8MAT_PRINT_SOME prints some of an R8MAT. Arguments Type Intent Optional Attributes Name integer(kind=4) :: m integer(kind=4) :: n real(kind=8) :: a (m,n) integer(kind=4) :: ilo integer(kind=4) :: jlo integer(kind=4) :: ihi integer(kind=4) :: jhi character(len=*) :: title","title":"mod_misc – learn_dg","loc":"module/mod_misc.html"},{"tags":"","text":"Uses iso_fortran_env Derived Types t_settings Derived Types type, public :: t_settings Components Type Visibility Attributes Name Initial integer, public :: length = 0 integer, public :: width = 0","title":"mod_settings – learn_dg","loc":"module/mod_settings.html"},{"tags":"","text":"Ancestors: mod_assembly Uses iso_fortran_env mod_legendre mod_integration Functions integrate_basis_1d_Ie Subroutines assemble1D set_BCs Module Functions assembleElementalMatrix1D Module Subroutines initialize_global_mats Functions function integrate_basis_1d_Ie (N, ii, jj, dii, djj, xy) result(integral) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N integer, intent(in) :: ii integer, intent(in) :: jj integer, intent(in) :: dii integer, intent(in) :: djj real(kind=wp), intent(in), dimension(:) :: xy Return Value real(kind=wp) Subroutines subroutine assemble1D (points, cells, diff, vel, GlobalA) Assemble the global stiffness matrix based on element connectivity Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: points Array of nodal coordinates integer, intent(in), dimension(:,:) :: cells Element connectivity real(kind=wp), intent(in) :: diff Diffusivity coefficient [m/s&#94;2] real(kind=wp), intent(in) :: vel Velocity [m/s] real(kind=wp), intent(out), dimension(:,:) :: GlobalA Global Stiffness matrix subroutine set_BCs (points, GlobalB, GlobalA) Set boundary conditions in GlobalA and GlobalB using two\n   Dirchlet boundaries Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: points Array of nodal coordinates real(kind=wp), intent(out), dimension(:) :: GlobalB Global RHS Vector real(kind=wp), intent(out), dimension(:,:) :: GlobalA Global Mass Matrix Module Functions function assembleElementalMatrix1D (N, d1, d2, xy) result(Ie) Routine to calculate the elemental mass/stiffness matrix\n   based on the derivatives of the basis functions. Arguments Type Intent Optional Attributes Name integer, intent(in) :: N Number of nodes in basis function integer, intent(in) :: d1 Derivative of the first basis function integer, intent(in) :: d2 Derivative of the second basis function real(kind=wp), intent(in), dimension(N) :: xy Coordinates of the 1D line element Return Value real(kind=wp),\n  dimension(N,N) Output elemental matrix Module Subroutines subroutine initialize_global_mats (num_nodes, GlobalA, GlobalB, GlobalX) This routine initalizes the global stiffness matrix, global\n   rhs vector, and global solution vector based on the number of\n   nodes in the system Arguments Type Intent Optional Attributes Name integer, intent(in) :: num_nodes The number of nodes in the system real(kind=wp), intent(out), dimension(:,:), allocatable :: GlobalA Global mass matrix real(kind=wp), intent(out), dimension(:), allocatable :: GlobalB Global RHS Vector real(kind=wp), intent(out), dimension(:), allocatable :: GlobalX Global solution vector","title":"smod_assemble_1D – learn_dg","loc":"module/smod_assemble_1d.html"},{"tags":"","text":"Ancestors: mod_assembly Uses iso_fortran_env mod_linalg mod_legendre mod_integration lib_array Module Functions assembleElementalMatrix2D Module Subroutines assemble2D Module Functions function assembleElementalMatrix2D (N, d1, d2, xy) result(Ie) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N integer, intent(in) :: d1 integer, intent(in) :: d2 real(kind=wp), intent(in), dimension(N,2) :: xy Return Value real(kind=wp),\n  dimension(N,N) Module Subroutines subroutine assemble2D (points, cells, diff, vel, GlobalA) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:,:) :: points integer, intent(in), dimension(:,:) :: cells real(kind=wp), intent(in) :: diff real(kind=wp), intent(in), dimension(2) :: vel real(kind=wp), intent(out), dimension(:,:) :: GlobalA","title":"smod_assemble_2D – learn_dg","loc":"module/smod_assemble_2d.html"},{"tags":"","text":"Ancestors: mod_integration Subroutines lgwt cgwt gaussquad_rosetta Module Subroutines gaussquad Subroutines subroutine lgwt (a, b, num_pts, x, w) This function is a fortran90 port of the matlab function,\n   lgwt.m The source code of lgwt.m was originally found at:\n   http://www.mathworks.com/matlabcentral/fileexchange/4540 Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a real(kind=wp), intent(in) :: b integer, intent(in) :: num_pts real(kind=wp), intent(out) :: x (:) real(kind=wp), intent(out) :: w (:) subroutine cgwt (num_pts, x, w) Arguments Type Intent Optional Attributes Name integer, intent(in) :: num_pts real(kind=wp), intent(out), dimension(:) :: x real(kind=wp), intent(out), dimension(:) :: w subroutine gaussquad_rosetta (n, r1, r2) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=wp), intent(out) :: r1 (n) real(kind=wp), intent(out) :: r2 (n) Module Subroutines module subroutine gaussquad (N, x, w) Interface → Arguments Type Intent Optional Attributes Name integer, intent(in) :: N real(kind=wp), intent(out), dimension(N) :: x real(kind=wp), intent(out), dimension(N) :: w","title":"smod_integration – learn_dg","loc":"module/smod_integration.html"},{"tags":"","text":"Legendre_1D is a submodule used to generate arrays of coeffiecents used for\n developing finite element basis functions in 1D. Finite element basis\n functions are defined at internal nodes and used to iterpolate some value\n between those nodes. calculate the coeffiecents associated with a univarate Lagrangian polynomial  1, x, x&#94;2, ..., x&#94;N  In the end you end up with a group of basis functions similar to this: Ancestors: mod_legendre Uses mod_linalg lib_array Module Functions getArow1D getx getAlpha1D pascal_1D_line basis_1D Module Functions pure function getArow1D (N, xi) result(row) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N real(kind=wp), intent(in) :: xi Return Value real(kind=wp),\n  dimension(N) function getx (N) result(x) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N Return Value real(kind=wp),\n  dimension(N) function getAlpha1D (N) result(alpha) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N Return Value real(kind=wp),\n  dimension(N,N) pure function pascal_1D_line (N, x) result(row) Generates the elements of an array associated with a univarate\n Lagrange polynomial. Arguments Type Intent Optional Attributes Name integer, intent(in) :: N real(kind=wp), intent(in) :: x Return Value real(kind=wp),\n  dimension(N+1) pure function basis_1D (x, alpha, dx) result(y) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: x real(kind=wp), intent(in), dimension(:) :: alpha integer, intent(in) :: dx Return Value real(kind=wp),\n  dimension(:), allocatable","title":"smod_legendre_1D – learn_dg","loc":"module/smod_legendre_1d.html"},{"tags":"","text":"Ancestors: mod_legendre Uses mod_linalg mod_misc Functions pascal_row_2D Module Functions getXY_2D getArow2D getAlpha2D pascal_2D_quad getJacobian_2D Functions pure function pascal_row_2D (N, x, y) result(row) Generates a row of Pascal's triangle in 2D Arguments Type Intent Optional Attributes Name integer, intent(in) :: N Row number of pascal's 2D triange (0-indexed) real(kind=wp), intent(in) :: x X-value used in triange real(kind=wp), intent(in) :: y Y-Value used in triange Return Value real(kind=wp),\n  dimension(N+1) Output row of triange Module Functions pure function getXY_2D (N) result(xy) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N Return Value real(kind=wp),\n  dimension(N,2) pure function getArow2D (N, xi, eta) result(row) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N real(kind=wp), intent(in) :: xi real(kind=wp), intent(in) :: eta Return Value real(kind=wp),\n  dimension(N) function getAlpha2D (N) result(alpha) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N Return Value real(kind=wp),\n  dimension(N,N) pure function pascal_2D_quad (N, x, y) result(row) Generates an array of points related to a quadrilateral using Pascal's\n triangle in 2D, where rows are 0-indexed Arguments Type Intent Optional Attributes Name integer, intent(in) :: N Order of the qaudrilateral real(kind=wp), intent(in) :: x X-coordinate of node used in calculation real(kind=wp), intent(in) :: y Y-coordinate of node used in calculation Return Value real(kind=wp),\n  dimension((N+1)**2) Output row function getJacobian_2D (N, xi, eta, xy, alpha) result(J) Calculates the Jacobian of a quadrilateral element at a point Arguments Type Intent Optional Attributes Name integer, intent(in) :: N Number of points in element real(kind=wp), intent(in) :: xi Value of xi coordinate in isoparametric element real(kind=wp), intent(in) :: eta Value of eta coordinate in isoparametric element real(kind=wp), intent(in), dimension(N,2) :: xy Array of x and y coordinates for the element real(kind=wp), intent(in), dimension(N,N) :: alpha Array of coefficients used to define basis functions Return Value real(kind=wp),\n  dimension(2,2) Jacobian of the isoparametric element at (xi,eta)","title":"smod_legendre_2D – learn_dg","loc":"module/smod_legendre_2d.html"},{"tags":"","text":"Uses iso_fortran_env mod_linalg mod_misc mod_io mod_assembly Variables diff vel num_nodes nodes2vertex cells points GlobalB GlobalX GlobalA dg Source Code driver1D Variables Type Attributes Name Initial real(kind=wp), parameter :: diff = 0.1_wp real(kind=wp), parameter :: vel = -5._wp integer :: num_nodes integer, dimension(:), allocatable :: nodes2vertex integer, dimension(:,:), allocatable :: cells real(kind=wp), dimension(:), allocatable :: points real(kind=wp), dimension(:), allocatable :: GlobalB real(kind=wp), dimension(:), allocatable :: GlobalX real(kind=wp), dimension(:,:), allocatable :: GlobalA logical :: dg Source Code program driver1D use , intrinsic :: iso_fortran_env , only : wp => real64 use :: mod_linalg , only : linsolve_quick use :: mod_misc , only : r8mat_print use :: mod_io , only : read_gmsh_file_1D , write_out_solution use :: mod_assembly , only : initialize_global_mats , assemble , set_BCs implicit none real ( wp ), parameter :: diff = 0.1_wp , vel = - 5._wp integer :: num_nodes integer , dimension (:), allocatable :: nodes2vertex integer , dimension (:,:), allocatable :: cells real ( wp ), dimension (:), allocatable :: points , GlobalB , GlobalX real ( wp ), dimension (:,:), allocatable :: GlobalA logical :: dg ! dg = .true. dg = . false . call read_gmsh_file_1D ( num_nodes , nodes2vertex , cells , points , dg ) ! stop call initialize_global_mats ( num_nodes , GlobalA , GlobalB , GlobalX ) call assemble ( points , cells , diff , vel , GlobalA ) call set_BCs ( points , GlobalB , GlobalA ) ! call r8mat_print(num_nodes, num_nodes, GlobalA, 'Global Stiffness matrix:') ! stop call linsolve_quick ( num_nodes , GlobalA , 1 , GlobalB , GlobalX ) ! call r8mat_print(num_nodes, 1, GlobalB, 'Global RHS:') ! call r8mat_print(num_nodes, 1, GlobalX, 'Global Solution Vector:') call write_out_solution ( num_nodes , points , GlobalX ) end program driver1D","title":"driver1D – learn_dg","loc":"program/driver1d.html"},{"tags":"","text":"Uses iso_fortran_env mod_linalg mod_misc mod_legendre mod_assembly Variables ii N xy points Ie GlobalB GlobalX GlobalA elem Source Code driver2D Variables Type Attributes Name Initial integer :: ii integer, parameter :: N = 16 real(kind=wp), dimension(N,2) :: xy real(kind=wp), dimension(:,:), allocatable :: points real(kind=wp), dimension(N,N) :: Ie real(kind=wp), dimension(N) :: GlobalB real(kind=wp), dimension(N) :: GlobalX real(kind=wp), dimension(N,N) :: GlobalA integer, dimension(1,N) :: elem Source Code program driver2D use , intrinsic :: iso_fortran_env , only : wp => real64 use :: mod_linalg , only : linsolve_quick , eye use :: mod_misc , only : r8mat_print use :: mod_legendre , only : getXY use :: mod_assembly , only : assembleElementalMatrix , assemble implicit none integer :: ii ! integer, parameter :: N = 4 ! integer, parameter :: N = 9 integer , parameter :: N = 16 real ( wp ), dimension ( N , 2 ) :: xy real ( wp ), dimension (:,:), allocatable :: points real ( wp ), dimension ( N , N ) :: Ie real ( wp ), dimension ( N ) :: GlobalB , GlobalX real ( wp ), dimension ( N , N ) :: GlobalA ! real(wp), dimension(9)    :: GlobalB, GlobalX ! real(wp), dimension(9,9)  :: GlobalA ! real(wp), dimension(15)    :: GlobalB, GlobalX ! real(wp), dimension(15,15)  :: GlobalA ! real(wp), dimension(16)    :: GlobalB, GlobalX ! real(wp), dimension(16,16)  :: GlobalA integer , dimension ( 1 , N ) :: elem ! integer,  dimension(4,4)  :: elem ! integer,  dimension(2,9)  :: elem ! integer, dimension(1, 16) :: elem ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!! ! !!!!!! Bi-linear quads !!!!!!! ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!! ! Element connection(s) for 4 bi-linear quadrilaterals ! elem(1,:) = [1, 2, 3, 4] ! elem(2,:) = [2, 5, 6, 3] ! elem(3,:) = [5, 7, 8, 6] ! elem(4,:) = [7, 9, 10, 8] ! Get base xi/eta coordinates for bi-linear quadrilateral ! xy = getXY(N) ! Adjust for bi-linear quad ! xy(:,1) = [0._wp, 1._wp, 1.6_wp, 0._wp] ! xy(:,2) = [-1._wp, -2._wp, 5._wp, 3._wp] ! xy(:,1) = [0._wp, 0.03333_wp, 0.03333_wp, 0._wp] ! xy(:,2) = [0._wp, 0._wp, 0.03333_wp, 0.03333_wp] ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!! ! !!!!!! Bi-linear quads !!!!!!! ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!! ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! ! !!!!!! Bi-quadratic quads !!!!!!! ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! ! Element connection(s) for 2 bi-quadratic quadrilaterals ! elem(1,:) = [1, 2, 5, 6, 7, 8, 9, 10, 11] ! elem(2,:) = [2, 3, 4, 5, 12, 13, 14, 8, 15] ! Get base xi/eta coordinates for bi-quadratic quadrilateral ! xy = getXY(N) ! Adjust for bi-quadratic quad ! xy(:,1) = [0._wp, 0.03333_wp, 0.03333_wp, 0._wp, 0.016667_wp, 0.03333_wp, 0.016667_wp, 0._wp, 0.016667_wp] ! xy(:,2) = [0._wp, 0._wp, 0.03333_wp, 0.03333_wp, 0._wp, 0.016667_wp, 0.03333_wp, 0.016667_wp, 0.016667_wp] ! xy(1,:) = [-1.25_wp, -0.8_wp] ! xy(6,:) = [0.75_wp, 0.1_wp] ! xy(9,:) = [-0.25_wp, 0.25_wp] ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! ! !!!!!! Bi-quadratic quads !!!!!!! ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!! ! !!!!!! Bi-cubic quads !!!!!!! ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!! ! Element connection(s) for 2 bi-cubic quadrilaterals ! elem(1,:) = [(ii, ii=1,16)] ! Get base xi/eta coordinates for bi-cubic quadrilateral ! xy = getXY(N) ! Adjust for bi-cubic quad ! xy(:,1) = [0._wp, 0.03333_wp, 0.03333_wp, 0._wp, 0.016667_wp, 0.03333_wp, 0.016667_wp, 0._wp, 0.016667_wp] ! xy(:,2) = [0._wp, 0._wp, 0.03333_wp, 0.03333_wp, 0._wp, 0.016667_wp, 0.03333_wp, 0.016667_wp, 0.016667_wp] ! xy(1,:) = [-1.25_wp, -0.8_wp] ! xy(6,:) = [0.75_wp, 0.1_wp] ! xy(9,:) = [-0.25_wp, 0.25_wp] ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!! ! !!!!!! Bi-cubic quads !!!!!!! ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!! ! GlobalA = 0._wp ! do ii = 1, size(elem, 1) !   Ie = - assembleElementalMatrix(N, 1, 1, xy) - assembleElementalMatrix(N, 2, 2, xy) !   GlobalA(elem(ii,:), elem(ii,:)) = GlobalA(elem(ii,:), elem(ii,:)) + Ie ! enddo ! elem(1,:) = [1, 5, 9, 8] ! elem(2,:) = [5, 2, 6, 9] ! elem(3,:) = [9, 6, 3, 7] ! elem(4,:) = [8, 9, 7, 4] elem ( 1 ,:) = [( ii , ii = 1 , N )] ! call r8mat_print(size(elem,1), size(elem,2), dble(elem), \"cells\") points = getXY ( N ) ! call r8mat_print(size(points,1), size(points,2), points, 'points') call assemble ( points , elem , 1._wp , [ 0._wp , 0._wp ], GlobalA ) select case ( N ) case ( 9 ) GlobalA ( [ 1 , 2 , 3 , 4 , 6 , 8 ], : ) = 0._wp GlobalA ( [ 1 , 2 , 3 , 4 , 6 , 8 ], [ 1 , 2 , 3 , 4 , 6 , 8 ] ) = eye ( 6 ) GlobalB = 0._wp GlobalB ( [ 1 , 4 , 8 ] ) = 1._wp case ( 16 ) GlobalA ( [ 1 , 2 , 3 , 4 , 7 , 8 , 11 , 12 ], : ) = 0._wp GlobalA ( [ 1 , 2 , 3 , 4 , 7 , 8 , 11 , 12 ], [ 1 , 2 , 3 , 4 , 7 , 8 , 11 , 12 ] ) = eye ( 8 ) GlobalB = 0._wp GlobalB ( [ 1 , 4 , 11 , 12 ] ) = 1._wp end select ! Zero-out the row corresponding with BCs and set A(ii,ii) to 1.0 forall ii ! GlobalA( [1, 4, 9, 10], : ) = 0._wp ! GlobalA( [1, 4, 9, 10], [1, 4, 9, 10] ) = eye(4) ! GlobalA( [1, 6, 10, 3, 4, 13], : ) = 0._wp ! GlobalA( [1, 6, 10, 3, 4, 13], [1, 6, 10, 3, 4, 13] ) = eye(6) ! GlobalA( [1, 2, 7, 8, 3, 4, 11, 12], : ) = 0._wp ! GlobalA( [1, 2, 7, 8, 3, 4, 11, 12], [1, 2, 7, 8, 3, 4, 11, 12] ) = eye(8) ! call r8mat_print(size(GlobalA,1), size(GlobalA,2), GlobalA, \"Global Stiffness Matrix:\") ! Set BCs (zero everywhere, 1 on left boundary) ! GlobalB = 0._wp ! GlobalB( [1, 4] ) = 1._wp ! GlobalB( [1, 4, 8] ) = 1._wp ! GlobalB ( [1, 4, 11, 12] ) = 1._wp ! Solve linear system call linsolve_quick ( & size ( GlobalA , 1 ), GlobalA , & size ( GlobalB , 1 ), GlobalB , & GlobalX ) call r8mat_print ( & size ( GlobalX , 1 ), 1 , GlobalX , \"Solution Vector:\" ) end program driver2D","title":"driver2D – learn_dg","loc":"program/driver2d.html"},{"tags":"","text":"Introduction This is an introduction","title":"User Guide – learn_dg","loc":"page//index.html"},{"tags":"","text":"Finite Element Theory Finite Element Theory Introduction Basis functions Partial Differential Equations Introduction This is the intro Basis functions Basis functions in 1D: Linear line (2 pts) Quadratic line (3 pts) Cubic line (4 pts) Basis functions in 2D: Bi-linear quadrilateral (4 pts) Bi-quadratic quadrilateral (9 pts) Bi-cubic quadrilateral (16 pts) Partial Differential Equations Example adv-diff equation  \\frac{\\partial u}{\\partial t} = \\Delta \\left( u \\right) - \\nabla \\cdot \\left( \\vec{c} u \\right)  Example","title":"Finite Element Theory – learn_dg","loc":"page/finite-element-theory/index.html"},{"tags":"","text":"Examples Examples Example Advection-Diffusion Problem Example Advection-Diffusion Problem Here goes the example","title":"Example – learn_dg","loc":"page/finite-element-theory/01_example.html"}]}