var tipuesearch = {"pages":[{"loc":"index.html","tags":"","text":"learn_dg This is the first paragraph of the document Note This is a note. I should elaborate on it Dependencies This project uses lapack/blas as the numerical backend. Linking to these\nlibraries was no problem on Linux, but on Windows you need to build lapack/blas\nfrom scratch. First download lapack/blas from here:\n'http://www.netlib.org/lapack/#_lapack_for_windows' Install using CMAKE, and then move the libblas.dll.a and liblapack.dll.a\nlibraries into wherever mingw expects to find libraries: Example:\n'C:\\Development\\MinGW\\lib' Documentation Website The documentation is built using FORD .\nFORD takes inline documentation, prefixed by !+ , and the markdown files located in docs/user_guide and wraps them all up in a pretty website.\nThe documentation website is automatically updated whenever a commit is added to the master branch. This is done through Travis-CI. To build the documentation locally run make docs This will build the documentation website in the docs/html directory. This project organization was heavily influenced by FIDASIM Developer Info Chris Coutinho","title":" learn_dg "},{"loc":"sourcefile/assembly.f90.html","tags":"","text":"This File Depends On sourcefile~~assembly.f90~~EfferentGraph sourcefile~assembly.f90 assembly.f90 sourcefile~legendre.f90 legendre.f90 sourcefile~legendre.f90->sourcefile~assembly.f90 sourcefile~integration.f90 integration.f90 sourcefile~integration.f90->sourcefile~legendre.f90 sourcefile~misc.f90 misc.f90 sourcefile~misc.f90->sourcefile~legendre.f90 sourcefile~linalg.f90 linalg.f90 sourcefile~linalg.f90->sourcefile~legendre.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files Dependent On This One sourcefile~~assembly.f90~~AfferentGraph sourcefile~assembly.f90 assembly.f90 sourcefile~main.f90 main.f90 sourcefile~assembly.f90->sourcefile~main.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Modules assembly Source Code assembly.f90 Source Code module assembly use iso_fortran_env , only : wp => real64 use legendre , only : getIe implicit none public :: initialize_global_mats , assemble contains subroutine initialize_global_mats ( num_nodes , & & GlobalA , & & GlobalB , & & GlobalX , & & xcoords ) integer , intent ( in ) :: num_nodes real ( wp ), intent ( out ), dimension (:), allocatable :: GlobalB , GlobalX real ( wp ), intent ( out ), dimension (:,:), allocatable :: GlobalA real ( wp ), intent ( in ), dimension (:) :: xcoords allocate ( GlobalA ( num_nodes , num_nodes )) allocate ( GlobalB ( num_nodes )) allocate ( GlobalX ( num_nodes )) ! Intial Conditions GlobalA (:,:) = 0._wp GlobalX (:) = 0._wp return end subroutine initialize_global_mats subroutine assemble ( order , xcoords , elem_conn , GlobalA , diff , vel ) integer , intent ( in ), dimension (:) :: order integer , intent ( in ), dimension (:,:) :: elem_conn real ( wp ), intent ( in ) :: diff , vel real ( wp ), intent ( in ), dimension (:) :: xcoords real ( wp ), intent ( out ), dimension (:,:) :: GlobalA integer :: ii real ( wp ), dimension (:,:), allocatable :: Ie ! Add elemental stiffness matrices to Global Stiffness Matrix do ii = 1 , size ( order ) ! Reallocate elemental stiffness matrix allocate ( Ie ( order ( ii ) + 1 , order ( ii ) + 1 )) call getIe ( 1 , 1 , xcoords ( elem_conn ( ii ,:)), Ie ) ! call r8mat_print(order(ii)+1, order(ii)+1, Ie, 'Elemental Stiffness Matrix:') GlobalA ( elem_conn ( ii ,:), elem_conn ( ii ,:)) = & GlobalA ( elem_conn ( ii ,:), elem_conn ( ii ,:)) - diff * Ie call getIe ( 0 , 1 , xcoords ( elem_conn ( ii ,:)), Ie ) ! call r8mat_print(order(ii)+1, order(ii)+1, Ie, 'Elemental Stiffness Matrix:') GlobalA ( elem_conn ( ii ,:), elem_conn ( ii ,:)) = & GlobalA ( elem_conn ( ii ,:), elem_conn ( ii ,:)) - vel * Ie ! Deallocate elemental stiffness matrix after every loop deallocate ( Ie ) ! stop enddo ! call r8mat_print(num_nodes, num_nodes, GlobalA, 'Global Stiffness Matrix:') ! stop return end subroutine assemble subroutine set_BCs ( xcoords , GlobalB , GlobalA ) real ( wp ), intent ( in ), dimension (:) :: xcoords real ( wp ), intent ( out ), dimension (:) :: GlobalB real ( wp ), intent ( out ), dimension (:,:) :: GlobalA integer , dimension ( 1 ) :: iloc iloc = minloc ( xcoords ) GlobalA ( iloc ,:) = 0._wp GlobalA ( iloc , iloc ) = 1._wp iloc = maxloc ( xcoords ) GlobalA ( iloc ,:) = 0._wp GlobalA ( iloc , iloc ) = 1._wp ! Left Boundary Dirchlet BC GlobalB (:) = 0._wp ! Right Boundary Dirchlet BC GlobalB ( maxloc ( xcoords )) = 1._wp ! call r8mat_print(num_nodes, 1, GlobalB, 'Global RHS:') ! stop return end subroutine set_BCs end module assembly","title":"assembly.f90 – learn_dg"},{"loc":"sourcefile/doubleint.f90.html","tags":"","text":"This File Depends On sourcefile~~doubleint.f90~~EfferentGraph sourcefile~doubleint.f90 doubleint.f90 sourcefile~misc.f90 misc.f90 sourcefile~misc.f90->sourcefile~doubleint.f90 sourcefile~legendre.f90 legendre.f90 sourcefile~misc.f90->sourcefile~legendre.f90 sourcefile~linalg.f90 linalg.f90 sourcefile~linalg.f90->sourcefile~doubleint.f90 sourcefile~linalg.f90->sourcefile~legendre.f90 sourcefile~legendre.f90->sourcefile~doubleint.f90 sourcefile~integration.f90 integration.f90 sourcefile~integration.f90->sourcefile~legendre.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Programs doubleint Source Code doubleint.f90 Source Code program doubleint use iso_fortran_env , only : wp => real64 use linalg , only : linsolve_quick , eye use misc , only : r8mat_print use legendre , only : assembleElementalMatrix , getxy implicit none integer :: ii ! integer, parameter :: N = 4 ! integer, parameter :: N = 9 integer , parameter :: N = 16 real ( wp ), dimension ( N , 2 ) :: xy real ( wp ), dimension ( N , N ) :: Ie ! real(wp), dimension(10)    :: GlobalB, GlobalX ! real(wp), dimension(10,10)  :: GlobalA ! real(wp), dimension(15)    :: GlobalB, GlobalX ! real(wp), dimension(15,15)  :: GlobalA real ( wp ), dimension ( 16 ) :: GlobalB , GlobalX real ( wp ), dimension ( 16 , 16 ) :: GlobalA ! integer,  dimension(4,4)  :: elem ! integer,  dimension(2,9)  :: elem integer , dimension ( 1 , 16 ) :: elem !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!! Bi-linear quads !!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! ! Element connection(s) for 3 bi-linear quadrilaterals ! elem(1,:) = [1, 2, 3, 4] ! elem(2,:) = [2, 5, 6, 3] ! elem(3,:) = [5, 7, 8, 6] ! elem(4,:) = [7, 9, 10, 8] ! Get base xi/eta coordinates for bi-linear quadrilateral ! xy(:,1) = [-1._wp, 1._wp, 1._wp, -1._wp] ! xy(:,2) = [-1._wp, -1._wp, 1._wp, 1._wp] ! Adjust for bi-linear quad ! xy(:,1) = [0._wp, 1._wp, 1.6_wp, 0._wp] ! xy(:,2) = [-1._wp, -2._wp, 5._wp, 3._wp] ! xy(:,1) = [0._wp, 0.03333_wp, 0.03333_wp, 0._wp] ! xy(:,2) = [0._wp, 0._wp, 0.03333_wp, 0.03333_wp] !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!! Bi-linear quads !!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!! Bi-quadratic quads !!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! ! Element connection(s) for 2 bi-quadratic quadrilaterals ! elem(1,:) = [1, 2, 5, 6, 7, 8, 9, 10, 11] ! elem(2,:) = [2, 3, 4, 5, 12, 13, 14, 8, 15] ! Get base xi/eta coordinates for bi-quadratic quadrilateral ! xy(:,1) = [-1._wp, 1._wp, 1._wp, -1._wp, 0._wp, 1._wp, 0._wp, -1._wp, 0._wp] ! xy(:,2) = [-1._wp, -1._wp, 1._wp, 1._wp, -1._wp, 0._wp, 1._wp, 0._wp, 0._wp] ! Adjust for bi-quadratic quad ! xy(:,1) = [0._wp, 0.03333_wp, 0.03333_wp, 0._wp, 0.016667_wp, 0.03333_wp, 0.016667_wp, 0._wp, 0.016667_wp] ! xy(:,2) = [0._wp, 0._wp, 0.03333_wp, 0.03333_wp, 0._wp, 0.016667_wp, 0.03333_wp, 0.016667_wp, 0.016667_wp] ! xy(1,:) = [-1.25_wp, -0.8_wp] ! xy(6,:) = [0.75_wp, 0.1_wp] ! xy(9,:) = [-0.25_wp, 0.25_wp] !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!! Bi-quadratic quads !!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!! Bi-cubic quads !!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!! ! Element connection(s) for 2 bi-cubic quadrilaterals elem ( 1 ,:) = [( ii , ii = 1 , 16 )] ! Get base xi/eta coordinates for bi-cubic quadrilateral xy = getxy ( N ) ! Adjust for bi-cubic quad ! xy(:,1) = [0._wp, 0.03333_wp, 0.03333_wp, 0._wp, 0.016667_wp, 0.03333_wp, 0.016667_wp, 0._wp, 0.016667_wp] ! xy(:,2) = [0._wp, 0._wp, 0.03333_wp, 0.03333_wp, 0._wp, 0.016667_wp, 0.03333_wp, 0.016667_wp, 0.016667_wp] ! xy(1,:) = [-1.25_wp, -0.8_wp] ! xy(6,:) = [0.75_wp, 0.1_wp] ! xy(9,:) = [-0.25_wp, 0.25_wp] !!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!! Bi-cubic quads !!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!! GlobalA = 0._wp do ii = 1 , size ( elem , 1 ) Ie = - assembleElementalMatrix ( N , 1 , 1 , xy ) - assembleElementalMatrix ( N , 2 , 2 , xy ) GlobalA ( elem ( ii ,:), elem ( ii ,:)) = GlobalA ( elem ( ii ,:), elem ( ii ,:)) + Ie enddo ! Zero-out the row corresponding with BCs and set A(ii,ii) to 1.0 forall ii ! GlobalA( [1, 4, 9, 10], : ) = 0._wp ! GlobalA( [1, 4, 9, 10], [1, 4, 9, 10] ) = eye(4) ! GlobalA( [1, 6, 10, 3, 4, 13], : ) = 0._wp ! GlobalA( [1, 6, 10, 3, 4, 13], [1, 6, 10, 3, 4, 13] ) = eye(6) GlobalA ( [ 1 , 2 , 7 , 8 , 3 , 4 , 11 , 12 ], : ) = 0._wp GlobalA ( [ 1 , 2 , 7 , 8 , 3 , 4 , 11 , 12 ], [ 1 , 2 , 7 , 8 , 3 , 4 , 11 , 12 ] ) = eye ( 8 ) call r8mat_print ( size ( GlobalA , 1 ), size ( GlobalA , 2 ), GlobalA , \"Global Stiffness Matrix:\" ) ! Set BCs (zero everywhere, 1 on left boundary) GlobalB = 0._wp ! GlobalB( [1, 4] ) = 1._wp ! GlobalB( [1, 6, 10] ) = 1._wp GlobalB ( [ 1 , 4 , 11 , 12 ] ) = 1._wp ! Solve linear system call linsolve_quick ( size ( GlobalA , 1 ), GlobalA , size ( GlobalB , 1 ), GlobalB , GlobalX ) call r8mat_print ( size ( GlobalX , 1 ), 1 , GlobalX , \"Solution Vector:\" ) end program doubleint","title":"doubleint.f90 – learn_dg"},{"loc":"sourcefile/integration.f90.html","tags":"","text":"Files Dependent On This One sourcefile~~integration.f90~~AfferentGraph sourcefile~integration.f90 integration.f90 sourcefile~legendre.f90 legendre.f90 sourcefile~integration.f90->sourcefile~legendre.f90 sourcefile~doubleint.f90 doubleint.f90 sourcefile~legendre.f90->sourcefile~doubleint.f90 sourcefile~assembly.f90 assembly.f90 sourcefile~legendre.f90->sourcefile~assembly.f90 sourcefile~main.f90 main.f90 sourcefile~assembly.f90->sourcefile~main.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Modules integration Source Code integration.f90 Source Code module integration use iso_fortran_env , only : wp => real64 use lib_array , only : linspace implicit none private :: lgwt , gaussquad , cgwt ! public :: lgwt, gaussquad, cgwt public :: integrate , integrate2D interface function fun2d_interf ( x , y ) result ( z ) import wp real ( wp ), intent ( in ), dimension (:,:) :: x , y real ( wp ), dimension (:,:), allocatable :: z end function end interface contains subroutine integrate ( sub , a , b , result ) ! This routine uses gauss-legendre quadrature to integrate a 1D function ! Input/Output variables real ( wp ), intent ( in ) :: a , b real ( wp ), intent ( out ) :: result interface subroutine sub ( xx , yy ) import wp real ( wp ), intent ( in ), dimension (:) :: xx real ( wp ), intent ( out ), dimension (:) :: yy end subroutine sub end interface ! Local variables integer :: N real ( wp ) :: result_old , error real ( wp ), parameter :: eps = sqrt ( epsilon ( 1.0_wp )) real ( wp ), dimension (:), allocatable :: x , w , y N = 3 result = 0.0_wp error = 1.0_wp do result_old = result allocate ( x ( N ), w ( N ), y ( N )) ! call cgwt(N, x, w) ! call lgwt(a, b, N, x, w) call gaussquad ( N , x , w ) call sub ( x , y ) result = sum ( y * w ) deallocate ( x , w , y ) ! error = norm2([result, result_old]) error = sqrt (( result - result_old ) ** 2.0_wp ) ! error = abs((result-result_old)/(result_old+eps)) ! write(*,*) N, result, error ! write(*,*) N, result, result_old, error, eps ! Check if error is acceptable, as well as whether the loop was gone ! through at least twice (N = 3, 4, 5...) if ( ( error < eps . or . abs ( result ) < eps ) & . and . N > 5 ) then exit else N = N + 1 endif enddo return end subroutine integrate function integrate2D ( fun ) result ( out ) procedure ( fun2d_interf ) :: fun real ( wp ) :: out integer :: ii , N real ( wp ) :: out_old , error real ( wp ), parameter :: eps = epsilon ( 0 e0 ) real ( wp ), dimension (:), allocatable :: x , w real ( wp ), dimension (:,:), allocatable :: xx , yy , wx , wy , out_spread ! Adaptive integration based on 2D Gauss-Legendre Quadrature ii = 1 ! Iteration number N = 2 ! Initial number of points to use error = 1._wp ! Initial estimate of error do ! Allocate x (positions) and w (weights) based on roots of the Legendre ! polynomial of order 'N' allocate ( x ( N ), w ( N )) allocate ( xx ( N , N ), yy ( N , N )) allocate ( wx ( N , N ), wy ( N , N )) allocate ( out_spread ( N , N )) call gaussquad_wrapper ( N , x , w ) ! Copy the 'x' array along both the x and y axes xx = spread ( x , dim = 1 , ncopies = N ) yy = spread ( x , dim = 2 , ncopies = N ) ! Copy the weights along both the x and y axes as well wx = spread ( w , dim = 1 , ncopies = N ) wy = spread ( w , dim = 2 , ncopies = N ) ! Calculate the function at the xx and yy nodes, and multiply the result ! with the weights: wx and wy out_spread = fun ( xx , yy ) * wx * wy ! Sum up the resulting array into a single scalar output out = sum ( reshape ( out_spread , [ N * N , 1 ] )) ! print*, out ! Set error if ii > 1 if ( ii > 1 ) then error = out - out_old else error = 1._wp endif ! Deallocate all arrays no longer needed. They will change size in each ! iteration anyway deallocate ( x , w , xx , yy , wx , wy , out_spread ) ! If iteration counter is more than 1 then check exit criteria if ( norm2 ( [ error ] ) <= eps ) then ! print'(a,i3,a,e13.5)', 'Fun integrated in ', N, & !                       & ' iterations. Error = ', error exit else out_old = out ii = ii + 1 N = N + 1 endif enddo return end function subroutine gaussquad_wrapper ( N , x , w ) integer , intent ( in ) :: N real ( wp ), intent ( out ), dimension ( N ) :: x , w select case ( N ) case ( 1 ) x = [ 0._wp ] w = [ 2._wp ] case ( 2 ) x = [ - 0.5773502691896257_wp , & & 0.5773502691896257_wp ] w = [ 1._wp , & & 1._wp ] case ( 3 ) x = [ - 0.7745966692414834_wp , & & 0._wp , & & 0.7745966692414834_wp ] w = [ 0.5555555555555556_wp , & & 0.8888888888888888_wp , & & 0.5555555555555556_wp ] case ( 4 ) x = [ - 0.8611363115940526_wp , & & - 0.3399810435848563_wp , & & 0.3399810435848563_wp , & & 0.8611363115940526_wp ] w = [ 0.3478548451374538_wp , & & 0.6521451548625461_wp , & & 0.6521451548625461_wp , & & 0.3478548451374538_wp ] case ( 5 ) x = [ - 0.9061798459386640_wp , & & - 0.5384693101056831_wp , & & 0._wp , & & 0.5384693101056831_wp , & & 0.9061798459386640_wp ] w = [ 0.2369268850561891_wp , & & 0.4786286704993665_wp , & & 0.5688888888888889_wp , & & 0.4786286704993665_wp , & & 0.2369268850561891_wp ] case default ! call lgwt(-1._wp, 1._wp, N, x, w) ! call cgwt(N, x, w) call gaussquad ( N , x , w ) end select return end subroutine gaussquad_wrapper subroutine lgwt ( a , b , num_pts , x , w ) ! This function is a fortran90 port of the matlab function, lgwt.m ! The source code of lgwt.m was originally found at: ! ! http://www.mathworks.com/matlabcentral/fileexchange/4540 ! Variables in/out integer , intent ( in ) :: num_pts real ( wp ), intent ( in ) :: a , b real ( wp ), intent ( out ), dimension (:) :: x , w ! Local variables integer :: ii , jj , N , N1 , N2 ! real(wp), parameter:: eps=sqrt(epsilon(1.0_wp)) real ( wp ), parameter :: eps = 1 d - 10 real ( wp ), dimension (:), allocatable :: xu , array1 , y , y0 , Lpp real ( wp ), dimension (:, :), allocatable :: L , Lp real ( wp ), parameter :: pi = 4.0_wp * datan ( 1.0_wp ) N = num_pts - 1 N1 = N + 1 N2 = N + 2 ! Allocate and initialize arrays allocate ( xu ( N1 ), array1 ( N1 ), y ( N1 ), y0 ( N1 )) allocate ( L ( N1 , N2 ), Lp ( N1 , N2 ), Lpp ( N1 )) L = 0.0_wp Lp = 0.0_wp call linspace ( - 1.0_wp , 1.0_wp , xu ) array1 = [ ( ii , ii = 0 , N ) ] ! Initial guess of ??? y = dcos (( 2.0_wp * real ( array1 , wp ) + 1.0_wp ) * & pi / ( 2.0_wp * real ( N , wp ) + 2.0_wp )) + & ( 0.27_wp / real ( N1 , wp )) * dsin ( pi * xu * real ( N , wp ) / real ( N2 , wp )) y0 = 2.0_wp do L (:, 1 ) = 1.0_wp Lp (:, 1 ) = 0.0_wp L (:, 2 ) = y Lp (:, 2 ) = 1.0_wp do jj = 2 , N1 L (:, jj + 1 ) = ( ( 2.0_wp * real ( jj , wp ) - 1.0_wp ) * y * L (:, jj ) - & real ( jj - 1 , wp ) * L (:, jj - 1 )) / real ( jj , wp ) enddo Lpp = real ( N2 , wp ) * ( L (:, N1 ) - y * L (:, N2 )) / ( 1.0_wp - y ** 2.0_wp ) y0 = y y = y0 - L (:, N2 ) / Lpp if ( norm2 ( y - y0 ) < eps ) then exit endif enddo x = ( a * ( 1.0_wp - y ) + b * ( 1.0_wp + y ) ) / 2.0_wp w = ( b - a ) / (( 1.0_wp - y ** 2.0_wp ) * Lpp ** 2.0_wp ) * & ( real ( N2 , wp ) / real ( N1 , wp )) ** 2.0_wp return end subroutine lgwt subroutine cgwt ( num_pts , x , w ) ! This function  determines the points and weights associated with Chebyshev-Gauss quadrature ! Variables in/out integer , intent ( in ) :: num_pts real ( wp ), intent ( out ), dimension (:) :: x , w ! Local variables integer :: ii real ( wp ), parameter :: pi = 4._wp * datan ( 1._wp ) x = dcos ( ( real ( 2 * [( ii , ii = 1 , num_pts )] - 1 , wp ) ) / real ( 2 * num_pts , wp ) * pi ) w = pi / real ( num_pts , wp ) / (( 1.0_wp - x ** 2._wp ) ** ( - 0.5_wp )) ! write(*,*) x ! write(*,*) w ! stop return end subroutine cgwt subroutine gaussquad ( n , r1 , r2 ) ! This code was originally found at the following website: !  http://rosettacode.org/wiki/Numerical_integration/Gauss-Legendre_Quadrature#Fortran integer , intent ( in ) :: n real ( wp ), intent ( out ) :: r1 ( n ), r2 ( n ) integer :: k real ( wp ), parameter :: pi = 4._wp * atan ( 1._wp ) real ( wp ) :: x , f , df , dx integer :: i , iter real ( wp ), allocatable :: p0 (:), p1 (:), tmp (:) p0 = [ 1._wp ] p1 = [ 1._wp , 0._wp ] do k = 2 , n tmp = (( 2 * k - 1 ) * [ p1 , 0._wp ] - ( k - 1 ) * [ 0._wp , 0._wp , p0 ]) / k p0 = p1 ; p1 = tmp enddo do i = 1 , n x = cos ( pi * ( i - 0.25_wp ) / ( n + 0.5_wp )) do iter = 1 , 10 f = p1 ( 1 ); df = 0._wp do k = 2 , size ( p1 ) df = f + x * df f = p1 ( k ) + x * f enddo dx = f / df x = x - dx if ( abs ( dx ) < 10 * epsilon ( dx )) exit enddo r1 ( i ) = x r2 ( i ) = 2 / (( 1 - x ** 2 ) * df ** 2 ) enddo return end subroutine end module integration","title":"integration.f90 – learn_dg"},{"loc":"sourcefile/io.f90.html","tags":"","text":"Files Dependent On This One sourcefile~~io.f90~~AfferentGraph sourcefile~io.f90 io.f90 sourcefile~main.f90 main.f90 sourcefile~io.f90->sourcefile~main.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Modules io Source Code io.f90 Source Code module io use iso_fortran_env , only : wp => real64 use lib_array , only : linspace implicit none public :: read_gmsh_file_1D , & & write_out_solution contains subroutine get_command_argument_wrapper ( arg ) character ( * ), intent ( out ) :: arg integer :: ii ii = 1 do call get_command_argument ( ii , arg ) if ( len_trim ( arg ) == 0 ) then arg = trim ( arg ) else exit endif ii = ii + 1 enddo return end subroutine get_command_argument_wrapper subroutine read_gmsh_file_1D ( num_nodes , & & order , & & nodes2vertex , & & elem_conn , & & xcoords , & & dg ) integer , intent ( out ) :: num_nodes integer , intent ( out ), dimension (:), allocatable :: order , nodes2vertex integer , intent ( out ), dimension (:,:), allocatable :: elem_conn real ( wp ), intent ( out ), dimension (:), allocatable :: xcoords logical , intent ( in ) :: dg integer :: ii , ios , vertex , num_elements , num_vertexes , d_int integer , dimension ( 2 ) :: iloc integer , dimension (:,:), allocatable :: vertex_conn real ( wp ) :: d_real character ( 50 ) :: filename character ( 50 ) :: blank_string call get_command_argument_wrapper ( filename ) ! print*, filename open ( unit = 21 , file = filename , iostat = ios , status = \"old\" , action = \"read\" ) if ( ios /= 0 ) stop \"Error opening file \" ! Read initial header information - assuming file is in the correct format do read ( 21 , * ) blank_string if ( trim ( blank_string ) == '$Nodes' ) exit enddo ! Read number of nodes read ( 21 , * ) num_vertexes allocate ( xcoords ( num_vertexes )) if ( . not . dg ) then num_nodes = num_vertexes else num_nodes = 2 * num_vertexes - 2 endif ! Read coordinate information for each vertex do ii = 1 , num_vertexes read ( 21 , * ) d_int , xcoords ( ii ), d_real , d_real enddo allocate ( nodes2vertex ( num_nodes )) nodes2vertex = 0 if ( dg ) then vertex = 1 do ii = 1 , num_nodes nodes2vertex ( ii ) = vertex if ( ii == 1 . or . ii == num_nodes ) then vertex = vertex + 1 elseif ( mod ( ii , 2 ) == 0 ) then vertex = vertex + 1 endif enddo else nodes2vertex = [( ii , ii = 1 , num_nodes )] endif do ii = 1 , num_nodes print * , ii , nodes2vertex ( ii ), xcoords ( nodes2vertex ( ii )) enddo print * , ! stop ! Two dummy lines : !   $EndNodes !   $Elements read ( 21 , * ) read ( 21 , * ) read ( 21 , * ) num_elements num_elements = num_elements - 2 allocate ( order ( num_elements )) allocate ( elem_conn ( num_elements , 2 )) allocate ( vertex_conn ( num_elements , 2 )) ! Initialize all elements as first order linear elements order = 1 ! Two dummy lines - Associated with 'point' elements read ( 21 , * ) read ( 21 , * ) do ii = 1 , num_elements read ( 21 , * ) d_int , d_int , d_int , d_int , d_int , vertex_conn ( ii , 1 : 2 ) ! print*, pack(vertex_conn, vertex_conn == nodes2vertex) enddo ! print*, pack([( ii, ii = 1, num_nodes )], & !       & nodes2vertex == nodes2vertex(3) & !       & .or. nodes2vertex == nodes2vertex(5)) ! stop if ( . not . dg ) then elem_conn = vertex_conn else do ii = 1 , num_elements ! elem_conn(ii,:) = pack([( ii, ii = 1, num_nodes )], & ! & nodes2vertex == vertex_conn(ii,1)) ! print*, loc(2._wp) ! print*, loc(nodes2vertex == vertex_conn(ii,2)) print * , order ( ii ), vertex_conn ( ii ,:), elem_conn ( ii ,:) print * , enddo endif print * , do ii = 1 , size ( xcoords ) print * , xcoords ( ii ) enddo print * , close ( unit = 21 , iostat = ios ) if ( ios /= 0 ) stop \"Error closing file unit 21\" return end subroutine read_gmsh_file_1D subroutine write_out_solution ( num_nodes , xcoords , GlobalX ) integer , intent ( in ) :: num_nodes real ( wp ), intent ( in ), dimension (:) :: xcoords , GlobalX integer :: ii , ios open ( unit = 21 , file = 'data.out' , iostat = ios , status = \"replace\" , action = \"write\" ) if ( ios /= 0 ) stop \"Error opening file data.out\" do ii = 1 , num_nodes write ( 21 , * ) xcoords ( ii ), GlobalX ( ii ) enddo close ( unit = 21 , iostat = ios ) if ( ios /= 0 ) stop \"Error closing file unit data.out\" return end subroutine write_out_solution end module io","title":"io.f90 – learn_dg"},{"loc":"sourcefile/legendre.f90.html","tags":"","text":"This File Depends On sourcefile~~legendre.f90~~EfferentGraph sourcefile~legendre.f90 legendre.f90 sourcefile~integration.f90 integration.f90 sourcefile~integration.f90->sourcefile~legendre.f90 sourcefile~misc.f90 misc.f90 sourcefile~misc.f90->sourcefile~legendre.f90 sourcefile~linalg.f90 linalg.f90 sourcefile~linalg.f90->sourcefile~legendre.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files Dependent On This One sourcefile~~legendre.f90~~AfferentGraph sourcefile~legendre.f90 legendre.f90 sourcefile~doubleint.f90 doubleint.f90 sourcefile~legendre.f90->sourcefile~doubleint.f90 sourcefile~assembly.f90 assembly.f90 sourcefile~legendre.f90->sourcefile~assembly.f90 sourcefile~main.f90 main.f90 sourcefile~assembly.f90->sourcefile~main.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Modules legendre Source Code legendre.f90 Source Code module legendre use iso_fortran_env , only : wp => real64 use misc , only : r8mat_print use lib_array , only : linspace use integration , only : integrate , integrate2D use linalg , only : linsolve_quick , linsolve , inv2 , det2 , eye implicit none private :: basis_1D , vandermonde private :: integrate_basis_1d , integrate_basis_1d_Ie public :: getIe , assembleElementalMatrix , getxy contains !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!! Elemental Matrix Routines 1-D !!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! subroutine getIe ( dx1 , dx2 , xcoords , Ie ) integer , intent ( in ) :: dx1 , dx2 real ( wp ), intent ( in ), dimension (:) :: xcoords real ( wp ), intent ( out ), dimension (:,:) :: Ie integer :: ii , jj , order order = size ( xcoords ) - 1 do ii = 1 , size ( xcoords ) Ie ( ii , :) = [( integrate_basis_1d_Ie ( order , ii , jj , dx1 , dx2 , xcoords ), jj = 1 , order + 1 )] enddo return end subroutine getIe function integrate_basis_1d_Ie ( N , ii , jj , dx1 , dx2 , xcoords ) result ( integral ) integer , intent ( in ) :: N , ii , jj , dx1 , dx2 real ( wp ), intent ( in ), dimension (:) :: xcoords real ( wp ) :: integral integer :: order , basis_num1 , basis_num2 real ( wp ), dimension (:, :), allocatable :: Vinv order = N basis_num1 = ii basis_num2 = jj allocate ( Vinv ( order + 1 , order + 1 )) call vandermonde ( order + 1 , Vinv ) ! Check to make sure xcoords is an array of size (N+1) if ( size ( xcoords ) /= order + 1 ) then write ( * , * ) 'The shape of `xcoords` is outside the acceptable range for a' write ( * , * ) '1D basis function.' write ( * , * ) 'Shape(xcoords) should be [' , 2 , order + 1 , '], not ' , shape ( xcoords ) endif call integrate ( local_wrapper , - 1.0_wp , 1.0_wp , integral ) return contains subroutine XorJ ( s , dx , out ) integer , intent ( in ) :: dx real ( wp ), intent ( in ), dimension (:) :: s real ( wp ), intent ( out ), dimension (:) :: out integer :: ii out = 0.0_wp do ii = 1 , size ( xcoords ) out = out + basis_1D ( s , Vinv (:, ii ), dx ) * xcoords ( ii ) enddo end subroutine XorJ subroutine local_wrapper ( s , y ) real ( wp ), intent ( in ), dimension (:) :: s real ( wp ), intent ( out ), dimension (:) :: y real ( wp ), dimension (:), allocatable :: J allocate ( J ( size ( s ))) call XorJ ( s , 1 , J ) ! write(*,*) dx1, dx2 y = 1.0_wp ! Here we have to be careful because J is not always needed in the first ! two function calls. Instead of using if statements, we can use an exponent so that when dx_ == 0, J is 1 y = y * basis_1D ( s , Vinv (:, basis_num1 ), dx1 ) / ( J ** real ( dx1 , wp )) y = y * basis_1D ( s , Vinv (:, basis_num2 ), dx2 ) / ( J ** real ( dx2 , wp )) y = y * J deallocate ( J ) return end subroutine local_wrapper end function integrate_basis_1d_Ie function integrate_basis_1d ( order , basis_num , dx ) result ( integral ) integer , intent ( in ) :: order , basis_num , dx real ( wp ) :: integral real ( wp ), dimension (:, :), allocatable :: Vinv allocate ( Vinv ( order + 1 , order + 1 )) call vandermonde ( order + 1 , Vinv ) ! call r8mat_print(order+1, order+1, Vinv, 'Inverse Vandermonde') ! Check to make sure requested basis number is within available basis if ( basis_num > order + 1 ) then write ( * , * ) 'The basis_num input is larger than number of available basis nodes (order+1)' write ( * , * ) 'Make sure order and basis_num are correctly set before calling' stop endif ! Check to make sure differentiation is either 0 or 1 if ( dx < 0 . or . dx > 1 ) then write ( * , * ) 'Derivatives of order lower than 0 or higher than 1 are not allowed' write ( * , * ) 'integrate_basis_1d was called with dx = ' , dx write ( * , * ) 'Check to make sure that the function was called correctly' stop endif call integrate ( local_basis_1D , - 1.0_wp , 1.0_wp , integral ) deallocate ( Vinv ) return contains subroutine local_basis_1D ( x , y ) real ( wp ), intent ( in ), dimension (:) :: x real ( wp ), intent ( out ), dimension (:) :: y y = basis_1D ( x , Vinv (:, basis_num ), dx ) return end subroutine local_basis_1D end function integrate_basis_1d function basis_1D ( x , alpha , dx ) result ( y ) ! Input/output variables integer , intent ( in ) :: dx real ( wp ), intent ( in ), dimension (:) :: x real ( wp ), intent ( in ), dimension (:) :: alpha real ( wp ), dimension (:), allocatable :: y , yx ! Local variables integer :: ii , N allocate ( y ( size ( x )), yx ( size ( x ))) N = size ( alpha ) y = 0._wp do ii = 1 + dx , N if ( dx == 0 ) then yx = alpha ( ii ) * x ** real ( ii - 1 , wp ) else ! Hoping for the best that dx == 1 yx = real ( ii - 1 , wp ) * alpha ( ii ) * ( x ) ** ( real ( ii - 1 - dx , wp )) endif y = y + yx enddo return end function basis_1D subroutine vandermonde ( n , Vinv ) integer :: ii , jj integer :: n real ( wp ), dimension ( n ) :: x real ( wp ), dimension (( n ) ** 2 ) :: V_flat real ( wp ), dimension ( n , n ) :: V , Vinv , eye call linspace ( - 1._wp , 1._wp , x ) V_flat = [( [( [ x ( ii ) ** real ( jj - 1 , wp )], ii = 1 , n )], jj = 1 , n )] V = reshape ([ V_flat ], [ n , n ]) ! call r8mat_print(n, n, V, 'Original V Matrix: ') eye = 0._wp do ii = 1 , n eye ( ii , ii ) = 1._wp enddo call linsolve_quick ( n , V , n , eye , Vinv ) return end subroutine vandermonde !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!! Elemental Matrix Routines 2-D !!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! pure function getxy ( N ) result ( xy ) integer , intent ( in ) :: N real ( wp ), dimension ( N , 2 ) :: xy ! Keep a copy of 1/3 handy so no need to retype it all the time real ( wp ), parameter :: zero = 0._wp real ( wp ), parameter :: one = 1._wp real ( wp ), parameter :: third = 1._wp / 3._wp if ( N == 4 ) then xy (:, 1 ) = [ - one , one , one , - one ] ! Four corner nodes xy (:, 2 ) = [ - one , - one , one , one ] ! Four corner nodes elseif ( N == 9 ) then xy (:, 1 ) = [ - one , one , one , - one , & ! Four corner nodes & zero , one , zero , - one , & ! Four edge nodes & zero ] ! Center node xy (:, 2 ) = [ - one , - one , one , one , & ! Four corner nodes & - one , zero , one , zero , & ! Four edge nodes & zero ] ! Center node elseif ( N == 16 ) then xy (:, 1 ) = [ - one , one , one , - one , & ! Four corner nodes & - third , third , & ! Two edge nodes on each & one , one , & !     of the four edges & third , - third , & & - one , - one , & & - third , third , third , - third ] ! Four internal nodes xy (:, 2 ) = [ - one , - one , one , one , & ! Four corner nodes & - one , - one , & ! Two edge nodes on each & - third , third , & !     of the four edges & one , one , & & third , - third , & & - third , - third , third , third ] ! Four internal nodes endif return end function getxy pure function getArow ( N , xi , eta ) result ( row ) integer , intent ( in ) :: N real ( wp ), intent ( in ) :: xi , eta real ( wp ), dimension ( N ) :: row if ( N == 4 ) then row = [ 1._wp , & & xi , eta , & & xi * eta ] elseif ( N == 9 ) then row = [ 1._wp , & & xi , eta , & & xi ** 2._wp , xi * eta , eta ** 2._wp , & & xi ** 2._wp * eta , xi * eta ** 2._wp , & & xi ** 2._wp * eta ** 2._wp ] elseif ( N == 16 ) then row = [ 1._wp , & & xi , eta , & & xi ** 2._wp , xi * eta , eta ** 2._wp , & & xi ** 3._wp , xi ** 2._wp * eta , xi * eta ** 2._wp , eta ** 3._wp , & & xi ** 3._wp * eta , xi ** 2._wp * eta ** 2._wp , xi * eta ** 3._wp , & & xi ** 3._wp * eta ** 2._wp , xi ** 2._wp * eta ** 3._wp , & & xi ** 3._wp * eta ** 3._wp ] endif return end function getArow function getAlpha ( N ) result ( alpha ) integer , intent ( in ) :: N real ( wp ), dimension ( N , N ) :: alpha integer :: ii real ( wp ), dimension ( N , N ) :: A , B A = getA ( N ) B = eye ( N ) call linsolve_quick ( N , A , N , B , alpha ) return contains pure function getA ( N ) result ( A ) integer , intent ( in ) :: N real ( wp ), dimension ( N , N ) :: A integer :: ii real ( wp ), dimension ( N , 2 ) :: xy xy = getxy ( N ) do ii = 1 , N A ( ii ,:) = getArow ( N , xy ( ii , 1 ), xy ( ii , 2 )) enddo return end function getA end function getAlpha pure function getJacobian ( N , xi , eta , xy , alpha ) result ( J ) integer , intent ( in ) :: N real ( wp ), intent ( in ) :: xi , eta real ( wp ), dimension ( N , 2 ), intent ( in ) :: xy real ( wp ), dimension ( N , N ), intent ( in ) :: alpha real ( wp ), dimension ( 2 , 2 ) :: J integer :: ii real ( wp ), parameter :: eps = epsilon ( 0 e0 ) real ( wp ), dimension ( 2 , N ) :: P real ( wp ), dimension ( N ) :: x ! P is a matrix containing derivatives of each basis function at (xi,eta) ! P = [dN_1/dxi, dN_2/dxi, dN_3/dxi, ... !      dN_1/deta, dN_2/deta, dN_3/deta, ...] do ii = 1 , N x = alpha (:, ii ) P ( 1 , ii ) = dot_product ( x , getArow ( N , xi + eps , eta )) - & & dot_product ( x , getArow ( N , xi - eps , eta )) P ( 2 , ii ) = dot_product ( x , getArow ( N , xi , eta + eps )) - & & dot_product ( x , getArow ( N , xi , eta - eps )) enddo P = P / ( 2._wp * eps ) J = matmul ( P , xy ) return end function getJacobian function assembleElementalMatrix ( N , d1 , d2 , xy ) result ( Ie ) ! Dummy variables integer , intent ( in ) :: N , d1 , d2 real ( wp ), dimension ( N , 2 ), intent ( in ) :: xy real ( wp ), dimension ( N , N ) :: Ie ! Local variables integer :: N1 , N2 real ( wp ), dimension ( N , N ) :: alpha ! Get the coefficients of the basis functions (alpha). Both bi-linear (N=4) ! and bi-quadratic (N=9) quadrilaterals are supported. alpha = getAlpha ( N ) Ie = 0._wp do N1 = 1 , N do N2 = 1 , N ! fun is now implicitly defined using the following: N1, N2, d1, and d2 Ie ( N1 , N2 ) = Ie ( N1 , N2 ) + integrate2D ( fun ) enddo enddo contains function fun ( xi , eta ) result ( out ) ! Dummy variables real ( wp ), dimension (:,:), intent ( in ) :: xi , eta real ( wp ), dimension (:,:), allocatable :: out ! Local variables integer :: ii , jj , num_pts real ( wp ), parameter :: eps = epsilon ( 0 e0 ) real ( wp ) :: fun1 , fun2 real ( wp ), dimension ( 2 ) :: dfun1 , dfun2 real ( wp ) :: detJ real ( wp ), dimension ( 2 , 2 ) :: J , invJ ! Initialize function output. Actual number of pts is num_pts*num_pts, ! because the meshgrid goes in both x and y directions. Only need one. num_pts = size ( xi , 1 ) allocate ( out ( num_pts , num_pts )) out = 0._wp do ii = 1 , num_pts do jj = 1 , num_pts ! Calculate Jacobian, inverse Jacobian, and determinant of finite ! element at (xi,eta) J = getJacobian ( N , xi ( ii , jj ), eta ( ii , jj ), xy , alpha ) invJ = inv2 ( J ) detJ = det2 ( J ) ! If fun1 is just N_i, use dot_product to determine N_i if ( d1 == 0 ) then fun1 = dot_product ( alpha (:, N1 ), getArow ( N , xi ( ii , jj ), eta ( ii , jj ))) else ! If fun1 contains a derivative, need to calc N_i,xi and N_i,eta dfun1 ( 1 ) = ( & & dot_product ( alpha (:, N1 ), getArow ( N , xi ( ii , jj ) + eps , eta ( ii , jj ))) - & & dot_product ( alpha (:, N1 ), getArow ( N , xi ( ii , jj ) - eps , eta ( ii , jj ))) & & ) / ( 2._wp * eps ) dfun1 ( 2 ) = ( & & dot_product ( alpha (:, N1 ), getArow ( N , xi ( ii , jj ), eta ( ii , jj ) + eps )) - & & dot_product ( alpha (:, N1 ), getArow ( N , xi ( ii , jj ), eta ( ii , jj ) - eps )) & & ) / ( 2._wp * eps ) ! N_i,x = dxi/dx * N_i,xi + deta/dx * N_i,eta fun1 = dot_product ( invJ ( d1 ,:), dfun1 ) endif ! If fun2 is just N_i, use dot_product to determine N_i if ( d2 == 0 ) then fun2 = dot_product ( alpha (:, N2 ), getArow ( N , xi ( ii , jj ), eta ( ii , jj ))) else ! If fun2 contains a derivative, need to calc N_i,xi and N_i,eta dfun2 ( 1 ) = ( & & dot_product ( alpha (:, N2 ), & & getArow ( N , xi ( ii , jj ) + eps , eta ( ii , jj ))) - & & dot_product ( alpha (:, N2 ), & & getArow ( N , xi ( ii , jj ) - eps , eta ( ii , jj ))) & & ) / ( 2._wp * eps ) dfun2 ( 2 ) = ( & & dot_product ( alpha (:, N2 ), getArow ( N , xi ( ii , jj ), eta ( ii , jj ) + eps )) - & & dot_product ( alpha (:, N2 ), getArow ( N , xi ( ii , jj ), eta ( ii , jj ) - eps )) & & ) / ( 2._wp * eps ) ! N_i,y = dxi/dy * N_i,xi + deta/dy * N_i,eta fun2 = dot_product ( invJ ( d2 ,:), dfun2 ) endif out ( ii , jj ) = fun1 * fun2 * detJ enddo enddo return end function fun end function assembleElementalMatrix end module legendre","title":"legendre.f90 – learn_dg"},{"loc":"sourcefile/linalg.f90.html","tags":"","text":"Files Dependent On This One sourcefile~~linalg.f90~~AfferentGraph sourcefile~linalg.f90 linalg.f90 sourcefile~main.f90 main.f90 sourcefile~linalg.f90->sourcefile~main.f90 sourcefile~doubleint.f90 doubleint.f90 sourcefile~linalg.f90->sourcefile~doubleint.f90 sourcefile~legendre.f90 legendre.f90 sourcefile~linalg.f90->sourcefile~legendre.f90 sourcefile~legendre.f90->sourcefile~doubleint.f90 sourcefile~assembly.f90 assembly.f90 sourcefile~legendre.f90->sourcefile~assembly.f90 sourcefile~assembly.f90->sourcefile~main.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Modules linalg Source Code linalg.f90 Source Code module linalg use iso_fortran_env , only : wp => real64 implicit none public :: linsolve_quick , linsolve contains pure function eye ( N ) integer , intent ( in ) :: N real ( wp ), dimension ( N , N ) :: eye integer :: ii eye = 0._wp ; forall ( ii = 1 : N ) eye ( ii , ii ) = 1._wp return end function eye pure function inv2 ( J ) result ( invJ ) real ( wp ), dimension ( 2 , 2 ), intent ( in ) :: J real ( wp ), dimension ( 2 , 2 ) :: invJ invJ = reshape ( [ J ( 2 , 2 ), - J ( 2 , 1 ), - J ( 1 , 2 ), J ( 1 , 1 )], [ 2 , 2 ] ) invJ = invJ / det2 ( J ) return end function inv2 pure function det2 ( A ) result ( det ) ! Computes the determinant of a 2x2 matrix real ( wp ), dimension ( 2 , 2 ), intent ( in ) :: A real ( wp ) :: det det = A ( 1 , 1 ) * A ( 2 , 2 ) - A ( 1 , 2 ) * A ( 2 , 1 ) return end function det2 subroutine linsolve_quick ( n , a , nrhs , b , x ) ! Quick wrapper around linsolve integer , intent ( in ) :: n , nrhs real ( wp ), intent ( in ), dimension ( n , n ) :: a real ( wp ), intent ( in ), dimension ( n , nrhs ) :: b real ( wp ), intent ( out ), dimension ( n , nrhs ) :: x integer , dimension ( n ) :: P real ( wp ), dimension ( n , n ) :: LU call linsolve ( n , a , nrhs , b , x , LU , P , . False .) return end subroutine linsolve_quick subroutine linsolve ( n , a , nrhs , b , x , LU , P , toggle ) ! This routine is a wrapper dgesv, splitting it into its two primary ! components: !             dgetrf - Decomposes A into P*L*U !             dgetrs - Uses P*L*U to solve for x (Ax=b => (P*L*U)x=b) ! ! Splitting these two up like this allows you to save the decomposed ! version of 'a' so that you don't have to do it again. If 'toggle' is ! equal to true, then the decomposition has already occured and LU can be ! trusted - OK to skip dgetrf ! Dummy variables integer , intent ( in ) :: n , nrhs integer , intent ( inout ), dimension ( n ) :: P real ( wp ), intent ( in ), dimension ( n , nrhs ) :: b real ( wp ), intent ( in ), dimension ( n , n ) :: a real ( wp ), intent ( out ), dimension ( n , nrhs ) :: x real ( wp ), intent ( inout ), dimension ( n , n ) :: LU logical , intent ( in ) :: toggle ! Local variables integer :: info integer , dimension ( n ) :: my_P real ( wp ), dimension ( n , n ) :: my_a real ( wp ), dimension ( n , nrhs ) :: my_b my_a = a my_b = b if ( . not . toggle ) then call dgetrf ( n , n , my_a , n , my_P , info ) if ( info /= 0 ) then write ( * , '(a)' ) ' ' write ( * , '(a)' ) 'DGETRF' write ( * , '(a,i8)' ) '  Factorization failed, INFO = ' , info stop endif LU = my_a P = my_P endif call dgetrs ( 'No transpose' , n , nrhs , LU , n , P , my_b , n , info ) if ( info /= 0 ) then write ( * , '(a)' ) ' ' write ( * , '(a)' ) 'DGETRS' write ( * , '(a,i8)' ) '  Back substitution failed, INFO = ' , info stop endif x = my_b return end subroutine linsolve end module linalg","title":"linalg.f90 – learn_dg"},{"loc":"sourcefile/main.f90.html","tags":"","text":"This File Depends On sourcefile~~main.f90~~EfferentGraph sourcefile~main.f90 main.f90 sourcefile~misc.f90 misc.f90 sourcefile~misc.f90->sourcefile~main.f90 sourcefile~legendre.f90 legendre.f90 sourcefile~misc.f90->sourcefile~legendre.f90 sourcefile~io.f90 io.f90 sourcefile~io.f90->sourcefile~main.f90 sourcefile~linalg.f90 linalg.f90 sourcefile~linalg.f90->sourcefile~main.f90 sourcefile~linalg.f90->sourcefile~legendre.f90 sourcefile~assembly.f90 assembly.f90 sourcefile~assembly.f90->sourcefile~main.f90 sourcefile~legendre.f90->sourcefile~assembly.f90 sourcefile~integration.f90 integration.f90 sourcefile~integration.f90->sourcefile~legendre.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Programs main Source Code main.f90 Source Code program main use iso_fortran_env , only : wp => real64 use linalg , only : linsolve_quick use misc , only : r8mat_print use io , only : get_command_argument_wrapper , & & read_gmsh_file_1D , & & write_out_solution use assembly , only : initialize_global_mats , assemble , set_BCs implicit none real ( wp ), parameter :: diff = 0.1_wp , vel = - 5._wp integer :: num_nodes integer , dimension (:), allocatable :: order , nodes2vertex integer , dimension (:,:), allocatable :: elem_conn real ( wp ), dimension (:), allocatable :: xcoords , GlobalB , GlobalX real ( wp ), dimension (:,:), allocatable :: GlobalA logical :: dg ! dg = .true. dg = . false . call read_gmsh_file_1D ( num_nodes , order , nodes2vertex , elem_conn , xcoords , dg ) ! stop call initialize_global_mats ( num_nodes , GlobalA , GlobalB , GlobalX , xcoords ) call assemble ( order , xcoords , elem_conn , GlobalA , diff , vel ) call set_BCs ( xcoords , GlobalB , GlobalA ) ! call r8mat_print(num_nodes, num_nodes, GlobalA, 'Global Stiffness matrix:') ! stop call linsolve_quick ( num_nodes , GlobalA , 1 , GlobalB , GlobalX ) ! call r8mat_print(num_nodes, 1, GlobalB, 'Global RHS:') ! call r8mat_print(num_nodes, 1, GlobalX, 'Global Solution Vector:') call write_out_solution ( num_nodes , xcoords , GlobalX ) end program main","title":"main.f90 – learn_dg"},{"loc":"sourcefile/misc.f90.html","tags":"","text":"Files Dependent On This One sourcefile~~misc.f90~~AfferentGraph sourcefile~misc.f90 misc.f90 sourcefile~main.f90 main.f90 sourcefile~misc.f90->sourcefile~main.f90 sourcefile~doubleint.f90 doubleint.f90 sourcefile~misc.f90->sourcefile~doubleint.f90 sourcefile~legendre.f90 legendre.f90 sourcefile~misc.f90->sourcefile~legendre.f90 sourcefile~legendre.f90->sourcefile~doubleint.f90 sourcefile~assembly.f90 assembly.f90 sourcefile~legendre.f90->sourcefile~assembly.f90 sourcefile~assembly.f90->sourcefile~main.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Modules misc Source Code misc.f90 Source Code module misc use iso_fortran_env , only : wp => real64 implicit none ! abstract interface !   pure function func1(xx) result(yy) !     import wp !     real(wp), intent(in), dimension(:):: xx !     real(wp), dimension(:), allocatable:: yy !   end function func1 ! !   pure function func2(xx, aa) result(yy) !     import wp !     real(wp), intent(in), dimension(:):: xx, aa !     real(wp), dimension(:), allocatable:: yy !   end function func2 ! end interface contains subroutine r8mat_print ( m , n , a , title ) !*****************************************************************************80 ! !! R8MAT_PRINT prints an R8MAT. ! !  Discussion: ! !    An R8MAT is a two dimensional matrix of double precision real values. ! !  Licensing: ! !    This code is distributed under the GNU LGPL license. ! !  Modified: ! !    12 September 2004 ! !  Author: ! !    John Burkardt ! !  Parameters: ! !    Input, integer M, the number of rows in A. ! !    Input, integer N, the number of columns in A. ! !    Input, real ( kind = 8 ) A(M,N), the matrix. ! !    Input, character ( len = * ) TITLE, a title to be printed. ! implicit none integer ( kind = 4 ) m integer ( kind = 4 ) n real ( kind = 8 ) a ( m , n ) character ( len = * ) title call r8mat_print_some ( m , n , a , 1 , 1 , m , n , title ) return end subroutine r8mat_print subroutine r8mat_print_some ( m , n , a , ilo , jlo , ihi , jhi , title ) !*****************************************************************************80 ! !! R8MAT_PRINT_SOME prints some of an R8MAT. ! !  Discussion: ! !    An R8MAT is a two dimensional matrix of double precision real values. ! !  Licensing: ! !    This code is distributed under the GNU LGPL license. ! !  Modified: ! !    26 March 2005 ! !  Author: ! !    John Burkardt ! !  Parameters: ! !    Input, integer M, N, the number of rows and columns. ! !    Input, real ( kind = 8 ) A(M,N), an M by N matrix to be printed. ! !    Input, integer ILO, JLO, the first row and column to print. ! !    Input, integer IHI, JHI, the last row and column to print. ! !    Input, character ( len = * ) TITLE, an optional title. ! implicit none integer ( kind = 4 ), parameter :: incx = 5 integer ( kind = 4 ) m integer ( kind = 4 ) n real ( kind = 8 ) a ( m , n ) character ( len = 14 ) ctemp ( incx ) integer ( kind = 4 ) i integer ( kind = 4 ) i2hi integer ( kind = 4 ) i2lo integer ( kind = 4 ) ihi integer ( kind = 4 ) ilo integer ( kind = 4 ) inc integer ( kind = 4 ) j integer ( kind = 4 ) j2 integer ( kind = 4 ) j2hi integer ( kind = 4 ) j2lo integer ( kind = 4 ) jhi integer ( kind = 4 ) jlo character ( len = * ) title if ( 0 < len_trim ( title ) ) then write ( * , '(a)' ) ' ' write ( * , '(a)' ) trim ( title ) endif do j2lo = max ( jlo , 1 ), min ( jhi , n ), incx j2hi = j2lo + incx - 1 j2hi = min ( j2hi , n ) j2hi = min ( j2hi , jhi ) inc = j2hi + 1 - j2lo write ( * , '(a)' ) ' ' do j = j2lo , j2hi j2 = j + 1 - j2lo write ( ctemp ( j2 ), '(i8,6x)' ) j enddo write ( * , '(''  Col   '',5a14)' ) ctemp ( 1 : inc ) write ( * , '(a)' ) '  Row' write ( * , '(a)' ) ' ' i2lo = max ( ilo , 1 ) i2hi = min ( ihi , m ) do i = i2lo , i2hi do j2 = 1 , inc j = j2lo - 1 + j2 if ( a ( i , j ) == real ( int ( a ( i , j ) ), kind = 8 ) ) then write ( ctemp ( j2 ), '(f8.0,6x)' ) a ( i , j ) else write ( ctemp ( j2 ), '(g14.6)' ) a ( i , j ) endif enddo write ( * , '(i5,1x,5a14)' ) i , ( ctemp ( j ), j = 1 , inc ) enddo enddo write ( * , '(a)' ) ' ' return end subroutine r8mat_print_some end module misc","title":"misc.f90 – learn_dg"},{"loc":"proc/assemble.html","tags":"","text":"public subroutine assemble(order, xcoords, elem_conn, GlobalA, diff, vel) Arguments Type Intent Optional Attributes Name integer, intent(in), dimension(:) :: order real(kind=wp), intent(in), dimension(:) :: xcoords integer, intent(in), dimension(:,:) :: elem_conn real(kind=wp), intent(out), dimension(:,:) :: GlobalA real(kind=wp), intent(in) :: diff real(kind=wp), intent(in) :: vel Calls proc~~assemble~~CallsGraph proc~assemble assemble getie getie proc~assemble->getie Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called By proc~~assemble~~CalledByGraph proc~assemble assemble program~main main program~main->proc~assemble Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code assemble Source Code subroutine assemble ( order , xcoords , elem_conn , GlobalA , diff , vel ) integer , intent ( in ), dimension (:) :: order integer , intent ( in ), dimension (:,:) :: elem_conn real ( wp ), intent ( in ) :: diff , vel real ( wp ), intent ( in ), dimension (:) :: xcoords real ( wp ), intent ( out ), dimension (:,:) :: GlobalA integer :: ii real ( wp ), dimension (:,:), allocatable :: Ie ! Add elemental stiffness matrices to Global Stiffness Matrix do ii = 1 , size ( order ) ! Reallocate elemental stiffness matrix allocate ( Ie ( order ( ii ) + 1 , order ( ii ) + 1 )) call getIe ( 1 , 1 , xcoords ( elem_conn ( ii ,:)), Ie ) ! call r8mat_print(order(ii)+1, order(ii)+1, Ie, 'Elemental Stiffness Matrix:') GlobalA ( elem_conn ( ii ,:), elem_conn ( ii ,:)) = & GlobalA ( elem_conn ( ii ,:), elem_conn ( ii ,:)) - diff * Ie call getIe ( 0 , 1 , xcoords ( elem_conn ( ii ,:)), Ie ) ! call r8mat_print(order(ii)+1, order(ii)+1, Ie, 'Elemental Stiffness Matrix:') GlobalA ( elem_conn ( ii ,:), elem_conn ( ii ,:)) = & GlobalA ( elem_conn ( ii ,:), elem_conn ( ii ,:)) - vel * Ie ! Deallocate elemental stiffness matrix after every loop deallocate ( Ie ) ! stop enddo ! call r8mat_print(num_nodes, num_nodes, GlobalA, 'Global Stiffness Matrix:') ! stop return end subroutine assemble","title":"assemble – learn_dg"},{"loc":"proc/initialize_global_mats.html","tags":"","text":"public subroutine initialize_global_mats(num_nodes, GlobalA, GlobalB, GlobalX, xcoords) Arguments Type Intent Optional Attributes Name integer, intent(in) :: num_nodes real(kind=wp), intent(out), dimension(:,:), allocatable :: GlobalA real(kind=wp), intent(out), dimension(:), allocatable :: GlobalB real(kind=wp), intent(out), dimension(:), allocatable :: GlobalX real(kind=wp), intent(in), dimension(:) :: xcoords Called By proc~~initialize_global_mats~~CalledByGraph proc~initialize_global_mats initialize_global_mats program~main main program~main->proc~initialize_global_mats Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code initialize_global_mats Source Code subroutine initialize_global_mats ( num_nodes , & & GlobalA , & & GlobalB , & & GlobalX , & & xcoords ) integer , intent ( in ) :: num_nodes real ( wp ), intent ( out ), dimension (:), allocatable :: GlobalB , GlobalX real ( wp ), intent ( out ), dimension (:,:), allocatable :: GlobalA real ( wp ), intent ( in ), dimension (:) :: xcoords allocate ( GlobalA ( num_nodes , num_nodes )) allocate ( GlobalB ( num_nodes )) allocate ( GlobalX ( num_nodes )) ! Intial Conditions GlobalA (:,:) = 0._wp GlobalX (:) = 0._wp return end subroutine initialize_global_mats","title":"initialize_global_mats – learn_dg"},{"loc":"proc/set_bcs.html","tags":"","text":"public subroutine set_BCs(xcoords, GlobalB, GlobalA) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: xcoords real(kind=wp), intent(out), dimension(:) :: GlobalB real(kind=wp), intent(out), dimension(:,:) :: GlobalA Source Code set_BCs Source Code subroutine set_BCs ( xcoords , GlobalB , GlobalA ) real ( wp ), intent ( in ), dimension (:) :: xcoords real ( wp ), intent ( out ), dimension (:) :: GlobalB real ( wp ), intent ( out ), dimension (:,:) :: GlobalA integer , dimension ( 1 ) :: iloc iloc = minloc ( xcoords ) GlobalA ( iloc ,:) = 0._wp GlobalA ( iloc , iloc ) = 1._wp iloc = maxloc ( xcoords ) GlobalA ( iloc ,:) = 0._wp GlobalA ( iloc , iloc ) = 1._wp ! Left Boundary Dirchlet BC GlobalB (:) = 0._wp ! Right Boundary Dirchlet BC GlobalB ( maxloc ( xcoords )) = 1._wp ! call r8mat_print(num_nodes, 1, GlobalB, 'Global RHS:') ! stop return end subroutine set_BCs","title":"set_BCs – learn_dg"},{"loc":"proc/integrate2d.html","tags":"","text":"public function integrate2D(fun) result(out) Arguments Type Intent Optional Attributes Name procedure( fun2d_interf ) :: fun Return Value real(kind=wp) Calls proc~~integrate2d~~CallsGraph proc~integrate2d integrate2D proc~gaussquad_wrapper gaussquad_wrapper proc~integrate2d->proc~gaussquad_wrapper proc~gaussquad gaussquad proc~gaussquad_wrapper->proc~gaussquad Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs.","title":"integrate2D – learn_dg"},{"loc":"proc/cgwt.html","tags":"","text":"private subroutine cgwt(num_pts, x, w) Arguments Type Intent Optional Attributes Name integer, intent(in) :: num_pts real(kind=wp), intent(out), dimension(:) :: x real(kind=wp), intent(out), dimension(:) :: w Calls proc~~cgwt~~CallsGraph proc~cgwt cgwt dcos dcos proc~cgwt->dcos Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code cgwt Source Code subroutine cgwt ( num_pts , x , w ) ! This function  determines the points and weights associated with Chebyshev-Gauss quadrature ! Variables in/out integer , intent ( in ) :: num_pts real ( wp ), intent ( out ), dimension (:) :: x , w ! Local variables integer :: ii real ( wp ), parameter :: pi = 4._wp * datan ( 1._wp ) x = dcos ( ( real ( 2 * [( ii , ii = 1 , num_pts )] - 1 , wp ) ) / real ( 2 * num_pts , wp ) * pi ) w = pi / real ( num_pts , wp ) / (( 1.0_wp - x ** 2._wp ) ** ( - 0.5_wp )) ! write(*,*) x ! write(*,*) w ! stop return end subroutine cgwt","title":"cgwt – learn_dg"},{"loc":"proc/gaussquad.html","tags":"","text":"private subroutine gaussquad(n, r1, r2) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=wp), intent(out) :: r1 (n) real(kind=wp), intent(out) :: r2 (n) Called By proc~~gaussquad~~CalledByGraph proc~gaussquad gaussquad proc~gaussquad_wrapper gaussquad_wrapper proc~gaussquad_wrapper->proc~gaussquad proc~integrate integrate proc~integrate->proc~gaussquad proc~integrate2d integrate2D proc~integrate2d->proc~gaussquad_wrapper proc~integrate_basis_1d_ie integrate_basis_1d_Ie proc~integrate_basis_1d_ie->proc~integrate proc~integrate_basis_1d integrate_basis_1d proc~integrate_basis_1d->proc~integrate proc~getie getIe proc~getie->proc~integrate_basis_1d_ie Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs.","title":"gaussquad – learn_dg"},{"loc":"proc/gaussquad_wrapper.html","tags":"","text":"public subroutine gaussquad_wrapper(N, x, w) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N real(kind=wp), intent(out), dimension(N) :: x real(kind=wp), intent(out), dimension(N) :: w Calls proc~~gaussquad_wrapper~~CallsGraph proc~gaussquad_wrapper gaussquad_wrapper proc~gaussquad gaussquad proc~gaussquad_wrapper->proc~gaussquad Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called By proc~~gaussquad_wrapper~~CalledByGraph proc~gaussquad_wrapper gaussquad_wrapper proc~integrate2d integrate2D proc~integrate2d->proc~gaussquad_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code gaussquad_wrapper Source Code subroutine gaussquad_wrapper ( N , x , w ) integer , intent ( in ) :: N real ( wp ), intent ( out ), dimension ( N ) :: x , w select case ( N ) case ( 1 ) x = [ 0._wp ] w = [ 2._wp ] case ( 2 ) x = [ - 0.5773502691896257_wp , & & 0.5773502691896257_wp ] w = [ 1._wp , & & 1._wp ] case ( 3 ) x = [ - 0.7745966692414834_wp , & & 0._wp , & & 0.7745966692414834_wp ] w = [ 0.5555555555555556_wp , & & 0.8888888888888888_wp , & & 0.5555555555555556_wp ] case ( 4 ) x = [ - 0.8611363115940526_wp , & & - 0.3399810435848563_wp , & & 0.3399810435848563_wp , & & 0.8611363115940526_wp ] w = [ 0.3478548451374538_wp , & & 0.6521451548625461_wp , & & 0.6521451548625461_wp , & & 0.3478548451374538_wp ] case ( 5 ) x = [ - 0.9061798459386640_wp , & & - 0.5384693101056831_wp , & & 0._wp , & & 0.5384693101056831_wp , & & 0.9061798459386640_wp ] w = [ 0.2369268850561891_wp , & & 0.4786286704993665_wp , & & 0.5688888888888889_wp , & & 0.4786286704993665_wp , & & 0.2369268850561891_wp ] case default ! call lgwt(-1._wp, 1._wp, N, x, w) ! call cgwt(N, x, w) call gaussquad ( N , x , w ) end select return end subroutine gaussquad_wrapper","title":"gaussquad_wrapper – learn_dg"},{"loc":"proc/integrate.html","tags":"","text":"public subroutine integrate(sub, a, b, result) Arguments Type Intent Optional Attributes Name public subroutine sub(xx, yy) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: xx real(kind=wp), intent(out), dimension(:) :: yy real(kind=wp), intent(in) :: a real(kind=wp), intent(in) :: b real(kind=wp), intent(out) :: result Calls proc~~integrate~~CallsGraph proc~integrate integrate proc~gaussquad gaussquad proc~integrate->proc~gaussquad Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called By proc~~integrate~~CalledByGraph proc~integrate integrate proc~integrate_basis_1d_ie integrate_basis_1d_Ie proc~integrate_basis_1d_ie->proc~integrate proc~integrate_basis_1d integrate_basis_1d proc~integrate_basis_1d->proc~integrate proc~getie getIe proc~getie->proc~integrate_basis_1d_ie Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code integrate Source Code subroutine integrate ( sub , a , b , result ) ! This routine uses gauss-legendre quadrature to integrate a 1D function ! Input/Output variables real ( wp ), intent ( in ) :: a , b real ( wp ), intent ( out ) :: result interface subroutine sub ( xx , yy ) import wp real ( wp ), intent ( in ), dimension (:) :: xx real ( wp ), intent ( out ), dimension (:) :: yy end subroutine sub end interface ! Local variables integer :: N real ( wp ) :: result_old , error real ( wp ), parameter :: eps = sqrt ( epsilon ( 1.0_wp )) real ( wp ), dimension (:), allocatable :: x , w , y N = 3 result = 0.0_wp error = 1.0_wp do result_old = result allocate ( x ( N ), w ( N ), y ( N )) ! call cgwt(N, x, w) ! call lgwt(a, b, N, x, w) call gaussquad ( N , x , w ) call sub ( x , y ) result = sum ( y * w ) deallocate ( x , w , y ) ! error = norm2([result, result_old]) error = sqrt (( result - result_old ) ** 2.0_wp ) ! error = abs((result-result_old)/(result_old+eps)) ! write(*,*) N, result, error ! write(*,*) N, result, result_old, error, eps ! Check if error is acceptable, as well as whether the loop was gone ! through at least twice (N = 3, 4, 5...) if ( ( error < eps . or . abs ( result ) < eps ) & . and . N > 5 ) then exit else N = N + 1 endif enddo return end subroutine integrate","title":"integrate – learn_dg"},{"loc":"proc/lgwt.html","tags":"","text":"private subroutine lgwt(a, b, num_pts, x, w) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a real(kind=wp), intent(in) :: b integer, intent(in) :: num_pts real(kind=wp), intent(out), dimension(:) :: x real(kind=wp), intent(out), dimension(:) :: w Calls proc~~lgwt~~CallsGraph proc~lgwt lgwt linspace linspace proc~lgwt->linspace dcos dcos proc~lgwt->dcos dsin dsin proc~lgwt->dsin Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code lgwt Source Code subroutine lgwt ( a , b , num_pts , x , w ) ! This function is a fortran90 port of the matlab function, lgwt.m ! The source code of lgwt.m was originally found at: ! ! http://www.mathworks.com/matlabcentral/fileexchange/4540 ! Variables in/out integer , intent ( in ) :: num_pts real ( wp ), intent ( in ) :: a , b real ( wp ), intent ( out ), dimension (:) :: x , w ! Local variables integer :: ii , jj , N , N1 , N2 ! real(wp), parameter:: eps=sqrt(epsilon(1.0_wp)) real ( wp ), parameter :: eps = 1 d - 10 real ( wp ), dimension (:), allocatable :: xu , array1 , y , y0 , Lpp real ( wp ), dimension (:, :), allocatable :: L , Lp real ( wp ), parameter :: pi = 4.0_wp * datan ( 1.0_wp ) N = num_pts - 1 N1 = N + 1 N2 = N + 2 ! Allocate and initialize arrays allocate ( xu ( N1 ), array1 ( N1 ), y ( N1 ), y0 ( N1 )) allocate ( L ( N1 , N2 ), Lp ( N1 , N2 ), Lpp ( N1 )) L = 0.0_wp Lp = 0.0_wp call linspace ( - 1.0_wp , 1.0_wp , xu ) array1 = [ ( ii , ii = 0 , N ) ] ! Initial guess of ??? y = dcos (( 2.0_wp * real ( array1 , wp ) + 1.0_wp ) * & pi / ( 2.0_wp * real ( N , wp ) + 2.0_wp )) + & ( 0.27_wp / real ( N1 , wp )) * dsin ( pi * xu * real ( N , wp ) / real ( N2 , wp )) y0 = 2.0_wp do L (:, 1 ) = 1.0_wp Lp (:, 1 ) = 0.0_wp L (:, 2 ) = y Lp (:, 2 ) = 1.0_wp do jj = 2 , N1 L (:, jj + 1 ) = ( ( 2.0_wp * real ( jj , wp ) - 1.0_wp ) * y * L (:, jj ) - & real ( jj - 1 , wp ) * L (:, jj - 1 )) / real ( jj , wp ) enddo Lpp = real ( N2 , wp ) * ( L (:, N1 ) - y * L (:, N2 )) / ( 1.0_wp - y ** 2.0_wp ) y0 = y y = y0 - L (:, N2 ) / Lpp if ( norm2 ( y - y0 ) < eps ) then exit endif enddo x = ( a * ( 1.0_wp - y ) + b * ( 1.0_wp + y ) ) / 2.0_wp w = ( b - a ) / (( 1.0_wp - y ** 2.0_wp ) * Lpp ** 2.0_wp ) * & ( real ( N2 , wp ) / real ( N1 , wp )) ** 2.0_wp return end subroutine lgwt","title":"lgwt – learn_dg"},{"loc":"interface/fun2d_interf.html","tags":"","text":"interface public function fun2d_interf(x, y) result(z) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:,:) :: x real(kind=wp), intent(in), dimension(:,:) :: y Return Value real(kind=wp),\n  dimension(:,:),allocatable","title":"fun2d_interf – learn_dg"},{"loc":"proc/get_command_argument_wrapper.html","tags":"","text":"public subroutine get_command_argument_wrapper(arg) Arguments Type Intent Optional Attributes Name character(len=*), intent(out) :: arg Called By proc~~get_command_argument_wrapper~~CalledByGraph proc~get_command_argument_wrapper get_command_argument_wrapper proc~read_gmsh_file_1d read_gmsh_file_1D proc~read_gmsh_file_1d->proc~get_command_argument_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code get_command_argument_wrapper Source Code subroutine get_command_argument_wrapper ( arg ) character ( * ), intent ( out ) :: arg integer :: ii ii = 1 do call get_command_argument ( ii , arg ) if ( len_trim ( arg ) == 0 ) then arg = trim ( arg ) else exit endif ii = ii + 1 enddo return end subroutine get_command_argument_wrapper","title":"get_command_argument_wrapper – learn_dg"},{"loc":"proc/read_gmsh_file_1d.html","tags":"","text":"public subroutine read_gmsh_file_1D(num_nodes, order, nodes2vertex, elem_conn, xcoords, dg) Arguments Type Intent Optional Attributes Name integer, intent(out) :: num_nodes integer, intent(out), dimension(:), allocatable :: order integer, intent(out), dimension(:), allocatable :: nodes2vertex integer, intent(out), dimension(:,:), allocatable :: elem_conn real(kind=wp), intent(out), dimension(:), allocatable :: xcoords logical, intent(in) :: dg Calls proc~~read_gmsh_file_1d~~CallsGraph proc~read_gmsh_file_1d read_gmsh_file_1D proc~get_command_argument_wrapper get_command_argument_wrapper proc~read_gmsh_file_1d->proc~get_command_argument_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code read_gmsh_file_1D Source Code subroutine read_gmsh_file_1D ( num_nodes , & & order , & & nodes2vertex , & & elem_conn , & & xcoords , & & dg ) integer , intent ( out ) :: num_nodes integer , intent ( out ), dimension (:), allocatable :: order , nodes2vertex integer , intent ( out ), dimension (:,:), allocatable :: elem_conn real ( wp ), intent ( out ), dimension (:), allocatable :: xcoords logical , intent ( in ) :: dg integer :: ii , ios , vertex , num_elements , num_vertexes , d_int integer , dimension ( 2 ) :: iloc integer , dimension (:,:), allocatable :: vertex_conn real ( wp ) :: d_real character ( 50 ) :: filename character ( 50 ) :: blank_string call get_command_argument_wrapper ( filename ) ! print*, filename open ( unit = 21 , file = filename , iostat = ios , status = \"old\" , action = \"read\" ) if ( ios /= 0 ) stop \"Error opening file \" ! Read initial header information - assuming file is in the correct format do read ( 21 , * ) blank_string if ( trim ( blank_string ) == '$Nodes' ) exit enddo ! Read number of nodes read ( 21 , * ) num_vertexes allocate ( xcoords ( num_vertexes )) if ( . not . dg ) then num_nodes = num_vertexes else num_nodes = 2 * num_vertexes - 2 endif ! Read coordinate information for each vertex do ii = 1 , num_vertexes read ( 21 , * ) d_int , xcoords ( ii ), d_real , d_real enddo allocate ( nodes2vertex ( num_nodes )) nodes2vertex = 0 if ( dg ) then vertex = 1 do ii = 1 , num_nodes nodes2vertex ( ii ) = vertex if ( ii == 1 . or . ii == num_nodes ) then vertex = vertex + 1 elseif ( mod ( ii , 2 ) == 0 ) then vertex = vertex + 1 endif enddo else nodes2vertex = [( ii , ii = 1 , num_nodes )] endif do ii = 1 , num_nodes print * , ii , nodes2vertex ( ii ), xcoords ( nodes2vertex ( ii )) enddo print * , ! stop ! Two dummy lines : !   $EndNodes !   $Elements read ( 21 , * ) read ( 21 , * ) read ( 21 , * ) num_elements num_elements = num_elements - 2 allocate ( order ( num_elements )) allocate ( elem_conn ( num_elements , 2 )) allocate ( vertex_conn ( num_elements , 2 )) ! Initialize all elements as first order linear elements order = 1 ! Two dummy lines - Associated with 'point' elements read ( 21 , * ) read ( 21 , * ) do ii = 1 , num_elements read ( 21 , * ) d_int , d_int , d_int , d_int , d_int , vertex_conn ( ii , 1 : 2 ) ! print*, pack(vertex_conn, vertex_conn == nodes2vertex) enddo ! print*, pack([( ii, ii = 1, num_nodes )], & !       & nodes2vertex == nodes2vertex(3) & !       & .or. nodes2vertex == nodes2vertex(5)) ! stop if ( . not . dg ) then elem_conn = vertex_conn else do ii = 1 , num_elements ! elem_conn(ii,:) = pack([( ii, ii = 1, num_nodes )], & ! & nodes2vertex == vertex_conn(ii,1)) ! print*, loc(2._wp) ! print*, loc(nodes2vertex == vertex_conn(ii,2)) print * , order ( ii ), vertex_conn ( ii ,:), elem_conn ( ii ,:) print * , enddo endif print * , do ii = 1 , size ( xcoords ) print * , xcoords ( ii ) enddo print * , close ( unit = 21 , iostat = ios ) if ( ios /= 0 ) stop \"Error closing file unit 21\" return end subroutine read_gmsh_file_1D","title":"read_gmsh_file_1D – learn_dg"},{"loc":"proc/write_out_solution.html","tags":"","text":"public subroutine write_out_solution(num_nodes, xcoords, GlobalX) Arguments Type Intent Optional Attributes Name integer, intent(in) :: num_nodes real(kind=wp), intent(in), dimension(:) :: xcoords real(kind=wp), intent(in), dimension(:) :: GlobalX Called By proc~~write_out_solution~~CalledByGraph proc~write_out_solution write_out_solution program~main main program~main->proc~write_out_solution Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code write_out_solution Source Code subroutine write_out_solution ( num_nodes , xcoords , GlobalX ) integer , intent ( in ) :: num_nodes real ( wp ), intent ( in ), dimension (:) :: xcoords , GlobalX integer :: ii , ios open ( unit = 21 , file = 'data.out' , iostat = ios , status = \"replace\" , action = \"write\" ) if ( ios /= 0 ) stop \"Error opening file data.out\" do ii = 1 , num_nodes write ( 21 , * ) xcoords ( ii ), GlobalX ( ii ) enddo close ( unit = 21 , iostat = ios ) if ( ios /= 0 ) stop \"Error closing file unit data.out\" return end subroutine write_out_solution","title":"write_out_solution – learn_dg"},{"loc":"proc/assembleelementalmatrix.html","tags":"","text":"public function assembleElementalMatrix(N, d1, d2, xy) result(Ie) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N integer, intent(in) :: d1 integer, intent(in) :: d2 real(kind=wp), intent(in), dimension(N,2) :: xy Return Value real(kind=wp),\n  dimension(N,N) Calls proc~~assembleelementalmatrix~~CallsGraph proc~assembleelementalmatrix assembleElementalMatrix integrate2d integrate2d proc~assembleelementalmatrix->integrate2d proc~getalpha getAlpha proc~assembleelementalmatrix->proc~getalpha proc~eye eye proc~getalpha->proc~eye proc~linsolve_quick linsolve_quick proc~getalpha->proc~linsolve_quick proc~linsolve linsolve proc~linsolve_quick->proc~linsolve dgetrs dgetrs proc~linsolve->dgetrs dgetrf dgetrf proc~linsolve->dgetrf Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code assembleElementalMatrix Source Code function assembleElementalMatrix ( N , d1 , d2 , xy ) result ( Ie ) ! Dummy variables integer , intent ( in ) :: N , d1 , d2 real ( wp ), dimension ( N , 2 ), intent ( in ) :: xy real ( wp ), dimension ( N , N ) :: Ie ! Local variables integer :: N1 , N2 real ( wp ), dimension ( N , N ) :: alpha ! Get the coefficients of the basis functions (alpha). Both bi-linear (N=4) ! and bi-quadratic (N=9) quadrilaterals are supported. alpha = getAlpha ( N ) Ie = 0._wp do N1 = 1 , N do N2 = 1 , N ! fun is now implicitly defined using the following: N1, N2, d1, and d2 Ie ( N1 , N2 ) = Ie ( N1 , N2 ) + integrate2D ( fun ) enddo enddo contains function fun ( xi , eta ) result ( out ) ! Dummy variables real ( wp ), dimension (:,:), intent ( in ) :: xi , eta real ( wp ), dimension (:,:), allocatable :: out ! Local variables integer :: ii , jj , num_pts real ( wp ), parameter :: eps = epsilon ( 0 e0 ) real ( wp ) :: fun1 , fun2 real ( wp ), dimension ( 2 ) :: dfun1 , dfun2 real ( wp ) :: detJ real ( wp ), dimension ( 2 , 2 ) :: J , invJ ! Initialize function output. Actual number of pts is num_pts*num_pts, ! because the meshgrid goes in both x and y directions. Only need one. num_pts = size ( xi , 1 ) allocate ( out ( num_pts , num_pts )) out = 0._wp do ii = 1 , num_pts do jj = 1 , num_pts ! Calculate Jacobian, inverse Jacobian, and determinant of finite ! element at (xi,eta) J = getJacobian ( N , xi ( ii , jj ), eta ( ii , jj ), xy , alpha ) invJ = inv2 ( J ) detJ = det2 ( J ) ! If fun1 is just N_i, use dot_product to determine N_i if ( d1 == 0 ) then fun1 = dot_product ( alpha (:, N1 ), getArow ( N , xi ( ii , jj ), eta ( ii , jj ))) else ! If fun1 contains a derivative, need to calc N_i,xi and N_i,eta dfun1 ( 1 ) = ( & & dot_product ( alpha (:, N1 ), getArow ( N , xi ( ii , jj ) + eps , eta ( ii , jj ))) - & & dot_product ( alpha (:, N1 ), getArow ( N , xi ( ii , jj ) - eps , eta ( ii , jj ))) & & ) / ( 2._wp * eps ) dfun1 ( 2 ) = ( & & dot_product ( alpha (:, N1 ), getArow ( N , xi ( ii , jj ), eta ( ii , jj ) + eps )) - & & dot_product ( alpha (:, N1 ), getArow ( N , xi ( ii , jj ), eta ( ii , jj ) - eps )) & & ) / ( 2._wp * eps ) ! N_i,x = dxi/dx * N_i,xi + deta/dx * N_i,eta fun1 = dot_product ( invJ ( d1 ,:), dfun1 ) endif ! If fun2 is just N_i, use dot_product to determine N_i if ( d2 == 0 ) then fun2 = dot_product ( alpha (:, N2 ), getArow ( N , xi ( ii , jj ), eta ( ii , jj ))) else ! If fun2 contains a derivative, need to calc N_i,xi and N_i,eta dfun2 ( 1 ) = ( & & dot_product ( alpha (:, N2 ), & & getArow ( N , xi ( ii , jj ) + eps , eta ( ii , jj ))) - & & dot_product ( alpha (:, N2 ), & & getArow ( N , xi ( ii , jj ) - eps , eta ( ii , jj ))) & & ) / ( 2._wp * eps ) dfun2 ( 2 ) = ( & & dot_product ( alpha (:, N2 ), getArow ( N , xi ( ii , jj ), eta ( ii , jj ) + eps )) - & & dot_product ( alpha (:, N2 ), getArow ( N , xi ( ii , jj ), eta ( ii , jj ) - eps )) & & ) / ( 2._wp * eps ) ! N_i,y = dxi/dy * N_i,xi + deta/dy * N_i,eta fun2 = dot_product ( invJ ( d2 ,:), dfun2 ) endif out ( ii , jj ) = fun1 * fun2 * detJ enddo enddo return end function fun end function assembleElementalMatrix","title":"assembleElementalMatrix – learn_dg"},{"loc":"proc/basis_1d.html","tags":"","text":"private function basis_1D(x, alpha, dx) result(y) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: x real(kind=wp), intent(in), dimension(:) :: alpha integer, intent(in) :: dx Return Value real(kind=wp),\n  dimension(:),allocatable Source Code basis_1D Source Code function basis_1D ( x , alpha , dx ) result ( y ) ! Input/output variables integer , intent ( in ) :: dx real ( wp ), intent ( in ), dimension (:) :: x real ( wp ), intent ( in ), dimension (:) :: alpha real ( wp ), dimension (:), allocatable :: y , yx ! Local variables integer :: ii , N allocate ( y ( size ( x )), yx ( size ( x ))) N = size ( alpha ) y = 0._wp do ii = 1 + dx , N if ( dx == 0 ) then yx = alpha ( ii ) * x ** real ( ii - 1 , wp ) else ! Hoping for the best that dx == 1 yx = real ( ii - 1 , wp ) * alpha ( ii ) * ( x ) ** ( real ( ii - 1 - dx , wp )) endif y = y + yx enddo return end function basis_1D","title":"basis_1D – learn_dg"},{"loc":"proc/getalpha.html","tags":"","text":"public function getAlpha(N) result(alpha) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N Return Value real(kind=wp),\n  dimension(N,N) Calls proc~~getalpha~~CallsGraph proc~getalpha getAlpha proc~eye eye proc~getalpha->proc~eye proc~linsolve_quick linsolve_quick proc~getalpha->proc~linsolve_quick proc~linsolve linsolve proc~linsolve_quick->proc~linsolve dgetrs dgetrs proc~linsolve->dgetrs dgetrf dgetrf proc~linsolve->dgetrf Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called By proc~~getalpha~~CalledByGraph proc~getalpha getAlpha proc~assembleelementalmatrix assembleElementalMatrix proc~assembleelementalmatrix->proc~getalpha Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code getAlpha Source Code function getAlpha ( N ) result ( alpha ) integer , intent ( in ) :: N real ( wp ), dimension ( N , N ) :: alpha integer :: ii real ( wp ), dimension ( N , N ) :: A , B A = getA ( N ) B = eye ( N ) call linsolve_quick ( N , A , N , B , alpha ) return contains pure function getA ( N ) result ( A ) integer , intent ( in ) :: N real ( wp ), dimension ( N , N ) :: A integer :: ii real ( wp ), dimension ( N , 2 ) :: xy xy = getxy ( N ) do ii = 1 , N A ( ii ,:) = getArow ( N , xy ( ii , 1 ), xy ( ii , 2 )) enddo return end function getA end function getAlpha","title":"getAlpha – learn_dg"},{"loc":"proc/getarow.html","tags":"","text":"public pure function getArow(N, xi, eta) result(row) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N real(kind=wp), intent(in) :: xi real(kind=wp), intent(in) :: eta Return Value real(kind=wp),\n  dimension(N) Called By proc~~getarow~~CalledByGraph proc~getarow getArow proc~getjacobian getJacobian proc~getjacobian->proc~getarow Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code getArow Source Code pure function getArow ( N , xi , eta ) result ( row ) integer , intent ( in ) :: N real ( wp ), intent ( in ) :: xi , eta real ( wp ), dimension ( N ) :: row if ( N == 4 ) then row = [ 1._wp , & & xi , eta , & & xi * eta ] elseif ( N == 9 ) then row = [ 1._wp , & & xi , eta , & & xi ** 2._wp , xi * eta , eta ** 2._wp , & & xi ** 2._wp * eta , xi * eta ** 2._wp , & & xi ** 2._wp * eta ** 2._wp ] elseif ( N == 16 ) then row = [ 1._wp , & & xi , eta , & & xi ** 2._wp , xi * eta , eta ** 2._wp , & & xi ** 3._wp , xi ** 2._wp * eta , xi * eta ** 2._wp , eta ** 3._wp , & & xi ** 3._wp * eta , xi ** 2._wp * eta ** 2._wp , xi * eta ** 3._wp , & & xi ** 3._wp * eta ** 2._wp , xi ** 2._wp * eta ** 3._wp , & & xi ** 3._wp * eta ** 3._wp ] endif return end function getArow","title":"getArow – learn_dg"},{"loc":"proc/getjacobian.html","tags":"","text":"public pure function getJacobian(N, xi, eta, xy, alpha) result(J) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N real(kind=wp), intent(in) :: xi real(kind=wp), intent(in) :: eta real(kind=wp), intent(in), dimension(N,2) :: xy real(kind=wp), intent(in), dimension(N,N) :: alpha Return Value real(kind=wp),\n  dimension(2,2) Calls proc~~getjacobian~~CallsGraph proc~getjacobian getJacobian proc~getarow getArow proc~getjacobian->proc~getarow Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code getJacobian Source Code pure function getJacobian ( N , xi , eta , xy , alpha ) result ( J ) integer , intent ( in ) :: N real ( wp ), intent ( in ) :: xi , eta real ( wp ), dimension ( N , 2 ), intent ( in ) :: xy real ( wp ), dimension ( N , N ), intent ( in ) :: alpha real ( wp ), dimension ( 2 , 2 ) :: J integer :: ii real ( wp ), parameter :: eps = epsilon ( 0 e0 ) real ( wp ), dimension ( 2 , N ) :: P real ( wp ), dimension ( N ) :: x ! P is a matrix containing derivatives of each basis function at (xi,eta) ! P = [dN_1/dxi, dN_2/dxi, dN_3/dxi, ... !      dN_1/deta, dN_2/deta, dN_3/deta, ...] do ii = 1 , N x = alpha (:, ii ) P ( 1 , ii ) = dot_product ( x , getArow ( N , xi + eps , eta )) - & & dot_product ( x , getArow ( N , xi - eps , eta )) P ( 2 , ii ) = dot_product ( x , getArow ( N , xi , eta + eps )) - & & dot_product ( x , getArow ( N , xi , eta - eps )) enddo P = P / ( 2._wp * eps ) J = matmul ( P , xy ) return end function getJacobian","title":"getJacobian – learn_dg"},{"loc":"proc/getxy.html","tags":"","text":"public pure function getxy(N) result(xy) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N Return Value real(kind=wp),\n  dimension(N,2) Called By proc~~getxy~~CalledByGraph proc~getxy getxy program~doubleint doubleint program~doubleint->proc~getxy Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code getxy Source Code pure function getxy ( N ) result ( xy ) integer , intent ( in ) :: N real ( wp ), dimension ( N , 2 ) :: xy ! Keep a copy of 1/3 handy so no need to retype it all the time real ( wp ), parameter :: zero = 0._wp real ( wp ), parameter :: one = 1._wp real ( wp ), parameter :: third = 1._wp / 3._wp if ( N == 4 ) then xy (:, 1 ) = [ - one , one , one , - one ] ! Four corner nodes xy (:, 2 ) = [ - one , - one , one , one ] ! Four corner nodes elseif ( N == 9 ) then xy (:, 1 ) = [ - one , one , one , - one , & ! Four corner nodes & zero , one , zero , - one , & ! Four edge nodes & zero ] ! Center node xy (:, 2 ) = [ - one , - one , one , one , & ! Four corner nodes & - one , zero , one , zero , & ! Four edge nodes & zero ] ! Center node elseif ( N == 16 ) then xy (:, 1 ) = [ - one , one , one , - one , & ! Four corner nodes & - third , third , & ! Two edge nodes on each & one , one , & !     of the four edges & third , - third , & & - one , - one , & & - third , third , third , - third ] ! Four internal nodes xy (:, 2 ) = [ - one , - one , one , one , & ! Four corner nodes & - one , - one , & ! Two edge nodes on each & - third , third , & !     of the four edges & one , one , & & third , - third , & & - third , - third , third , third ] ! Four internal nodes endif return end function getxy","title":"getxy – learn_dg"},{"loc":"proc/integrate_basis_1d.html","tags":"","text":"private function integrate_basis_1d(order, basis_num, dx) result(integral) Arguments Type Intent Optional Attributes Name integer, intent(in) :: order integer, intent(in) :: basis_num integer, intent(in) :: dx Return Value real(kind=wp) Calls proc~~integrate_basis_1d~~CallsGraph proc~integrate_basis_1d integrate_basis_1d proc~vandermonde vandermonde proc~integrate_basis_1d->proc~vandermonde proc~integrate integrate proc~integrate_basis_1d->proc~integrate linspace linspace proc~vandermonde->linspace proc~linsolve_quick linsolve_quick proc~vandermonde->proc~linsolve_quick proc~gaussquad gaussquad proc~integrate->proc~gaussquad proc~linsolve linsolve proc~linsolve_quick->proc~linsolve dgetrs dgetrs proc~linsolve->dgetrs dgetrf dgetrf proc~linsolve->dgetrf Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code integrate_basis_1d Source Code function integrate_basis_1d ( order , basis_num , dx ) result ( integral ) integer , intent ( in ) :: order , basis_num , dx real ( wp ) :: integral real ( wp ), dimension (:, :), allocatable :: Vinv allocate ( Vinv ( order + 1 , order + 1 )) call vandermonde ( order + 1 , Vinv ) ! call r8mat_print(order+1, order+1, Vinv, 'Inverse Vandermonde') ! Check to make sure requested basis number is within available basis if ( basis_num > order + 1 ) then write ( * , * ) 'The basis_num input is larger than number of available basis nodes (order+1)' write ( * , * ) 'Make sure order and basis_num are correctly set before calling' stop endif ! Check to make sure differentiation is either 0 or 1 if ( dx < 0 . or . dx > 1 ) then write ( * , * ) 'Derivatives of order lower than 0 or higher than 1 are not allowed' write ( * , * ) 'integrate_basis_1d was called with dx = ' , dx write ( * , * ) 'Check to make sure that the function was called correctly' stop endif call integrate ( local_basis_1D , - 1.0_wp , 1.0_wp , integral ) deallocate ( Vinv ) return contains subroutine local_basis_1D ( x , y ) real ( wp ), intent ( in ), dimension (:) :: x real ( wp ), intent ( out ), dimension (:) :: y y = basis_1D ( x , Vinv (:, basis_num ), dx ) return end subroutine local_basis_1D end function integrate_basis_1d","title":"integrate_basis_1d – learn_dg"},{"loc":"proc/integrate_basis_1d_ie.html","tags":"","text":"private function integrate_basis_1d_Ie(N, ii, jj, dx1, dx2, xcoords) result(integral) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N integer, intent(in) :: ii integer, intent(in) :: jj integer, intent(in) :: dx1 integer, intent(in) :: dx2 real(kind=wp), intent(in), dimension(:) :: xcoords Return Value real(kind=wp) Calls proc~~integrate_basis_1d_ie~~CallsGraph proc~integrate_basis_1d_ie integrate_basis_1d_Ie proc~vandermonde vandermonde proc~integrate_basis_1d_ie->proc~vandermonde proc~integrate integrate proc~integrate_basis_1d_ie->proc~integrate linspace linspace proc~vandermonde->linspace proc~linsolve_quick linsolve_quick proc~vandermonde->proc~linsolve_quick proc~gaussquad gaussquad proc~integrate->proc~gaussquad proc~linsolve linsolve proc~linsolve_quick->proc~linsolve dgetrs dgetrs proc~linsolve->dgetrs dgetrf dgetrf proc~linsolve->dgetrf Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called By proc~~integrate_basis_1d_ie~~CalledByGraph proc~integrate_basis_1d_ie integrate_basis_1d_Ie proc~getie getIe proc~getie->proc~integrate_basis_1d_ie Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code integrate_basis_1d_Ie Source Code function integrate_basis_1d_Ie ( N , ii , jj , dx1 , dx2 , xcoords ) result ( integral ) integer , intent ( in ) :: N , ii , jj , dx1 , dx2 real ( wp ), intent ( in ), dimension (:) :: xcoords real ( wp ) :: integral integer :: order , basis_num1 , basis_num2 real ( wp ), dimension (:, :), allocatable :: Vinv order = N basis_num1 = ii basis_num2 = jj allocate ( Vinv ( order + 1 , order + 1 )) call vandermonde ( order + 1 , Vinv ) ! Check to make sure xcoords is an array of size (N+1) if ( size ( xcoords ) /= order + 1 ) then write ( * , * ) 'The shape of `xcoords` is outside the acceptable range for a' write ( * , * ) '1D basis function.' write ( * , * ) 'Shape(xcoords) should be [' , 2 , order + 1 , '], not ' , shape ( xcoords ) endif call integrate ( local_wrapper , - 1.0_wp , 1.0_wp , integral ) return contains subroutine XorJ ( s , dx , out ) integer , intent ( in ) :: dx real ( wp ), intent ( in ), dimension (:) :: s real ( wp ), intent ( out ), dimension (:) :: out integer :: ii out = 0.0_wp do ii = 1 , size ( xcoords ) out = out + basis_1D ( s , Vinv (:, ii ), dx ) * xcoords ( ii ) enddo end subroutine XorJ subroutine local_wrapper ( s , y ) real ( wp ), intent ( in ), dimension (:) :: s real ( wp ), intent ( out ), dimension (:) :: y real ( wp ), dimension (:), allocatable :: J allocate ( J ( size ( s ))) call XorJ ( s , 1 , J ) ! write(*,*) dx1, dx2 y = 1.0_wp ! Here we have to be careful because J is not always needed in the first ! two function calls. Instead of using if statements, we can use an exponent so that when dx_ == 0, J is 1 y = y * basis_1D ( s , Vinv (:, basis_num1 ), dx1 ) / ( J ** real ( dx1 , wp )) y = y * basis_1D ( s , Vinv (:, basis_num2 ), dx2 ) / ( J ** real ( dx2 , wp )) y = y * J deallocate ( J ) return end subroutine local_wrapper end function integrate_basis_1d_Ie","title":"integrate_basis_1d_Ie – learn_dg"},{"loc":"proc/getie.html","tags":"","text":"public subroutine getIe(dx1, dx2, xcoords, Ie) Arguments Type Intent Optional Attributes Name integer, intent(in) :: dx1 integer, intent(in) :: dx2 real(kind=wp), intent(in), dimension(:) :: xcoords real(kind=wp), intent(out), dimension(:,:) :: Ie Calls proc~~getie~~CallsGraph proc~getie getIe proc~integrate_basis_1d_ie integrate_basis_1d_Ie proc~getie->proc~integrate_basis_1d_ie proc~vandermonde vandermonde proc~integrate_basis_1d_ie->proc~vandermonde proc~integrate integrate proc~integrate_basis_1d_ie->proc~integrate linspace linspace proc~vandermonde->linspace proc~linsolve_quick linsolve_quick proc~vandermonde->proc~linsolve_quick proc~gaussquad gaussquad proc~integrate->proc~gaussquad proc~linsolve linsolve proc~linsolve_quick->proc~linsolve dgetrs dgetrs proc~linsolve->dgetrs dgetrf dgetrf proc~linsolve->dgetrf Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code getIe Source Code subroutine getIe ( dx1 , dx2 , xcoords , Ie ) integer , intent ( in ) :: dx1 , dx2 real ( wp ), intent ( in ), dimension (:) :: xcoords real ( wp ), intent ( out ), dimension (:,:) :: Ie integer :: ii , jj , order order = size ( xcoords ) - 1 do ii = 1 , size ( xcoords ) Ie ( ii , :) = [( integrate_basis_1d_Ie ( order , ii , jj , dx1 , dx2 , xcoords ), jj = 1 , order + 1 )] enddo return end subroutine getIe","title":"getIe – learn_dg"},{"loc":"proc/vandermonde.html","tags":"","text":"private subroutine vandermonde(n, Vinv) Arguments Type Intent Optional Attributes Name integer :: n real(kind=wp), dimension(n, n) :: Vinv Calls proc~~vandermonde~~CallsGraph proc~vandermonde vandermonde linspace linspace proc~vandermonde->linspace proc~linsolve_quick linsolve_quick proc~vandermonde->proc~linsolve_quick proc~linsolve linsolve proc~linsolve_quick->proc~linsolve dgetrs dgetrs proc~linsolve->dgetrs dgetrf dgetrf proc~linsolve->dgetrf Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called By proc~~vandermonde~~CalledByGraph proc~vandermonde vandermonde proc~integrate_basis_1d_ie integrate_basis_1d_Ie proc~integrate_basis_1d_ie->proc~vandermonde proc~integrate_basis_1d integrate_basis_1d proc~integrate_basis_1d->proc~vandermonde proc~getie getIe proc~getie->proc~integrate_basis_1d_ie Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code vandermonde Source Code subroutine vandermonde ( n , Vinv ) integer :: ii , jj integer :: n real ( wp ), dimension ( n ) :: x real ( wp ), dimension (( n ) ** 2 ) :: V_flat real ( wp ), dimension ( n , n ) :: V , Vinv , eye call linspace ( - 1._wp , 1._wp , x ) V_flat = [( [( [ x ( ii ) ** real ( jj - 1 , wp )], ii = 1 , n )], jj = 1 , n )] V = reshape ([ V_flat ], [ n , n ]) ! call r8mat_print(n, n, V, 'Original V Matrix: ') eye = 0._wp do ii = 1 , n eye ( ii , ii ) = 1._wp enddo call linsolve_quick ( n , V , n , eye , Vinv ) return end subroutine vandermonde","title":"vandermonde – learn_dg"},{"loc":"proc/det2.html","tags":"","text":"public pure function det2(A) result(det) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(2,2) :: A Return Value real(kind=wp) Called By proc~~det2~~CalledByGraph proc~det2 det2 proc~inv2 inv2 proc~inv2->proc~det2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code det2 Source Code pure function det2 ( A ) result ( det ) ! Computes the determinant of a 2x2 matrix real ( wp ), dimension ( 2 , 2 ), intent ( in ) :: A real ( wp ) :: det det = A ( 1 , 1 ) * A ( 2 , 2 ) - A ( 1 , 2 ) * A ( 2 , 1 ) return end function det2","title":"det2 – learn_dg"},{"loc":"proc/eye.html","tags":"","text":"public pure function eye(N) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N Return Value real(kind=wp),\n  dimension(N,N) Called By proc~~eye~~CalledByGraph proc~eye eye program~doubleint doubleint program~doubleint->proc~eye proc~getalpha getAlpha proc~getalpha->proc~eye proc~assembleelementalmatrix assembleElementalMatrix proc~assembleelementalmatrix->proc~getalpha Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code eye Source Code pure function eye ( N ) integer , intent ( in ) :: N real ( wp ), dimension ( N , N ) :: eye integer :: ii eye = 0._wp ; forall ( ii = 1 : N ) eye ( ii , ii ) = 1._wp return end function eye","title":"eye – learn_dg"},{"loc":"proc/inv2.html","tags":"","text":"public pure function inv2(J) result(invJ) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(2,2) :: J Return Value real(kind=wp),\n  dimension(2,2) Calls proc~~inv2~~CallsGraph proc~inv2 inv2 proc~det2 det2 proc~inv2->proc~det2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code inv2 Source Code pure function inv2 ( J ) result ( invJ ) real ( wp ), dimension ( 2 , 2 ), intent ( in ) :: J real ( wp ), dimension ( 2 , 2 ) :: invJ invJ = reshape ( [ J ( 2 , 2 ), - J ( 2 , 1 ), - J ( 1 , 2 ), J ( 1 , 1 )], [ 2 , 2 ] ) invJ = invJ / det2 ( J ) return end function inv2","title":"inv2 – learn_dg"},{"loc":"proc/linsolve.html","tags":"","text":"public subroutine linsolve(n, a, nrhs, b, x, LU, P, toggle) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=wp), intent(in), dimension(n, n) :: a integer, intent(in) :: nrhs real(kind=wp), intent(in), dimension(n, nrhs) :: b real(kind=wp), intent(out), dimension(n, nrhs) :: x real(kind=wp), intent(inout), dimension(n, n) :: LU integer, intent(inout), dimension(n) :: P logical, intent(in) :: toggle Calls proc~~linsolve~~CallsGraph proc~linsolve linsolve dgetrs dgetrs proc~linsolve->dgetrs dgetrf dgetrf proc~linsolve->dgetrf Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called By proc~~linsolve~~CalledByGraph proc~linsolve linsolve proc~linsolve_quick linsolve_quick proc~linsolve_quick->proc~linsolve proc~vandermonde vandermonde proc~vandermonde->proc~linsolve_quick program~main main program~main->proc~linsolve_quick program~doubleint doubleint program~doubleint->proc~linsolve_quick proc~getalpha getAlpha proc~getalpha->proc~linsolve_quick proc~integrate_basis_1d_ie integrate_basis_1d_Ie proc~integrate_basis_1d_ie->proc~vandermonde proc~integrate_basis_1d integrate_basis_1d proc~integrate_basis_1d->proc~vandermonde proc~getie getIe proc~getie->proc~integrate_basis_1d_ie proc~assembleelementalmatrix assembleElementalMatrix proc~assembleelementalmatrix->proc~getalpha Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code linsolve Source Code subroutine linsolve ( n , a , nrhs , b , x , LU , P , toggle ) ! This routine is a wrapper dgesv, splitting it into its two primary ! components: !             dgetrf - Decomposes A into P*L*U !             dgetrs - Uses P*L*U to solve for x (Ax=b => (P*L*U)x=b) ! ! Splitting these two up like this allows you to save the decomposed ! version of 'a' so that you don't have to do it again. If 'toggle' is ! equal to true, then the decomposition has already occured and LU can be ! trusted - OK to skip dgetrf ! Dummy variables integer , intent ( in ) :: n , nrhs integer , intent ( inout ), dimension ( n ) :: P real ( wp ), intent ( in ), dimension ( n , nrhs ) :: b real ( wp ), intent ( in ), dimension ( n , n ) :: a real ( wp ), intent ( out ), dimension ( n , nrhs ) :: x real ( wp ), intent ( inout ), dimension ( n , n ) :: LU logical , intent ( in ) :: toggle ! Local variables integer :: info integer , dimension ( n ) :: my_P real ( wp ), dimension ( n , n ) :: my_a real ( wp ), dimension ( n , nrhs ) :: my_b my_a = a my_b = b if ( . not . toggle ) then call dgetrf ( n , n , my_a , n , my_P , info ) if ( info /= 0 ) then write ( * , '(a)' ) ' ' write ( * , '(a)' ) 'DGETRF' write ( * , '(a,i8)' ) '  Factorization failed, INFO = ' , info stop endif LU = my_a P = my_P endif call dgetrs ( 'No transpose' , n , nrhs , LU , n , P , my_b , n , info ) if ( info /= 0 ) then write ( * , '(a)' ) ' ' write ( * , '(a)' ) 'DGETRS' write ( * , '(a,i8)' ) '  Back substitution failed, INFO = ' , info stop endif x = my_b return end subroutine linsolve","title":"linsolve – learn_dg"},{"loc":"proc/linsolve_quick.html","tags":"","text":"public subroutine linsolve_quick(n, a, nrhs, b, x) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=wp), intent(in), dimension(n, n) :: a integer, intent(in) :: nrhs real(kind=wp), intent(in), dimension(n, nrhs) :: b real(kind=wp), intent(out), dimension(n, nrhs) :: x Calls proc~~linsolve_quick~~CallsGraph proc~linsolve_quick linsolve_quick proc~linsolve linsolve proc~linsolve_quick->proc~linsolve dgetrs dgetrs proc~linsolve->dgetrs dgetrf dgetrf proc~linsolve->dgetrf Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called By proc~~linsolve_quick~~CalledByGraph proc~linsolve_quick linsolve_quick proc~vandermonde vandermonde proc~vandermonde->proc~linsolve_quick program~main main program~main->proc~linsolve_quick program~doubleint doubleint program~doubleint->proc~linsolve_quick proc~getalpha getAlpha proc~getalpha->proc~linsolve_quick proc~integrate_basis_1d_ie integrate_basis_1d_Ie proc~integrate_basis_1d_ie->proc~vandermonde proc~integrate_basis_1d integrate_basis_1d proc~integrate_basis_1d->proc~vandermonde proc~getie getIe proc~getie->proc~integrate_basis_1d_ie proc~assembleelementalmatrix assembleElementalMatrix proc~assembleelementalmatrix->proc~getalpha Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code linsolve_quick Source Code subroutine linsolve_quick ( n , a , nrhs , b , x ) ! Quick wrapper around linsolve integer , intent ( in ) :: n , nrhs real ( wp ), intent ( in ), dimension ( n , n ) :: a real ( wp ), intent ( in ), dimension ( n , nrhs ) :: b real ( wp ), intent ( out ), dimension ( n , nrhs ) :: x integer , dimension ( n ) :: P real ( wp ), dimension ( n , n ) :: LU call linsolve ( n , a , nrhs , b , x , LU , P , . False .) return end subroutine linsolve_quick","title":"linsolve_quick – learn_dg"},{"loc":"proc/r8mat_print.html","tags":"","text":"public subroutine r8mat_print(m, n, a, title) * * * * * * * * * * * *80 ! R8MAT_PRINT prints an R8MAT. Discussion: An R8MAT is a two dimensional matrix of double precision real values. Licensing: This code is distributed under the GNU LGPL license. Modified: 12 September 2004 Author: John Burkardt Parameters: Input, integer M, the number of rows in A.\n\nInput, integer N, the number of columns in A.\n\nInput, real ( kind = 8 ) A(M,N), the matrix.\n\nInput, character ( len = * ) TITLE, a title to be printed. Arguments Type Intent Optional Attributes Name integer(kind=4) :: m integer(kind=4) :: n real(kind=8) :: a (m,n) character(len=*) :: title Calls proc~~r8mat_print~~CallsGraph proc~r8mat_print r8mat_print proc~r8mat_print_some r8mat_print_some proc~r8mat_print->proc~r8mat_print_some Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called By proc~~r8mat_print~~CalledByGraph proc~r8mat_print r8mat_print program~doubleint doubleint program~doubleint->proc~r8mat_print Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code r8mat_print Source Code subroutine r8mat_print ( m , n , a , title ) !*****************************************************************************80 ! !! R8MAT_PRINT prints an R8MAT. ! !  Discussion: ! !    An R8MAT is a two dimensional matrix of double precision real values. ! !  Licensing: ! !    This code is distributed under the GNU LGPL license. ! !  Modified: ! !    12 September 2004 ! !  Author: ! !    John Burkardt ! !  Parameters: ! !    Input, integer M, the number of rows in A. ! !    Input, integer N, the number of columns in A. ! !    Input, real ( kind = 8 ) A(M,N), the matrix. ! !    Input, character ( len = * ) TITLE, a title to be printed. ! implicit none integer ( kind = 4 ) m integer ( kind = 4 ) n real ( kind = 8 ) a ( m , n ) character ( len = * ) title call r8mat_print_some ( m , n , a , 1 , 1 , m , n , title ) return end subroutine r8mat_print","title":"r8mat_print – learn_dg"},{"loc":"proc/r8mat_print_some.html","tags":"","text":"public subroutine r8mat_print_some(m, n, a, ilo, jlo, ihi, jhi, title) * * * * * * * * * * * *80 ! R8MAT_PRINT_SOME prints some of an R8MAT. Discussion: An R8MAT is a two dimensional matrix of double precision real values. Licensing: This code is distributed under the GNU LGPL license. Modified: 26 March 2005 Author: John Burkardt Parameters: Input, integer M, N, the number of rows and columns.\n\nInput, real ( kind = 8 ) A(M,N), an M by N matrix to be printed.\n\nInput, integer ILO, JLO, the first row and column to print.\n\nInput, integer IHI, JHI, the last row and column to print.\n\nInput, character ( len = * ) TITLE, an optional title. Arguments Type Intent Optional Attributes Name integer(kind=4) :: m integer(kind=4) :: n real(kind=8) :: a (m,n) integer(kind=4) :: ilo integer(kind=4) :: jlo integer(kind=4) :: ihi integer(kind=4) :: jhi character(len=*) :: title Called By proc~~r8mat_print_some~~CalledByGraph proc~r8mat_print_some r8mat_print_some proc~r8mat_print r8mat_print proc~r8mat_print->proc~r8mat_print_some program~doubleint doubleint program~doubleint->proc~r8mat_print Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code r8mat_print_some Source Code subroutine r8mat_print_some ( m , n , a , ilo , jlo , ihi , jhi , title ) !*****************************************************************************80 ! !! R8MAT_PRINT_SOME prints some of an R8MAT. ! !  Discussion: ! !    An R8MAT is a two dimensional matrix of double precision real values. ! !  Licensing: ! !    This code is distributed under the GNU LGPL license. ! !  Modified: ! !    26 March 2005 ! !  Author: ! !    John Burkardt ! !  Parameters: ! !    Input, integer M, N, the number of rows and columns. ! !    Input, real ( kind = 8 ) A(M,N), an M by N matrix to be printed. ! !    Input, integer ILO, JLO, the first row and column to print. ! !    Input, integer IHI, JHI, the last row and column to print. ! !    Input, character ( len = * ) TITLE, an optional title. ! implicit none integer ( kind = 4 ), parameter :: incx = 5 integer ( kind = 4 ) m integer ( kind = 4 ) n real ( kind = 8 ) a ( m , n ) character ( len = 14 ) ctemp ( incx ) integer ( kind = 4 ) i integer ( kind = 4 ) i2hi integer ( kind = 4 ) i2lo integer ( kind = 4 ) ihi integer ( kind = 4 ) ilo integer ( kind = 4 ) inc integer ( kind = 4 ) j integer ( kind = 4 ) j2 integer ( kind = 4 ) j2hi integer ( kind = 4 ) j2lo integer ( kind = 4 ) jhi integer ( kind = 4 ) jlo character ( len = * ) title if ( 0 < len_trim ( title ) ) then write ( * , '(a)' ) ' ' write ( * , '(a)' ) trim ( title ) endif do j2lo = max ( jlo , 1 ), min ( jhi , n ), incx j2hi = j2lo + incx - 1 j2hi = min ( j2hi , n ) j2hi = min ( j2hi , jhi ) inc = j2hi + 1 - j2lo write ( * , '(a)' ) ' ' do j = j2lo , j2hi j2 = j + 1 - j2lo write ( ctemp ( j2 ), '(i8,6x)' ) j enddo write ( * , '(''  Col   '',5a14)' ) ctemp ( 1 : inc ) write ( * , '(a)' ) '  Row' write ( * , '(a)' ) ' ' i2lo = max ( ilo , 1 ) i2hi = min ( ihi , m ) do i = i2lo , i2hi do j2 = 1 , inc j = j2lo - 1 + j2 if ( a ( i , j ) == real ( int ( a ( i , j ) ), kind = 8 ) ) then write ( ctemp ( j2 ), '(f8.0,6x)' ) a ( i , j ) else write ( ctemp ( j2 ), '(g14.6)' ) a ( i , j ) endif enddo write ( * , '(i5,1x,5a14)' ) i , ( ctemp ( j ), j = 1 , inc ) enddo enddo write ( * , '(a)' ) ' ' return end subroutine r8mat_print_some","title":"r8mat_print_some – learn_dg"},{"loc":"module/assembly.html","tags":"","text":"Uses: iso_fortran_env legendre module~~assembly~~UsesGraph module~assembly assembly module~legendre legendre module~legendre->module~assembly iso_fortran_env iso_fortran_env iso_fortran_env->module~assembly iso_fortran_env->module~legendre module~integration integration iso_fortran_env->module~integration module~misc misc iso_fortran_env->module~misc module~linalg linalg iso_fortran_env->module~linalg lib_array lib_array lib_array->module~legendre lib_array->module~integration module~integration->module~legendre module~misc->module~legendre module~linalg->module~legendre Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used By module~~assembly~~UsedByGraph module~assembly assembly program~main main module~assembly->program~main Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Subroutines assemble initialize_global_mats set_BCs Subroutines public subroutine assemble (order, xcoords, elem_conn, GlobalA, diff, vel) Arguments Type Intent Optional Attributes Name integer, intent(in), dimension(:) :: order real(kind=wp), intent(in), dimension(:) :: xcoords integer, intent(in), dimension(:,:) :: elem_conn real(kind=wp), intent(out), dimension(:,:) :: GlobalA real(kind=wp), intent(in) :: diff real(kind=wp), intent(in) :: vel public subroutine initialize_global_mats (num_nodes, GlobalA, GlobalB, GlobalX, xcoords) Arguments Type Intent Optional Attributes Name integer, intent(in) :: num_nodes real(kind=wp), intent(out), dimension(:,:), allocatable :: GlobalA real(kind=wp), intent(out), dimension(:), allocatable :: GlobalB real(kind=wp), intent(out), dimension(:), allocatable :: GlobalX real(kind=wp), intent(in), dimension(:) :: xcoords public subroutine set_BCs (xcoords, GlobalB, GlobalA) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: xcoords real(kind=wp), intent(out), dimension(:) :: GlobalB real(kind=wp), intent(out), dimension(:,:) :: GlobalA","title":"assembly – learn_dg"},{"loc":"module/integration.html","tags":"","text":"Uses: iso_fortran_env lib_array module~~integration~~UsesGraph module~integration integration lib_array lib_array lib_array->module~integration iso_fortran_env iso_fortran_env iso_fortran_env->module~integration Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used By module~~integration~~UsedByGraph module~integration integration module~legendre legendre module~integration->module~legendre module~assembly assembly module~legendre->module~assembly program~doubleint doubleint module~legendre->program~doubleint program~main main module~assembly->program~main Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Interfaces fun2d_interf Functions integrate2D Subroutines cgwt gaussquad gaussquad_wrapper integrate lgwt Interfaces interface public function fun2d_interf (x, y) result(z) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:,:) :: x real(kind=wp), intent(in), dimension(:,:) :: y Return Value real(kind=wp),\n  dimension(:,:), allocatable Functions public function integrate2D (fun) result(out) Arguments Type Intent Optional Attributes Name procedure( fun2d_interf ) :: fun Return Value real(kind=wp) Subroutines private subroutine cgwt (num_pts, x, w) Arguments Type Intent Optional Attributes Name integer, intent(in) :: num_pts real(kind=wp), intent(out), dimension(:) :: x real(kind=wp), intent(out), dimension(:) :: w private subroutine gaussquad (n, r1, r2) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=wp), intent(out) :: r1 (n) real(kind=wp), intent(out) :: r2 (n) public subroutine gaussquad_wrapper (N, x, w) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N real(kind=wp), intent(out), dimension(N) :: x real(kind=wp), intent(out), dimension(N) :: w public subroutine integrate (sub, a, b, result) Arguments Type Intent Optional Attributes Name public subroutine sub(xx, yy) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: xx real(kind=wp), intent(out), dimension(:) :: yy real(kind=wp), intent(in) :: a real(kind=wp), intent(in) :: b real(kind=wp), intent(out) :: result private subroutine lgwt (a, b, num_pts, x, w) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a real(kind=wp), intent(in) :: b integer, intent(in) :: num_pts real(kind=wp), intent(out), dimension(:) :: x real(kind=wp), intent(out), dimension(:) :: w","title":"integration – learn_dg"},{"loc":"module/io.html","tags":"","text":"Uses: iso_fortran_env lib_array module~~io~~UsesGraph module~io io lib_array lib_array lib_array->module~io iso_fortran_env iso_fortran_env iso_fortran_env->module~io Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used By module~~io~~UsedByGraph module~io io program~main main module~io->program~main Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Subroutines get_command_argument_wrapper read_gmsh_file_1D write_out_solution Subroutines public subroutine get_command_argument_wrapper (arg) Arguments Type Intent Optional Attributes Name character(len=*), intent(out) :: arg public subroutine read_gmsh_file_1D (num_nodes, order, nodes2vertex, elem_conn, xcoords, dg) Arguments Type Intent Optional Attributes Name integer, intent(out) :: num_nodes integer, intent(out), dimension(:), allocatable :: order integer, intent(out), dimension(:), allocatable :: nodes2vertex integer, intent(out), dimension(:,:), allocatable :: elem_conn real(kind=wp), intent(out), dimension(:), allocatable :: xcoords logical, intent(in) :: dg public subroutine write_out_solution (num_nodes, xcoords, GlobalX) Arguments Type Intent Optional Attributes Name integer, intent(in) :: num_nodes real(kind=wp), intent(in), dimension(:) :: xcoords real(kind=wp), intent(in), dimension(:) :: GlobalX","title":"io – learn_dg"},{"loc":"module/legendre.html","tags":"","text":"Uses: iso_fortran_env misc lib_array integration linalg module~~legendre~~UsesGraph module~legendre legendre lib_array lib_array lib_array->module~legendre module~integration integration lib_array->module~integration module~integration->module~legendre iso_fortran_env iso_fortran_env iso_fortran_env->module~legendre iso_fortran_env->module~integration module~misc misc iso_fortran_env->module~misc module~linalg linalg iso_fortran_env->module~linalg module~misc->module~legendre module~linalg->module~legendre Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used By module~~legendre~~UsedByGraph module~legendre legendre module~assembly assembly module~legendre->module~assembly program~doubleint doubleint module~legendre->program~doubleint program~main main module~assembly->program~main Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Functions assembleElementalMatrix basis_1D getAlpha getArow getJacobian getxy integrate_basis_1d integrate_basis_1d_Ie Subroutines getIe vandermonde Functions public function assembleElementalMatrix (N, d1, d2, xy) result(Ie) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N integer, intent(in) :: d1 integer, intent(in) :: d2 real(kind=wp), intent(in), dimension(N,2) :: xy Return Value real(kind=wp),\n  dimension(N,N) private function basis_1D (x, alpha, dx) result(y) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: x real(kind=wp), intent(in), dimension(:) :: alpha integer, intent(in) :: dx Return Value real(kind=wp),\n  dimension(:), allocatable public function getAlpha (N) result(alpha) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N Return Value real(kind=wp),\n  dimension(N,N) public pure function getArow (N, xi, eta) result(row) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N real(kind=wp), intent(in) :: xi real(kind=wp), intent(in) :: eta Return Value real(kind=wp),\n  dimension(N) public pure function getJacobian (N, xi, eta, xy, alpha) result(J) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N real(kind=wp), intent(in) :: xi real(kind=wp), intent(in) :: eta real(kind=wp), intent(in), dimension(N,2) :: xy real(kind=wp), intent(in), dimension(N,N) :: alpha Return Value real(kind=wp),\n  dimension(2,2) public pure function getxy (N) result(xy) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N Return Value real(kind=wp),\n  dimension(N,2) private function integrate_basis_1d (order, basis_num, dx) result(integral) Arguments Type Intent Optional Attributes Name integer, intent(in) :: order integer, intent(in) :: basis_num integer, intent(in) :: dx Return Value real(kind=wp) private function integrate_basis_1d_Ie (N, ii, jj, dx1, dx2, xcoords) result(integral) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N integer, intent(in) :: ii integer, intent(in) :: jj integer, intent(in) :: dx1 integer, intent(in) :: dx2 real(kind=wp), intent(in), dimension(:) :: xcoords Return Value real(kind=wp) Subroutines public subroutine getIe (dx1, dx2, xcoords, Ie) Arguments Type Intent Optional Attributes Name integer, intent(in) :: dx1 integer, intent(in) :: dx2 real(kind=wp), intent(in), dimension(:) :: xcoords real(kind=wp), intent(out), dimension(:,:) :: Ie private subroutine vandermonde (n, Vinv) Arguments Type Intent Optional Attributes Name integer :: n real(kind=wp), dimension(n, n) :: Vinv","title":"legendre – learn_dg"},{"loc":"module/linalg.html","tags":"","text":"Uses: iso_fortran_env module~~linalg~~UsesGraph module~linalg linalg iso_fortran_env iso_fortran_env iso_fortran_env->module~linalg Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used By module~~linalg~~UsedByGraph module~linalg linalg module~legendre legendre module~linalg->module~legendre program~main main module~linalg->program~main program~doubleint doubleint module~linalg->program~doubleint module~legendre->program~doubleint module~assembly assembly module~legendre->module~assembly module~assembly->program~main Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Functions det2 eye inv2 Subroutines linsolve linsolve_quick Functions public pure function det2 (A) result(det) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(2,2) :: A Return Value real(kind=wp) public pure function eye (N) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N Return Value real(kind=wp),\n  dimension(N,N) public pure function inv2 (J) result(invJ) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(2,2) :: J Return Value real(kind=wp),\n  dimension(2,2) Subroutines public subroutine linsolve (n, a, nrhs, b, x, LU, P, toggle) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=wp), intent(in), dimension(n, n) :: a integer, intent(in) :: nrhs real(kind=wp), intent(in), dimension(n, nrhs) :: b real(kind=wp), intent(out), dimension(n, nrhs) :: x real(kind=wp), intent(inout), dimension(n, n) :: LU integer, intent(inout), dimension(n) :: P logical, intent(in) :: toggle public subroutine linsolve_quick (n, a, nrhs, b, x) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=wp), intent(in), dimension(n, n) :: a integer, intent(in) :: nrhs real(kind=wp), intent(in), dimension(n, nrhs) :: b real(kind=wp), intent(out), dimension(n, nrhs) :: x","title":"linalg – learn_dg"},{"loc":"module/misc.html","tags":"","text":"Uses: iso_fortran_env module~~misc~~UsesGraph module~misc misc iso_fortran_env iso_fortran_env iso_fortran_env->module~misc Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used By module~~misc~~UsedByGraph module~misc misc module~legendre legendre module~misc->module~legendre program~main main module~misc->program~main program~doubleint doubleint module~misc->program~doubleint module~legendre->program~doubleint module~assembly assembly module~legendre->module~assembly module~assembly->program~main Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Subroutines r8mat_print r8mat_print_some Subroutines public subroutine r8mat_print (m, n, a, title) * * * * * * * * * * * *80 Arguments Type Intent Optional Attributes Name integer(kind=4) :: m integer(kind=4) :: n real(kind=8) :: a (m,n) character(len=*) :: title public subroutine r8mat_print_some (m, n, a, ilo, jlo, ihi, jhi, title) * * * * * * * * * * * *80 Arguments Type Intent Optional Attributes Name integer(kind=4) :: m integer(kind=4) :: n real(kind=8) :: a (m,n) integer(kind=4) :: ilo integer(kind=4) :: jlo integer(kind=4) :: ihi integer(kind=4) :: jhi character(len=*) :: title","title":"misc – learn_dg"},{"loc":"program/doubleint.html","tags":"","text":"Uses: iso_fortran_env linalg misc legendre program~~doubleint~~UsesGraph program~doubleint doubleint module~legendre legendre module~legendre->program~doubleint iso_fortran_env iso_fortran_env iso_fortran_env->program~doubleint iso_fortran_env->module~legendre module~misc misc iso_fortran_env->module~misc module~linalg linalg iso_fortran_env->module~linalg module~integration integration iso_fortran_env->module~integration module~misc->program~doubleint module~misc->module~legendre module~linalg->program~doubleint module~linalg->module~legendre lib_array lib_array lib_array->module~legendre lib_array->module~integration module~integration->module~legendre Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Calls program~~doubleint~~CallsGraph program~doubleint doubleint assembleelementalmatrix assembleelementalmatrix program~doubleint->assembleelementalmatrix proc~getxy getxy program~doubleint->proc~getxy proc~eye eye program~doubleint->proc~eye proc~r8mat_print r8mat_print program~doubleint->proc~r8mat_print proc~linsolve_quick linsolve_quick program~doubleint->proc~linsolve_quick proc~r8mat_print_some r8mat_print_some proc~r8mat_print->proc~r8mat_print_some proc~linsolve linsolve proc~linsolve_quick->proc~linsolve dgetrs dgetrs proc~linsolve->dgetrs dgetrf dgetrf proc~linsolve->dgetrf Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Variables GlobalA GlobalB GlobalX Ie N elem ii xy Source Code doubleint Variables Type Attributes Name Initial real(kind=wp), dimension(16,16) :: GlobalA real(kind=wp), dimension(16) :: GlobalB real(kind=wp), dimension(16) :: GlobalX real(kind=wp), dimension(N,N) :: Ie integer, parameter :: N = 16 integer, dimension(1, 16) :: elem integer :: ii real(kind=wp), dimension(N,2) :: xy Source Code program doubleint use iso_fortran_env , only : wp => real64 use linalg , only : linsolve_quick , eye use misc , only : r8mat_print use legendre , only : assembleElementalMatrix , getxy implicit none integer :: ii ! integer, parameter :: N = 4 ! integer, parameter :: N = 9 integer , parameter :: N = 16 real ( wp ), dimension ( N , 2 ) :: xy real ( wp ), dimension ( N , N ) :: Ie ! real(wp), dimension(10)    :: GlobalB, GlobalX ! real(wp), dimension(10,10)  :: GlobalA ! real(wp), dimension(15)    :: GlobalB, GlobalX ! real(wp), dimension(15,15)  :: GlobalA real ( wp ), dimension ( 16 ) :: GlobalB , GlobalX real ( wp ), dimension ( 16 , 16 ) :: GlobalA ! integer,  dimension(4,4)  :: elem ! integer,  dimension(2,9)  :: elem integer , dimension ( 1 , 16 ) :: elem !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!! Bi-linear quads !!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! ! Element connection(s) for 3 bi-linear quadrilaterals ! elem(1,:) = [1, 2, 3, 4] ! elem(2,:) = [2, 5, 6, 3] ! elem(3,:) = [5, 7, 8, 6] ! elem(4,:) = [7, 9, 10, 8] ! Get base xi/eta coordinates for bi-linear quadrilateral ! xy(:,1) = [-1._wp, 1._wp, 1._wp, -1._wp] ! xy(:,2) = [-1._wp, -1._wp, 1._wp, 1._wp] ! Adjust for bi-linear quad ! xy(:,1) = [0._wp, 1._wp, 1.6_wp, 0._wp] ! xy(:,2) = [-1._wp, -2._wp, 5._wp, 3._wp] ! xy(:,1) = [0._wp, 0.03333_wp, 0.03333_wp, 0._wp] ! xy(:,2) = [0._wp, 0._wp, 0.03333_wp, 0.03333_wp] !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!! Bi-linear quads !!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!! Bi-quadratic quads !!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! ! Element connection(s) for 2 bi-quadratic quadrilaterals ! elem(1,:) = [1, 2, 5, 6, 7, 8, 9, 10, 11] ! elem(2,:) = [2, 3, 4, 5, 12, 13, 14, 8, 15] ! Get base xi/eta coordinates for bi-quadratic quadrilateral ! xy(:,1) = [-1._wp, 1._wp, 1._wp, -1._wp, 0._wp, 1._wp, 0._wp, -1._wp, 0._wp] ! xy(:,2) = [-1._wp, -1._wp, 1._wp, 1._wp, -1._wp, 0._wp, 1._wp, 0._wp, 0._wp] ! Adjust for bi-quadratic quad ! xy(:,1) = [0._wp, 0.03333_wp, 0.03333_wp, 0._wp, 0.016667_wp, 0.03333_wp, 0.016667_wp, 0._wp, 0.016667_wp] ! xy(:,2) = [0._wp, 0._wp, 0.03333_wp, 0.03333_wp, 0._wp, 0.016667_wp, 0.03333_wp, 0.016667_wp, 0.016667_wp] ! xy(1,:) = [-1.25_wp, -0.8_wp] ! xy(6,:) = [0.75_wp, 0.1_wp] ! xy(9,:) = [-0.25_wp, 0.25_wp] !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!! Bi-quadratic quads !!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!! Bi-cubic quads !!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!! ! Element connection(s) for 2 bi-cubic quadrilaterals elem ( 1 ,:) = [( ii , ii = 1 , 16 )] ! Get base xi/eta coordinates for bi-cubic quadrilateral xy = getxy ( N ) ! Adjust for bi-cubic quad ! xy(:,1) = [0._wp, 0.03333_wp, 0.03333_wp, 0._wp, 0.016667_wp, 0.03333_wp, 0.016667_wp, 0._wp, 0.016667_wp] ! xy(:,2) = [0._wp, 0._wp, 0.03333_wp, 0.03333_wp, 0._wp, 0.016667_wp, 0.03333_wp, 0.016667_wp, 0.016667_wp] ! xy(1,:) = [-1.25_wp, -0.8_wp] ! xy(6,:) = [0.75_wp, 0.1_wp] ! xy(9,:) = [-0.25_wp, 0.25_wp] !!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!! Bi-cubic quads !!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!! GlobalA = 0._wp do ii = 1 , size ( elem , 1 ) Ie = - assembleElementalMatrix ( N , 1 , 1 , xy ) - assembleElementalMatrix ( N , 2 , 2 , xy ) GlobalA ( elem ( ii ,:), elem ( ii ,:)) = GlobalA ( elem ( ii ,:), elem ( ii ,:)) + Ie enddo ! Zero-out the row corresponding with BCs and set A(ii,ii) to 1.0 forall ii ! GlobalA( [1, 4, 9, 10], : ) = 0._wp ! GlobalA( [1, 4, 9, 10], [1, 4, 9, 10] ) = eye(4) ! GlobalA( [1, 6, 10, 3, 4, 13], : ) = 0._wp ! GlobalA( [1, 6, 10, 3, 4, 13], [1, 6, 10, 3, 4, 13] ) = eye(6) GlobalA ( [ 1 , 2 , 7 , 8 , 3 , 4 , 11 , 12 ], : ) = 0._wp GlobalA ( [ 1 , 2 , 7 , 8 , 3 , 4 , 11 , 12 ], [ 1 , 2 , 7 , 8 , 3 , 4 , 11 , 12 ] ) = eye ( 8 ) call r8mat_print ( size ( GlobalA , 1 ), size ( GlobalA , 2 ), GlobalA , \"Global Stiffness Matrix:\" ) ! Set BCs (zero everywhere, 1 on left boundary) GlobalB = 0._wp ! GlobalB( [1, 4] ) = 1._wp ! GlobalB( [1, 6, 10] ) = 1._wp GlobalB ( [ 1 , 4 , 11 , 12 ] ) = 1._wp ! Solve linear system call linsolve_quick ( size ( GlobalA , 1 ), GlobalA , size ( GlobalB , 1 ), GlobalB , GlobalX ) call r8mat_print ( size ( GlobalX , 1 ), 1 , GlobalX , \"Solution Vector:\" ) end program doubleint","title":"doubleint – learn_dg"},{"loc":"program/main.html","tags":"","text":"Uses: iso_fortran_env linalg misc io assembly program~~main~~UsesGraph program~main main module~assembly assembly module~assembly->program~main iso_fortran_env iso_fortran_env iso_fortran_env->program~main iso_fortran_env->module~assembly module~io io iso_fortran_env->module~io module~misc misc iso_fortran_env->module~misc module~linalg linalg iso_fortran_env->module~linalg module~legendre legendre iso_fortran_env->module~legendre module~integration integration iso_fortran_env->module~integration module~io->program~main module~misc->program~main module~misc->module~legendre module~linalg->program~main module~linalg->module~legendre module~legendre->module~assembly lib_array lib_array lib_array->module~io lib_array->module~legendre lib_array->module~integration module~integration->module~legendre Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Calls program~~main~~CallsGraph program~main main proc~initialize_global_mats initialize_global_mats program~main->proc~initialize_global_mats proc~assemble assemble program~main->proc~assemble proc~write_out_solution write_out_solution program~main->proc~write_out_solution proc~linsolve_quick linsolve_quick program~main->proc~linsolve_quick set_bcs set_bcs program~main->set_bcs read_gmsh_file_1d read_gmsh_file_1d program~main->read_gmsh_file_1d getie getie proc~assemble->getie proc~linsolve linsolve proc~linsolve_quick->proc~linsolve dgetrs dgetrs proc~linsolve->dgetrs dgetrf dgetrf proc~linsolve->dgetrf Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Variables GlobalA GlobalB GlobalX dg diff elem_conn nodes2vertex num_nodes order vel xcoords Source Code main Variables Type Attributes Name Initial real(kind=wp), dimension(:,:), allocatable :: GlobalA real(kind=wp), dimension(:), allocatable :: GlobalB real(kind=wp), dimension(:), allocatable :: GlobalX logical :: dg real(kind=wp), parameter :: diff = 0.1_wp integer, dimension(:,:), allocatable :: elem_conn integer, dimension(:), allocatable :: nodes2vertex integer :: num_nodes integer, dimension(:), allocatable :: order real(kind=wp), parameter :: vel = -5._wp real(kind=wp), dimension(:), allocatable :: xcoords Source Code program main use iso_fortran_env , only : wp => real64 use linalg , only : linsolve_quick use misc , only : r8mat_print use io , only : get_command_argument_wrapper , & & read_gmsh_file_1D , & & write_out_solution use assembly , only : initialize_global_mats , assemble , set_BCs implicit none real ( wp ), parameter :: diff = 0.1_wp , vel = - 5._wp integer :: num_nodes integer , dimension (:), allocatable :: order , nodes2vertex integer , dimension (:,:), allocatable :: elem_conn real ( wp ), dimension (:), allocatable :: xcoords , GlobalB , GlobalX real ( wp ), dimension (:,:), allocatable :: GlobalA logical :: dg ! dg = .true. dg = . false . call read_gmsh_file_1D ( num_nodes , order , nodes2vertex , elem_conn , xcoords , dg ) ! stop call initialize_global_mats ( num_nodes , GlobalA , GlobalB , GlobalX , xcoords ) call assemble ( order , xcoords , elem_conn , GlobalA , diff , vel ) call set_BCs ( xcoords , GlobalB , GlobalA ) ! call r8mat_print(num_nodes, num_nodes, GlobalA, 'Global Stiffness matrix:') ! stop call linsolve_quick ( num_nodes , GlobalA , 1 , GlobalB , GlobalX ) ! call r8mat_print(num_nodes, 1, GlobalB, 'Global RHS:') ! call r8mat_print(num_nodes, 1, GlobalX, 'Global Solution Vector:') call write_out_solution ( num_nodes , xcoords , GlobalX ) end program main","title":"main – learn_dg"},{"loc":"page//index.html","tags":"","text":"Introduction This is an introduction","title":"User Guide – learn_dg"}]}