var tipuesearch = {"pages":[{"title":" learn_dg ","loc":"index.html","text":"learn_dg Developer Info Chris Coutinho","tags":""},{"title":"integration.f90 – learn_dg","loc":"sourcefile/integration.f90.html","text":"Files Dependent On This One sourcefile~~integration.f90~~AfferentGraph sourcefile~integration.f90 integration.f90 sourcefile~legendre.f90 legendre.f90 sourcefile~integration.f90->sourcefile~legendre.f90 sourcefile~main.f90 main.f90 sourcefile~legendre.f90->sourcefile~main.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Modules integration Source Code integration.f90 Source Code module integration use iso_fortran_env , only : wp => real64 use lib_array , only : linspace implicit none private :: lgwt public :: integrate contains subroutine integrate ( sub , a , b , result ) ! This routine uses gauss-legendre quadrature to integrate a 1D function ! Input/Output variables real ( wp ), intent ( in ) :: a , b real ( wp ), intent ( out ) :: result interface subroutine sub ( xx , yy ) import wp real ( wp ), intent ( in ), dimension (:) :: xx real ( wp ), intent ( out ), dimension (:) :: yy end subroutine sub end interface ! Local variables integer :: N real ( wp ) :: result_old , error real ( wp ), parameter :: eps = sqrt ( epsilon ( 1.0_wp )) real ( wp ), dimension (:), allocatable :: x , w , y N = 3 result = 0.0_wp error = 1.0_wp do result_old = result allocate ( x ( N ), w ( N ), y ( N )) ! call cgwt(N, x, w) ! call lgwt(a, b, N, x, w) call gaussquad ( N , x , w ) call sub ( x , y ) result = sum ( y * w ) deallocate ( x , w , y ) ! error = norm2([result, result_old]) error = sqrt (( result - result_old ) ** 2.0_wp ) ! error = abs((result-result_old)/(result_old+eps)) ! write(*,*) N, result, error ! write(*,*) N, result, result_old, error, eps ! Check if error is acceptable, as well as whether the loop was gone ! through at least twice (N = 3, 4, 5...) if ( ( error < eps . or . abs ( result ) < eps ) & . and . N > 5 ) then exit else N = N + 1 end if end do return end subroutine integrate subroutine lgwt ( a , b , num_pts , x , w ) ! This function is a fortran90 port of the matlab function, lgwt.m ! The source code of lgwt.m was originally found at: ! ! http://www.mathworks.com/matlabcentral/fileexchange/4540 ! Variables in/out integer , intent ( in ) :: num_pts real ( wp ), intent ( in ) :: a , b real ( wp ), intent ( out ), dimension (:) :: x , w ! Local variables integer :: ii , jj , N , N1 , N2 ! real(wp), parameter:: eps=sqrt(epsilon(1.0_wp)) real ( wp ), parameter :: eps = 1 d - 10 real ( wp ), dimension (:), allocatable :: xu , array1 , y , y0 , Lpp real ( wp ), dimension (:, :), allocatable :: L , Lp real ( wp ), parameter :: pi = 4.0_wp * datan ( 1.0_wp ) N = num_pts - 1 N1 = N + 1 N2 = N + 2 ! Allocate and initialize arrays allocate ( xu ( N1 ), array1 ( N1 ), y ( N1 ), y0 ( N1 )) allocate ( L ( N1 , N2 ), Lp ( N1 , N2 ), Lpp ( N1 )) L = 0.0_wp Lp = 0.0_wp call linspace ( - 1.0_wp , 1.0_wp , xu ) array1 = [ ( ii , ii = 0 , N ) ] ! Initial guess of ??? y = dcos (( 2.0_wp * real ( array1 , wp ) + 1.0_wp ) * & pi / ( 2.0_wp * real ( N , wp ) + 2.0_wp )) + & ( 0.27_wp / real ( N1 , wp )) * dsin ( pi * xu * real ( N , wp ) / real ( N2 , wp )) y0 = 2.0_wp do L (:, 1 ) = 1.0_wp Lp (:, 1 ) = 0.0_wp L (:, 2 ) = y Lp (:, 2 ) = 1.0_wp do jj = 2 , N1 L (:, jj + 1 ) = ( ( 2.0_wp * real ( jj , wp ) - 1.0_wp ) * y * L (:, jj ) - & real ( jj - 1 , wp ) * L (:, jj - 1 )) / real ( jj , wp ) end do Lpp = real ( N2 , wp ) * ( L (:, N1 ) - y * L (:, N2 )) / ( 1.0_wp - y ** 2.0_wp ) y0 = y y = y0 - L (:, N2 ) / Lpp if ( norm2 ( y - y0 ) < eps ) then exit end if end do x = ( a * ( 1.0_wp - y ) + b * ( 1.0_wp + y ) ) / 2.0_wp w = ( b - a ) / (( 1.0_wp - y ** 2.0_wp ) * Lpp ** 2.0_wp ) * & ( real ( N2 , wp ) / real ( N1 , wp )) ** 2.0_wp return end subroutine lgwt subroutine cgwt ( num_pts , x , w ) ! This function  determines the points and weights associated with Chebyshev-Gauss quadrature ! Variables in/out integer , intent ( in ) :: num_pts real ( wp ), intent ( out ), dimension (:) :: x , w ! Local variables integer :: ii real ( wp ), parameter :: pi = 4.0_wp * datan ( 1.0_wp ) x = dcos (( real ( 2 * [( ii , ii = 1 , num_pts )] - 1 , wp )) / real ( 2 * num_pts , wp ) * pi ) w = pi / real ( num_pts , wp ) / (( 1.0_wp - x ** 2.0_wp ) ** ( - 0.5_wp )) ! write(*,*) x ! write(*,*) w ! stop return end subroutine cgwt subroutine gaussquad ( n , r1 , r2 ) ! This code was originally found at the following website: !  http://rosettacode.org/wiki/Numerical_integration/Gauss-Legendre_Quadrature#Fortran integer :: n , k real ( wp ), parameter :: pi = 4 * atan ( 1._wp ) real ( wp ) :: r1 (:), r2 (:), x , f , df , dx integer :: i , iter real ( wp ), allocatable :: p0 (:), p1 (:), tmp (:) p0 = [ 1._wp ] p1 = [ 1._wp , 0._wp ] do k = 2 , n tmp = (( 2 * k - 1 ) * [ p1 , 0._wp ] - ( k - 1 ) * [ 0._wp , 0._wp , p0 ]) / k p0 = p1 ; p1 = tmp end do do i = 1 , n x = cos ( pi * ( i - 0.25_wp ) / ( n + 0.5_wp )) do iter = 1 , 10 f = p1 ( 1 ); df = 0._wp do k = 2 , size ( p1 ) df = f + x * df f = p1 ( k ) + x * f end do dx = f / df x = x - dx if ( abs ( dx ) < 10 * epsilon ( dx )) exit end do r1 ( i ) = x r2 ( i ) = 2 / (( 1 - x ** 2 ) * df ** 2 ) end do return end subroutine end module integration","tags":""},{"title":"io.f90 – learn_dg","loc":"sourcefile/io.f90.html","text":"Files Dependent On This One sourcefile~~io.f90~~AfferentGraph sourcefile~io.f90 io.f90 sourcefile~main.f90 main.f90 sourcefile~io.f90->sourcefile~main.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Modules io Source Code io.f90 Source Code module io use iso_fortran_env , only : wp => real64 implicit none contains subroutine get_command_argument_wrapper ( arg ) character ( * ), intent ( out ) :: arg integer :: ii ii = 1 do call get_command_argument ( ii , arg ) if ( len_trim ( arg ) == 0 ) then arg = trim ( arg ) else exit end if ii = ii + 1 end do return end subroutine get_command_argument_wrapper subroutine read_gmsh_file_1D ( filename , num_nodes , order , elem_conn , xcoords ) integer , intent ( out ) :: num_nodes integer , intent ( out ), dimension (:), allocatable :: order integer , intent ( out ), dimension (:,:), allocatable :: elem_conn real ( wp ), intent ( out ), dimension (:), allocatable :: xcoords character ( * ), intent ( in ) :: filename integer :: ii , ios , num_elements , d_int real ( wp ) :: d_real character ( 50 ) :: blank_string ! write(*,*) filename open ( unit = 21 , file = filename , iostat = ios , status = \"old\" , action = \"read\" ) if ( ios /= 0 ) stop \"Error opening file \" ! Read initial header information - assuming file is correct format do read ( 21 , * ) blank_string if ( trim ( blank_string ) == '$Nodes' ) exit end do ! Read number of nodes read ( 21 , * ) num_nodes allocate ( xcoords ( num_nodes )) ! Read coordinate information for each node do ii = 1 , num_nodes read ( 21 , * ) d_int , xcoords ( ii ), d_real , d_real end do ! Two dummy lines - $EndNodes and $Elements read ( 21 , * ) read ( 21 , * ) read ( 21 , * ) num_elements num_elements = num_elements - 2 allocate ( order ( num_elements )) allocate ( elem_conn ( num_elements , 2 )) ! Initialize all elements as first order linear elements order = 1 ! Two dummy lines - Associated with 'point' elements read ( 21 , * ) read ( 21 , * ) do ii = 1 , num_elements read ( 21 , * ) d_int , d_int , d_int , d_int , d_int , elem_conn ( ii , 1 : 2 ) end do ! do ii = 1, size(order) !   write(*,*) order(ii), elem_conn(ii, :) ! end do ! write(*,*) ! ! do ii = 1, size(xcoords) !   write(*,*) xcoords(ii) ! end do ! write(*,*) close ( unit = 21 , iostat = ios , status = \"delete\" ) if ( ios /= 0 ) stop \"Error closing file unit 21\" return end subroutine read_gmsh_file_1D end module io","tags":""},{"title":"legendre.f90 – learn_dg","loc":"sourcefile/legendre.f90.html","text":"This File Depends On sourcefile~~legendre.f90~~EfferentGraph sourcefile~legendre.f90 legendre.f90 sourcefile~misc.f90 misc.f90 sourcefile~misc.f90->sourcefile~legendre.f90 sourcefile~integration.f90 integration.f90 sourcefile~integration.f90->sourcefile~legendre.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files Dependent On This One sourcefile~~legendre.f90~~AfferentGraph sourcefile~legendre.f90 legendre.f90 sourcefile~main.f90 main.f90 sourcefile~legendre.f90->sourcefile~main.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Modules legendre Source Code legendre.f90 Source Code module legendre use iso_fortran_env , only : wp => real64 use misc , only : func1 , func2 , r8mat_print use lib_array , only : linspace , invert_matrix use integration , only : integrate implicit none private :: basis_1D , vandermonde private :: integrate_basis_1d , integrate_basis_1d_Ie public :: getIe public :: linsolve_quick , linsolve contains subroutine getIe ( dx1 , dx2 , xcoords , Ie ) integer , intent ( in ) :: dx1 , dx2 real ( wp ), intent ( in ), dimension (:) :: xcoords real ( wp ), intent ( out ), dimension (:,:) :: Ie integer :: ii , jj , order order = size ( xcoords ) - 1 do ii = 1 , size ( xcoords ) Ie ( ii , :) = [( integrate_basis_1d_Ie ( order , ii , jj , dx1 , dx2 , xcoords ), jj = 1 , order + 1 )] end do return end subroutine getIe function integrate_basis_1d_Ie ( N , ii , jj , dx1 , dx2 , xcoords ) result ( integral ) integer , intent ( in ) :: N , ii , jj , dx1 , dx2 real ( wp ), intent ( in ), dimension (:) :: xcoords real ( wp ) :: integral integer :: order , basis_num1 , basis_num2 real ( wp ), dimension (:, :), allocatable :: Vinv order = N basis_num1 = ii basis_num2 = jj allocate ( Vinv ( order + 1 , order + 1 )) call vandermonde ( order + 1 , Vinv ) ! Check to make sure xcoords is an array of size (N+1) if ( size ( xcoords ) /= order + 1 ) then write ( * , * ) 'The shape of `xcoords` is outside the acceptable range for a' write ( * , * ) '1D basis function.' write ( * , * ) 'Shape(xcoords) should be [' , 2 , order + 1 , '], not ' , shape ( xcoords ) end if ! Check to make sure requested basis number is within available basis ! if ( basis_num > order+1 ) then !   write(*,*) 'The basis_num input is larger than number of available basis' !   write(*,*) 'nodes (order+1). Make sure order and basis_num are correctly' !   write(*,*) 'set before calling' !   stop ! end if ! Check to make sure differentiation(s) is either 0 or 1 ! if ( (dx1 < 0 .or. dx1 > 1) .and. & !      (dx2 < 0 .or. dx2 > 1) ) then !   write(*,*) 'Derivatives of order lower than 0 or higher than 1 are not allowed' !   write(*,*) 'integrate_basis_1d_Ie was called with dx1, dx2 = ', dx1, dx2 !   write(*,*) 'Check to make sure that the function was called correctly' !   stop ! end if call integrate ( local_wrapper , - 1.0_wp , 1.0_wp , integral ) return contains subroutine XorJ ( s , dx , out ) integer , intent ( in ) :: dx real ( wp ), intent ( in ), dimension (:) :: s real ( wp ), intent ( out ), dimension (:) :: out integer :: ii out = 0.0_wp do ii = 1 , size ( xcoords ) out = out + basis_1D ( s , Vinv (:, ii ), dx ) * xcoords ( ii ) end do end subroutine XorJ subroutine local_wrapper ( s , y ) real ( wp ), intent ( in ), dimension (:) :: s real ( wp ), intent ( out ), dimension (:) :: y real ( wp ), dimension (:), allocatable :: J allocate ( J ( size ( s ))) call XorJ ( s , 1 , J ) ! write(*,*) dx1, dx2 y = 1.0_wp ! Here we have to be careful because J is not always needed in the first ! two function calls. Instead of using if statements, we can use an exponent so that when dx_ = 0, J is 1 y = y * basis_1D ( s , Vinv (:, basis_num1 ), dx1 ) / ( J ** real ( dx1 , wp )) y = y * basis_1D ( s , Vinv (:, basis_num2 ), dx2 ) / ( J ** real ( dx2 , wp )) y = y * J deallocate ( J ) return end subroutine local_wrapper end function integrate_basis_1d_Ie function integrate_basis_1d ( order , basis_num , dx ) result ( integral ) integer , intent ( in ) :: order , basis_num , dx real ( wp ) :: integral real ( wp ), dimension (:, :), allocatable :: Vinv allocate ( Vinv ( order + 1 , order + 1 )) call vandermonde ( order + 1 , Vinv ) ! call r8mat_print(order+1, order+1, Vinv, 'Inverse Vandermonde') ! Check to make sure requested basis number is within available basis if ( basis_num > order + 1 ) then write ( * , * ) 'The basis_num input is larger than number of available basis nodes (order+1)' write ( * , * ) 'Make sure order and basis_num are correctly set before calling' stop end if ! Check to make sure differentiation is either 0 or 1 if ( dx < 0 . or . dx > 1 ) then write ( * , * ) 'Derivatives of order lower than 0 or higher than 1 are not allowed' write ( * , * ) 'integrate_basis_1d was called with dx = ' , dx write ( * , * ) 'Check to make sure that the function was called correctly' stop end if call integrate ( local_basis_1D , - 1.0_wp , 1.0_wp , integral ) deallocate ( Vinv ) return contains subroutine local_basis_1D ( x , y ) real ( wp ), intent ( in ), dimension (:) :: x real ( wp ), intent ( out ), dimension (:) :: y y = basis_1D ( x , Vinv (:, basis_num ), dx ) return end subroutine local_basis_1D end function integrate_basis_1d function basis_1D ( x , alpha , dx ) result ( y ) ! Input/output variables integer , intent ( in ) :: dx real ( wp ), intent ( in ), dimension (:) :: x real ( wp ), intent ( in ), dimension (:) :: alpha real ( wp ), dimension (:), allocatable :: y , yx ! Local variables integer :: ii , N allocate ( y ( size ( x )), yx ( size ( x ))) N = size ( alpha ) y = 0.0 d0 do ii = 1 + dx , N if ( dx == 0 ) then yx = alpha ( ii ) * x ** real ( ii - 1 , wp ) else ! Hoping for the best that dx == 1 yx = real ( ii - 1 , wp ) * alpha ( ii ) * ( x ) ** ( real ( ii - 1 - dx , wp )) end if y = y + yx end do return end function basis_1D subroutine vandermonde ( n , Vinv ) integer :: ii , jj integer :: n real ( wp ), dimension ( n ) :: x real ( wp ), dimension (( n ) ** 2 ) :: V_flat real ( wp ), dimension ( n , n ) :: V , Vinv , eye call linspace ( - 1.0 d0 , 1.0 d0 , x ) V_flat = [( [( [ x ( ii ) ** real ( jj - 1 , wp )], ii = 1 , n )], jj = 1 , n )] V = reshape ([ V_flat ], [ n , n ]) ! call r8mat_print(n, n, V, 'Original V Matrix: ') eye = 0.0 d0 do ii = 1 , n eye ( ii , ii ) = 1.0 d0 end do call linsolve_quick ( n , V , n , eye , Vinv ) return end subroutine vandermonde subroutine linsolve_quick ( n , a , nrhs , b , x ) ! Quick wrapper around linsolve integer , intent ( in ) :: n , nrhs real ( wp ), intent ( in ), dimension ( n , n ) :: a real ( wp ), intent ( in ), dimension ( n , nrhs ) :: b real ( wp ), intent ( out ), dimension ( n , nrhs ) :: x integer , dimension ( n ) :: P real ( wp ), dimension ( n , n ) :: LU call linsolve ( n , a , nrhs , b , x , LU , P , . False .) return end subroutine linsolve_quick subroutine linsolve ( n , a , nrhs , b , x , LU , P , toggle ) ! This routine is a wrapper dgesv, splitting it into its two primary ! components: !             dgetrf - Decomposes A into P*L*U !             dgetrs - Uses P*L*U to solve for x (Ax=b => (P*L*U)x=b) ! ! Splitting these two up like this allows you to save the decomposed ! version of 'a' so that you don't have to do it again. If 'toggle' is ! equal to true, then the decomposition has already occured and LU can be ! trusted - OK to skip dgetrf ! Dummy variables integer , intent ( in ) :: n , nrhs integer , intent ( inout ), dimension ( n ) :: P real ( wp ), intent ( in ), dimension ( n , nrhs ) :: b real ( wp ), intent ( in ), dimension ( n , n ) :: a real ( wp ), intent ( out ), dimension ( n , nrhs ) :: x real ( wp ), intent ( inout ), dimension ( n , n ) :: LU logical , intent ( in ) :: toggle ! Local variables integer :: info integer , dimension ( n ) :: my_P real ( wp ), dimension ( n , n ) :: my_a real ( wp ), dimension ( n , nrhs ) :: my_b my_a = a my_b = b if ( . not . toggle ) then call dgetrf ( n , n , my_a , n , my_P , info ) if ( info /= 0 ) then write ( * , '(a)' ) ' ' write ( * , '(a)' ) 'DGETRF' write ( * , '(a,i8)' ) '  Factorization failed, INFO = ' , info stop end if LU = my_a P = my_P end if call dgetrs ( 'No transpose' , n , nrhs , LU , n , P , my_b , n , info ) if ( info /= 0 ) then write ( * , '(a)' ) ' ' write ( * , '(a)' ) 'DGETRS' write ( * , '(a,i8)' ) '  Back substitution failed, INFO = ' , info stop end if x = my_b return end subroutine linsolve end module legendre","tags":""},{"title":"main.f90 – learn_dg","loc":"sourcefile/main.f90.html","text":"This File Depends On sourcefile~~main.f90~~EfferentGraph sourcefile~main.f90 main.f90 sourcefile~misc.f90 misc.f90 sourcefile~misc.f90->sourcefile~main.f90 sourcefile~legendre.f90 legendre.f90 sourcefile~misc.f90->sourcefile~legendre.f90 sourcefile~legendre.f90->sourcefile~main.f90 sourcefile~io.f90 io.f90 sourcefile~io.f90->sourcefile~main.f90 sourcefile~integration.f90 integration.f90 sourcefile~integration.f90->sourcefile~legendre.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Programs main Source Code main.f90 Source Code program main use iso_fortran_env , only : wp => real64 use legendre , only : getIe , linsolve_quick use misc , only : r8mat_print use io , only : get_command_argument_wrapper , read_gmsh_file_1D implicit none integer :: ii , jj , num_nodes , ios real ( wp ) :: vel = - 1.0_wp , diff = 0.5_wp real ( wp ) :: r ! integer :: order = 4 ! real(wp), dimension(:),   allocatable :: xcoords ! real(wp), dimension(:,:), allocatable :: Ie integer , dimension (:), allocatable :: orderN integer , dimension (:,:), allocatable :: elem_connN real ( wp ), dimension (:), allocatable :: xcoordsN , GlobalB , GlobalX real ( wp ), dimension (:), allocatable :: analytical real ( wp ), dimension (:,:), allocatable :: IeN , GlobalA character ( len = 50 ) :: arg ! allocate(xcoords(order+1)) ! allocate(Ie(order+1, order+1)) ! xcoords = [0.0_wp, 1.2_wp, 1.9_wp, 2.5_wp, 3.0_wp] ! ! do ii = 1, order+1 !   Ie(ii, :) = [( integrate_basis_1d_Ie(order, ii, jj, 1, 1, xcoords), jj = 1, order+1 )] ! end do ! ! call getIe(1, 1, xcoords, Ie) ! call r8mat_print(order+1, order+1, Ie, 'Elemental Stiffness matrix:') ! ! deallocate(xcoords, Ie) call get_command_argument_wrapper ( arg ) call read_gmsh_file_1D ( arg , num_nodes , orderN , elem_connN , xcoordsN ) ! write(*,*) orderN(1), elem_connN(1,:), xcoordsN(elem_connN(1,:)) allocate ( GlobalA ( num_nodes , num_nodes )) allocate ( GlobalB ( num_nodes )) allocate ( GlobalX ( num_nodes )) allocate ( analytical ( num_nodes )) GlobalA (:,:) = 0.0_wp GlobalB (:) = 0.0_wp GlobalB ( 1 ) = 0.0_wp GlobalB ( 2 ) = 1.0_wp GlobalX (:) = 0.0_wp call r8mat_print ( num_nodes , 1 , GlobalB , 'Global RHS:' ) ! Add elemental stiffness matrices to Global Stiffness Matrix do ii = 1 , size ( orderN ) ! Reallocate elemental stiffness matrix allocate ( IeN ( orderN ( ii ) + 1 , orderN ( ii ) + 1 )) call getIe ( 1 , 1 , xcoordsN ( elem_connN ( ii ,:)), IeN ) ! call r8mat_print(orderN(ii)+1, orderN(ii)+1, IeN, 'Elemental Stiffness Matrix:') GlobalA ( elem_connN ( ii ,:), elem_connN ( ii ,:)) = & GlobalA ( elem_connN ( ii ,:), elem_connN ( ii ,:)) - diff * IeN ! deallocate(IeN) ! allocate(IeN(orderN(ii)+1, orderN(ii)+1)) call getIe ( 0 , 1 , xcoordsN ( elem_connN ( ii ,:)), IeN ) ! call r8mat_print(orderN(ii)+1, orderN(ii)+1, IeN, 'Elemental Stiffness Matrix:') GlobalA ( elem_connN ( ii ,:), elem_connN ( ii ,:)) = & GlobalA ( elem_connN ( ii ,:), elem_connN ( ii ,:)) - vel * IeN ! Deallocate elemental stiffness matrix after every loop deallocate ( IeN ) ! stop end do ! call r8mat_print(num_nodes, num_nodes, GlobalA, 'Global Stiffness Matrix:') GlobalA ( 1 ,:) = 0.0_wp GlobalA ( 1 , 1 ) = 1.0_wp GlobalA ( 2 ,:) = 0.0_wp GlobalA ( 2 , 2 ) = 1.0_wp ! call r8mat_print(num_nodes, num_nodes, GlobalA, 'Global Stiffness matrix:') call linsolve_quick ( num_nodes , GlobalA , 1 , GlobalB , GlobalX ) ! call r8mat_print(num_nodes, 1, GlobalB, 'Global RHS:') call r8mat_print ( num_nodes , 1 , GlobalX , 'Global Solution Vector:' ) open ( unit = 21 , file = 'data.out' , iostat = ios , status = \"replace\" , action = \"write\" ) if ( ios /= 0 ) stop \"Error opening file 21\" r = vel / diff ! do ii = 1, num_nodes !   write(*,*) (1.0_wp-exp(xcoordsN(ii))) / (1.0_wp - exp(1.0_wp)) ! end do ! stop analytical = ( 1.0_wp - dexp ( r * xcoordsN )) / ( 1.0_wp - dexp ( r ) ) do ii = 1 , num_nodes write ( 21 , * ) xcoordsN ( ii ), GlobalX ( ii ), analytical ( ii ) end do write ( * , * ) write ( * , * ) norm2 ([ GlobalX - analytical ]) close ( unit = 21 , iostat = ios ) if ( ios /= 0 ) stop \"Error closing file unit 21\" if ( allocated ( orderN ) ) deallocate ( orderN ) if ( allocated ( elem_connN ) ) deallocate ( elem_connN ) if ( allocated ( xcoordsN ) ) deallocate ( xcoordsN ) if ( allocated ( GlobalA ) ) deallocate ( GlobalA ) if ( allocated ( GlobalB ) ) deallocate ( GlobalB ) if ( allocated ( GlobalX ) ) deallocate ( GlobalX ) if ( allocated ( analytical ) ) deallocate ( analytical ) end program main","tags":""},{"title":"misc.f90 – learn_dg","loc":"sourcefile/misc.f90.html","text":"Files Dependent On This One sourcefile~~misc.f90~~AfferentGraph sourcefile~misc.f90 misc.f90 sourcefile~legendre.f90 legendre.f90 sourcefile~misc.f90->sourcefile~legendre.f90 sourcefile~main.f90 main.f90 sourcefile~misc.f90->sourcefile~main.f90 sourcefile~legendre.f90->sourcefile~main.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Modules misc Source Code misc.f90 Source Code module misc use iso_fortran_env , only : wp => real64 implicit none abstract interface pure function func1 ( xx ) result ( yy ) import wp real ( wp ), intent ( in ), dimension (:) :: xx real ( wp ), dimension (:), allocatable :: yy end function func1 pure function func2 ( xx , aa ) result ( yy ) import wp real ( wp ), intent ( in ), dimension (:) :: xx , aa real ( wp ), dimension (:), allocatable :: yy end function func2 end interface contains subroutine r8mat_print ( m , n , a , title ) !*****************************************************************************80 ! !! R8MAT_PRINT prints an R8MAT. ! !  Discussion: ! !    An R8MAT is a two dimensional matrix of double precision real values. ! !  Licensing: ! !    This code is distributed under the GNU LGPL license. ! !  Modified: ! !    12 September 2004 ! !  Author: ! !    John Burkardt ! !  Parameters: ! !    Input, integer M, the number of rows in A. ! !    Input, integer N, the number of columns in A. ! !    Input, real ( kind = 8 ) A(M,N), the matrix. ! !    Input, character ( len = * ) TITLE, a title to be printed. ! implicit none integer ( kind = 4 ) m integer ( kind = 4 ) n real ( kind = 8 ) a ( m , n ) character ( len = * ) title call r8mat_print_some ( m , n , a , 1 , 1 , m , n , title ) return end subroutine r8mat_print_some ( m , n , a , ilo , jlo , ihi , jhi , title ) !*****************************************************************************80 ! !! R8MAT_PRINT_SOME prints some of an R8MAT. ! !  Discussion: ! !    An R8MAT is a two dimensional matrix of double precision real values. ! !  Licensing: ! !    This code is distributed under the GNU LGPL license. ! !  Modified: ! !    26 March 2005 ! !  Author: ! !    John Burkardt ! !  Parameters: ! !    Input, integer M, N, the number of rows and columns. ! !    Input, real ( kind = 8 ) A(M,N), an M by N matrix to be printed. ! !    Input, integer ILO, JLO, the first row and column to print. ! !    Input, integer IHI, JHI, the last row and column to print. ! !    Input, character ( len = * ) TITLE, an optional title. ! implicit none integer ( kind = 4 ), parameter :: incx = 5 integer ( kind = 4 ) m integer ( kind = 4 ) n real ( kind = 8 ) a ( m , n ) character ( len = 14 ) ctemp ( incx ) integer ( kind = 4 ) i integer ( kind = 4 ) i2hi integer ( kind = 4 ) i2lo integer ( kind = 4 ) ihi integer ( kind = 4 ) ilo integer ( kind = 4 ) inc integer ( kind = 4 ) j integer ( kind = 4 ) j2 integer ( kind = 4 ) j2hi integer ( kind = 4 ) j2lo integer ( kind = 4 ) jhi integer ( kind = 4 ) jlo character ( len = * ) title if ( 0 < len_trim ( title ) ) then write ( * , '(a)' ) ' ' write ( * , '(a)' ) trim ( title ) end if do j2lo = max ( jlo , 1 ), min ( jhi , n ), incx j2hi = j2lo + incx - 1 j2hi = min ( j2hi , n ) j2hi = min ( j2hi , jhi ) inc = j2hi + 1 - j2lo write ( * , '(a)' ) ' ' do j = j2lo , j2hi j2 = j + 1 - j2lo write ( ctemp ( j2 ), '(i8,6x)' ) j end do write ( * , '(''  Col   '',5a14)' ) ctemp ( 1 : inc ) write ( * , '(a)' ) '  Row' write ( * , '(a)' ) ' ' i2lo = max ( ilo , 1 ) i2hi = min ( ihi , m ) do i = i2lo , i2hi do j2 = 1 , inc j = j2lo - 1 + j2 if ( a ( i , j ) == real ( int ( a ( i , j ) ), kind = 8 ) ) then write ( ctemp ( j2 ), '(f8.0,6x)' ) a ( i , j ) else write ( ctemp ( j2 ), '(g14.6)' ) a ( i , j ) end if end do write ( * , '(i5,1x,5a14)' ) i , ( ctemp ( j ), j = 1 , inc ) end do end do write ( * , '(a)' ) ' ' return end end module misc","tags":""},{"title":"func1 – learn_dg","loc":"interface/func1.html","text":"abstract interface public pure function func1(xx) result(yy) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: xx Return Value real(kind=wp),\n  dimension(:),allocatable","tags":""},{"title":"func2 – learn_dg","loc":"interface/func2.html","text":"abstract interface public pure function func2(xx, aa) result(yy) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: xx real(kind=wp), intent(in), dimension(:) :: aa Return Value real(kind=wp),\n  dimension(:),allocatable","tags":""},{"title":"cgwt – learn_dg","loc":"proc/cgwt.html","text":"public subroutine cgwt(num_pts, x, w) Arguments Type Intent Optional Attributes Name integer, intent(in) :: num_pts real(kind=wp), intent(out), dimension(:) :: x real(kind=wp), intent(out), dimension(:) :: w Calls proc~~cgwt~~CallsGraph proc~cgwt cgwt dcos dcos proc~cgwt->dcos Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code cgwt Source Code subroutine cgwt ( num_pts , x , w ) ! This function  determines the points and weights associated with Chebyshev-Gauss quadrature ! Variables in/out integer , intent ( in ) :: num_pts real ( wp ), intent ( out ), dimension (:) :: x , w ! Local variables integer :: ii real ( wp ), parameter :: pi = 4.0_wp * datan ( 1.0_wp ) x = dcos (( real ( 2 * [( ii , ii = 1 , num_pts )] - 1 , wp )) / real ( 2 * num_pts , wp ) * pi ) w = pi / real ( num_pts , wp ) / (( 1.0_wp - x ** 2.0_wp ) ** ( - 0.5_wp )) ! write(*,*) x ! write(*,*) w ! stop return end subroutine cgwt","tags":""},{"title":"gaussquad – learn_dg","loc":"proc/gaussquad.html","text":"public subroutine gaussquad(n, r1, r2) Arguments Type Intent Optional Attributes Name integer :: n real(kind=wp) :: r1 (:) real(kind=wp) :: r2 (:) Called By proc~~gaussquad~~CalledByGraph proc~gaussquad gaussquad proc~integrate integrate proc~integrate->proc~gaussquad proc~integrate_basis_1d_ie integrate_basis_1d_Ie proc~integrate_basis_1d_ie->proc~integrate proc~integrate_basis_1d integrate_basis_1d proc~integrate_basis_1d->proc~integrate proc~getie getIe proc~getie->proc~integrate_basis_1d_ie Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs.","tags":""},{"title":"integrate – learn_dg","loc":"proc/integrate.html","text":"public subroutine integrate(sub, a, b, result) Arguments Type Intent Optional Attributes Name public subroutine sub(xx, yy) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: xx real(kind=wp), intent(out), dimension(:) :: yy real(kind=wp), intent(in) :: a real(kind=wp), intent(in) :: b real(kind=wp), intent(out) :: result Calls proc~~integrate~~CallsGraph proc~integrate integrate proc~gaussquad gaussquad proc~integrate->proc~gaussquad Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called By proc~~integrate~~CalledByGraph proc~integrate integrate proc~integrate_basis_1d_ie integrate_basis_1d_Ie proc~integrate_basis_1d_ie->proc~integrate proc~integrate_basis_1d integrate_basis_1d proc~integrate_basis_1d->proc~integrate proc~getie getIe proc~getie->proc~integrate_basis_1d_ie Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code integrate Source Code subroutine integrate ( sub , a , b , result ) ! This routine uses gauss-legendre quadrature to integrate a 1D function ! Input/Output variables real ( wp ), intent ( in ) :: a , b real ( wp ), intent ( out ) :: result interface subroutine sub ( xx , yy ) import wp real ( wp ), intent ( in ), dimension (:) :: xx real ( wp ), intent ( out ), dimension (:) :: yy end subroutine sub end interface ! Local variables integer :: N real ( wp ) :: result_old , error real ( wp ), parameter :: eps = sqrt ( epsilon ( 1.0_wp )) real ( wp ), dimension (:), allocatable :: x , w , y N = 3 result = 0.0_wp error = 1.0_wp do result_old = result allocate ( x ( N ), w ( N ), y ( N )) ! call cgwt(N, x, w) ! call lgwt(a, b, N, x, w) call gaussquad ( N , x , w ) call sub ( x , y ) result = sum ( y * w ) deallocate ( x , w , y ) ! error = norm2([result, result_old]) error = sqrt (( result - result_old ) ** 2.0_wp ) ! error = abs((result-result_old)/(result_old+eps)) ! write(*,*) N, result, error ! write(*,*) N, result, result_old, error, eps ! Check if error is acceptable, as well as whether the loop was gone ! through at least twice (N = 3, 4, 5...) if ( ( error < eps . or . abs ( result ) < eps ) & . and . N > 5 ) then exit else N = N + 1 end if end do return end subroutine integrate","tags":""},{"title":"lgwt – learn_dg","loc":"proc/lgwt.html","text":"private subroutine lgwt(a, b, num_pts, x, w) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a real(kind=wp), intent(in) :: b integer, intent(in) :: num_pts real(kind=wp), intent(out), dimension(:) :: x real(kind=wp), intent(out), dimension(:) :: w Calls proc~~lgwt~~CallsGraph proc~lgwt lgwt linspace linspace proc~lgwt->linspace dcos dcos proc~lgwt->dcos dsin dsin proc~lgwt->dsin Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code lgwt Source Code subroutine lgwt ( a , b , num_pts , x , w ) ! This function is a fortran90 port of the matlab function, lgwt.m ! The source code of lgwt.m was originally found at: ! ! http://www.mathworks.com/matlabcentral/fileexchange/4540 ! Variables in/out integer , intent ( in ) :: num_pts real ( wp ), intent ( in ) :: a , b real ( wp ), intent ( out ), dimension (:) :: x , w ! Local variables integer :: ii , jj , N , N1 , N2 ! real(wp), parameter:: eps=sqrt(epsilon(1.0_wp)) real ( wp ), parameter :: eps = 1 d - 10 real ( wp ), dimension (:), allocatable :: xu , array1 , y , y0 , Lpp real ( wp ), dimension (:, :), allocatable :: L , Lp real ( wp ), parameter :: pi = 4.0_wp * datan ( 1.0_wp ) N = num_pts - 1 N1 = N + 1 N2 = N + 2 ! Allocate and initialize arrays allocate ( xu ( N1 ), array1 ( N1 ), y ( N1 ), y0 ( N1 )) allocate ( L ( N1 , N2 ), Lp ( N1 , N2 ), Lpp ( N1 )) L = 0.0_wp Lp = 0.0_wp call linspace ( - 1.0_wp , 1.0_wp , xu ) array1 = [ ( ii , ii = 0 , N ) ] ! Initial guess of ??? y = dcos (( 2.0_wp * real ( array1 , wp ) + 1.0_wp ) * & pi / ( 2.0_wp * real ( N , wp ) + 2.0_wp )) + & ( 0.27_wp / real ( N1 , wp )) * dsin ( pi * xu * real ( N , wp ) / real ( N2 , wp )) y0 = 2.0_wp do L (:, 1 ) = 1.0_wp Lp (:, 1 ) = 0.0_wp L (:, 2 ) = y Lp (:, 2 ) = 1.0_wp do jj = 2 , N1 L (:, jj + 1 ) = ( ( 2.0_wp * real ( jj , wp ) - 1.0_wp ) * y * L (:, jj ) - & real ( jj - 1 , wp ) * L (:, jj - 1 )) / real ( jj , wp ) end do Lpp = real ( N2 , wp ) * ( L (:, N1 ) - y * L (:, N2 )) / ( 1.0_wp - y ** 2.0_wp ) y0 = y y = y0 - L (:, N2 ) / Lpp if ( norm2 ( y - y0 ) < eps ) then exit end if end do x = ( a * ( 1.0_wp - y ) + b * ( 1.0_wp + y ) ) / 2.0_wp w = ( b - a ) / (( 1.0_wp - y ** 2.0_wp ) * Lpp ** 2.0_wp ) * & ( real ( N2 , wp ) / real ( N1 , wp )) ** 2.0_wp return end subroutine lgwt","tags":""},{"title":"get_command_argument_wrapper – learn_dg","loc":"proc/get_command_argument_wrapper.html","text":"public subroutine get_command_argument_wrapper(arg) Arguments Type Intent Optional Attributes Name character(len=*), intent(out) :: arg Called By proc~~get_command_argument_wrapper~~CalledByGraph proc~get_command_argument_wrapper get_command_argument_wrapper program~main main program~main->proc~get_command_argument_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code get_command_argument_wrapper Source Code subroutine get_command_argument_wrapper ( arg ) character ( * ), intent ( out ) :: arg integer :: ii ii = 1 do call get_command_argument ( ii , arg ) if ( len_trim ( arg ) == 0 ) then arg = trim ( arg ) else exit end if ii = ii + 1 end do return end subroutine get_command_argument_wrapper","tags":""},{"title":"read_gmsh_file_1D – learn_dg","loc":"proc/read_gmsh_file_1d.html","text":"public subroutine read_gmsh_file_1D(filename, num_nodes, order, elem_conn, xcoords) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename integer, intent(out) :: num_nodes integer, intent(out), dimension(:), allocatable :: order integer, intent(out), dimension(:,:), allocatable :: elem_conn real(kind=wp), intent(out), dimension(:), allocatable :: xcoords Source Code read_gmsh_file_1D Source Code subroutine read_gmsh_file_1D ( filename , num_nodes , order , elem_conn , xcoords ) integer , intent ( out ) :: num_nodes integer , intent ( out ), dimension (:), allocatable :: order integer , intent ( out ), dimension (:,:), allocatable :: elem_conn real ( wp ), intent ( out ), dimension (:), allocatable :: xcoords character ( * ), intent ( in ) :: filename integer :: ii , ios , num_elements , d_int real ( wp ) :: d_real character ( 50 ) :: blank_string ! write(*,*) filename open ( unit = 21 , file = filename , iostat = ios , status = \"old\" , action = \"read\" ) if ( ios /= 0 ) stop \"Error opening file \" ! Read initial header information - assuming file is correct format do read ( 21 , * ) blank_string if ( trim ( blank_string ) == '$Nodes' ) exit end do ! Read number of nodes read ( 21 , * ) num_nodes allocate ( xcoords ( num_nodes )) ! Read coordinate information for each node do ii = 1 , num_nodes read ( 21 , * ) d_int , xcoords ( ii ), d_real , d_real end do ! Two dummy lines - $EndNodes and $Elements read ( 21 , * ) read ( 21 , * ) read ( 21 , * ) num_elements num_elements = num_elements - 2 allocate ( order ( num_elements )) allocate ( elem_conn ( num_elements , 2 )) ! Initialize all elements as first order linear elements order = 1 ! Two dummy lines - Associated with 'point' elements read ( 21 , * ) read ( 21 , * ) do ii = 1 , num_elements read ( 21 , * ) d_int , d_int , d_int , d_int , d_int , elem_conn ( ii , 1 : 2 ) end do ! do ii = 1, size(order) !   write(*,*) order(ii), elem_conn(ii, :) ! end do ! write(*,*) ! ! do ii = 1, size(xcoords) !   write(*,*) xcoords(ii) ! end do ! write(*,*) close ( unit = 21 , iostat = ios , status = \"delete\" ) if ( ios /= 0 ) stop \"Error closing file unit 21\" return end subroutine read_gmsh_file_1D","tags":""},{"title":"basis_1D – learn_dg","loc":"proc/basis_1d.html","text":"private function basis_1D(x, alpha, dx) result(y) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: x real(kind=wp), intent(in), dimension(:) :: alpha integer, intent(in) :: dx Return Value real(kind=wp),\n  dimension(:),allocatable Source Code basis_1D Source Code function basis_1D ( x , alpha , dx ) result ( y ) ! Input/output variables integer , intent ( in ) :: dx real ( wp ), intent ( in ), dimension (:) :: x real ( wp ), intent ( in ), dimension (:) :: alpha real ( wp ), dimension (:), allocatable :: y , yx ! Local variables integer :: ii , N allocate ( y ( size ( x )), yx ( size ( x ))) N = size ( alpha ) y = 0.0 d0 do ii = 1 + dx , N if ( dx == 0 ) then yx = alpha ( ii ) * x ** real ( ii - 1 , wp ) else ! Hoping for the best that dx == 1 yx = real ( ii - 1 , wp ) * alpha ( ii ) * ( x ) ** ( real ( ii - 1 - dx , wp )) end if y = y + yx end do return end function basis_1D","tags":""},{"title":"integrate_basis_1d – learn_dg","loc":"proc/integrate_basis_1d.html","text":"private function integrate_basis_1d(order, basis_num, dx) result(integral) Arguments Type Intent Optional Attributes Name integer, intent(in) :: order integer, intent(in) :: basis_num integer, intent(in) :: dx Return Value real(kind=wp) Calls proc~~integrate_basis_1d~~CallsGraph proc~integrate_basis_1d integrate_basis_1d proc~vandermonde vandermonde proc~integrate_basis_1d->proc~vandermonde proc~integrate integrate proc~integrate_basis_1d->proc~integrate linspace linspace proc~vandermonde->linspace proc~linsolve_quick linsolve_quick proc~vandermonde->proc~linsolve_quick proc~gaussquad gaussquad proc~integrate->proc~gaussquad proc~linsolve linsolve proc~linsolve_quick->proc~linsolve dgetrf dgetrf proc~linsolve->dgetrf dgetrs dgetrs proc~linsolve->dgetrs Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code integrate_basis_1d Source Code function integrate_basis_1d ( order , basis_num , dx ) result ( integral ) integer , intent ( in ) :: order , basis_num , dx real ( wp ) :: integral real ( wp ), dimension (:, :), allocatable :: Vinv allocate ( Vinv ( order + 1 , order + 1 )) call vandermonde ( order + 1 , Vinv ) ! call r8mat_print(order+1, order+1, Vinv, 'Inverse Vandermonde') ! Check to make sure requested basis number is within available basis if ( basis_num > order + 1 ) then write ( * , * ) 'The basis_num input is larger than number of available basis nodes (order+1)' write ( * , * ) 'Make sure order and basis_num are correctly set before calling' stop end if ! Check to make sure differentiation is either 0 or 1 if ( dx < 0 . or . dx > 1 ) then write ( * , * ) 'Derivatives of order lower than 0 or higher than 1 are not allowed' write ( * , * ) 'integrate_basis_1d was called with dx = ' , dx write ( * , * ) 'Check to make sure that the function was called correctly' stop end if call integrate ( local_basis_1D , - 1.0_wp , 1.0_wp , integral ) deallocate ( Vinv ) return contains subroutine local_basis_1D ( x , y ) real ( wp ), intent ( in ), dimension (:) :: x real ( wp ), intent ( out ), dimension (:) :: y y = basis_1D ( x , Vinv (:, basis_num ), dx ) return end subroutine local_basis_1D end function integrate_basis_1d","tags":""},{"title":"integrate_basis_1d_Ie – learn_dg","loc":"proc/integrate_basis_1d_ie.html","text":"private function integrate_basis_1d_Ie(N, ii, jj, dx1, dx2, xcoords) result(integral) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N integer, intent(in) :: ii integer, intent(in) :: jj integer, intent(in) :: dx1 integer, intent(in) :: dx2 real(kind=wp), intent(in), dimension(:) :: xcoords Return Value real(kind=wp) Calls proc~~integrate_basis_1d_ie~~CallsGraph proc~integrate_basis_1d_ie integrate_basis_1d_Ie proc~vandermonde vandermonde proc~integrate_basis_1d_ie->proc~vandermonde proc~integrate integrate proc~integrate_basis_1d_ie->proc~integrate linspace linspace proc~vandermonde->linspace proc~linsolve_quick linsolve_quick proc~vandermonde->proc~linsolve_quick proc~gaussquad gaussquad proc~integrate->proc~gaussquad proc~linsolve linsolve proc~linsolve_quick->proc~linsolve dgetrf dgetrf proc~linsolve->dgetrf dgetrs dgetrs proc~linsolve->dgetrs Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called By proc~~integrate_basis_1d_ie~~CalledByGraph proc~integrate_basis_1d_ie integrate_basis_1d_Ie proc~getie getIe proc~getie->proc~integrate_basis_1d_ie Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code integrate_basis_1d_Ie Source Code function integrate_basis_1d_Ie ( N , ii , jj , dx1 , dx2 , xcoords ) result ( integral ) integer , intent ( in ) :: N , ii , jj , dx1 , dx2 real ( wp ), intent ( in ), dimension (:) :: xcoords real ( wp ) :: integral integer :: order , basis_num1 , basis_num2 real ( wp ), dimension (:, :), allocatable :: Vinv order = N basis_num1 = ii basis_num2 = jj allocate ( Vinv ( order + 1 , order + 1 )) call vandermonde ( order + 1 , Vinv ) ! Check to make sure xcoords is an array of size (N+1) if ( size ( xcoords ) /= order + 1 ) then write ( * , * ) 'The shape of `xcoords` is outside the acceptable range for a' write ( * , * ) '1D basis function.' write ( * , * ) 'Shape(xcoords) should be [' , 2 , order + 1 , '], not ' , shape ( xcoords ) end if ! Check to make sure requested basis number is within available basis ! if ( basis_num > order+1 ) then !   write(*,*) 'The basis_num input is larger than number of available basis' !   write(*,*) 'nodes (order+1). Make sure order and basis_num are correctly' !   write(*,*) 'set before calling' !   stop ! end if ! Check to make sure differentiation(s) is either 0 or 1 ! if ( (dx1 < 0 .or. dx1 > 1) .and. & !      (dx2 < 0 .or. dx2 > 1) ) then !   write(*,*) 'Derivatives of order lower than 0 or higher than 1 are not allowed' !   write(*,*) 'integrate_basis_1d_Ie was called with dx1, dx2 = ', dx1, dx2 !   write(*,*) 'Check to make sure that the function was called correctly' !   stop ! end if call integrate ( local_wrapper , - 1.0_wp , 1.0_wp , integral ) return contains subroutine XorJ ( s , dx , out ) integer , intent ( in ) :: dx real ( wp ), intent ( in ), dimension (:) :: s real ( wp ), intent ( out ), dimension (:) :: out integer :: ii out = 0.0_wp do ii = 1 , size ( xcoords ) out = out + basis_1D ( s , Vinv (:, ii ), dx ) * xcoords ( ii ) end do end subroutine XorJ subroutine local_wrapper ( s , y ) real ( wp ), intent ( in ), dimension (:) :: s real ( wp ), intent ( out ), dimension (:) :: y real ( wp ), dimension (:), allocatable :: J allocate ( J ( size ( s ))) call XorJ ( s , 1 , J ) ! write(*,*) dx1, dx2 y = 1.0_wp ! Here we have to be careful because J is not always needed in the first ! two function calls. Instead of using if statements, we can use an exponent so that when dx_ = 0, J is 1 y = y * basis_1D ( s , Vinv (:, basis_num1 ), dx1 ) / ( J ** real ( dx1 , wp )) y = y * basis_1D ( s , Vinv (:, basis_num2 ), dx2 ) / ( J ** real ( dx2 , wp )) y = y * J deallocate ( J ) return end subroutine local_wrapper end function integrate_basis_1d_Ie","tags":""},{"title":"getIe – learn_dg","loc":"proc/getie.html","text":"public subroutine getIe(dx1, dx2, xcoords, Ie) Arguments Type Intent Optional Attributes Name integer, intent(in) :: dx1 integer, intent(in) :: dx2 real(kind=wp), intent(in), dimension(:) :: xcoords real(kind=wp), intent(out), dimension(:,:) :: Ie Calls proc~~getie~~CallsGraph proc~getie getIe proc~integrate_basis_1d_ie integrate_basis_1d_Ie proc~getie->proc~integrate_basis_1d_ie proc~vandermonde vandermonde proc~integrate_basis_1d_ie->proc~vandermonde proc~integrate integrate proc~integrate_basis_1d_ie->proc~integrate linspace linspace proc~vandermonde->linspace proc~linsolve_quick linsolve_quick proc~vandermonde->proc~linsolve_quick proc~gaussquad gaussquad proc~integrate->proc~gaussquad proc~linsolve linsolve proc~linsolve_quick->proc~linsolve dgetrf dgetrf proc~linsolve->dgetrf dgetrs dgetrs proc~linsolve->dgetrs Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code getIe Source Code subroutine getIe ( dx1 , dx2 , xcoords , Ie ) integer , intent ( in ) :: dx1 , dx2 real ( wp ), intent ( in ), dimension (:) :: xcoords real ( wp ), intent ( out ), dimension (:,:) :: Ie integer :: ii , jj , order order = size ( xcoords ) - 1 do ii = 1 , size ( xcoords ) Ie ( ii , :) = [( integrate_basis_1d_Ie ( order , ii , jj , dx1 , dx2 , xcoords ), jj = 1 , order + 1 )] end do return end subroutine getIe","tags":""},{"title":"linsolve – learn_dg","loc":"proc/linsolve.html","text":"public subroutine linsolve(n, a, nrhs, b, x, LU, P, toggle) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=wp), intent(in), dimension(n, n) :: a integer, intent(in) :: nrhs real(kind=wp), intent(in), dimension(n, nrhs) :: b real(kind=wp), intent(out), dimension(n, nrhs) :: x real(kind=wp), intent(inout), dimension(n, n) :: LU integer, intent(inout), dimension(n) :: P logical, intent(in) :: toggle Calls proc~~linsolve~~CallsGraph proc~linsolve linsolve dgetrf dgetrf proc~linsolve->dgetrf dgetrs dgetrs proc~linsolve->dgetrs Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called By proc~~linsolve~~CalledByGraph proc~linsolve linsolve proc~linsolve_quick linsolve_quick proc~linsolve_quick->proc~linsolve proc~vandermonde vandermonde proc~vandermonde->proc~linsolve_quick program~main main program~main->proc~linsolve_quick proc~integrate_basis_1d_ie integrate_basis_1d_Ie proc~integrate_basis_1d_ie->proc~vandermonde proc~integrate_basis_1d integrate_basis_1d proc~integrate_basis_1d->proc~vandermonde proc~getie getIe proc~getie->proc~integrate_basis_1d_ie Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code linsolve Source Code subroutine linsolve ( n , a , nrhs , b , x , LU , P , toggle ) ! This routine is a wrapper dgesv, splitting it into its two primary ! components: !             dgetrf - Decomposes A into P*L*U !             dgetrs - Uses P*L*U to solve for x (Ax=b => (P*L*U)x=b) ! ! Splitting these two up like this allows you to save the decomposed ! version of 'a' so that you don't have to do it again. If 'toggle' is ! equal to true, then the decomposition has already occured and LU can be ! trusted - OK to skip dgetrf ! Dummy variables integer , intent ( in ) :: n , nrhs integer , intent ( inout ), dimension ( n ) :: P real ( wp ), intent ( in ), dimension ( n , nrhs ) :: b real ( wp ), intent ( in ), dimension ( n , n ) :: a real ( wp ), intent ( out ), dimension ( n , nrhs ) :: x real ( wp ), intent ( inout ), dimension ( n , n ) :: LU logical , intent ( in ) :: toggle ! Local variables integer :: info integer , dimension ( n ) :: my_P real ( wp ), dimension ( n , n ) :: my_a real ( wp ), dimension ( n , nrhs ) :: my_b my_a = a my_b = b if ( . not . toggle ) then call dgetrf ( n , n , my_a , n , my_P , info ) if ( info /= 0 ) then write ( * , '(a)' ) ' ' write ( * , '(a)' ) 'DGETRF' write ( * , '(a,i8)' ) '  Factorization failed, INFO = ' , info stop end if LU = my_a P = my_P end if call dgetrs ( 'No transpose' , n , nrhs , LU , n , P , my_b , n , info ) if ( info /= 0 ) then write ( * , '(a)' ) ' ' write ( * , '(a)' ) 'DGETRS' write ( * , '(a,i8)' ) '  Back substitution failed, INFO = ' , info stop end if x = my_b return end subroutine linsolve","tags":""},{"title":"linsolve_quick – learn_dg","loc":"proc/linsolve_quick.html","text":"public subroutine linsolve_quick(n, a, nrhs, b, x) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=wp), intent(in), dimension(n, n) :: a integer, intent(in) :: nrhs real(kind=wp), intent(in), dimension(n, nrhs) :: b real(kind=wp), intent(out), dimension(n, nrhs) :: x Calls proc~~linsolve_quick~~CallsGraph proc~linsolve_quick linsolve_quick proc~linsolve linsolve proc~linsolve_quick->proc~linsolve dgetrf dgetrf proc~linsolve->dgetrf dgetrs dgetrs proc~linsolve->dgetrs Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called By proc~~linsolve_quick~~CalledByGraph proc~linsolve_quick linsolve_quick proc~vandermonde vandermonde proc~vandermonde->proc~linsolve_quick program~main main program~main->proc~linsolve_quick proc~integrate_basis_1d_ie integrate_basis_1d_Ie proc~integrate_basis_1d_ie->proc~vandermonde proc~integrate_basis_1d integrate_basis_1d proc~integrate_basis_1d->proc~vandermonde proc~getie getIe proc~getie->proc~integrate_basis_1d_ie Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code linsolve_quick Source Code subroutine linsolve_quick ( n , a , nrhs , b , x ) ! Quick wrapper around linsolve integer , intent ( in ) :: n , nrhs real ( wp ), intent ( in ), dimension ( n , n ) :: a real ( wp ), intent ( in ), dimension ( n , nrhs ) :: b real ( wp ), intent ( out ), dimension ( n , nrhs ) :: x integer , dimension ( n ) :: P real ( wp ), dimension ( n , n ) :: LU call linsolve ( n , a , nrhs , b , x , LU , P , . False .) return end subroutine linsolve_quick","tags":""},{"title":"vandermonde – learn_dg","loc":"proc/vandermonde.html","text":"private subroutine vandermonde(n, Vinv) Arguments Type Intent Optional Attributes Name integer :: n real(kind=wp), dimension(n, n) :: Vinv Calls proc~~vandermonde~~CallsGraph proc~vandermonde vandermonde linspace linspace proc~vandermonde->linspace proc~linsolve_quick linsolve_quick proc~vandermonde->proc~linsolve_quick proc~linsolve linsolve proc~linsolve_quick->proc~linsolve dgetrf dgetrf proc~linsolve->dgetrf dgetrs dgetrs proc~linsolve->dgetrs Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called By proc~~vandermonde~~CalledByGraph proc~vandermonde vandermonde proc~integrate_basis_1d_ie integrate_basis_1d_Ie proc~integrate_basis_1d_ie->proc~vandermonde proc~integrate_basis_1d integrate_basis_1d proc~integrate_basis_1d->proc~vandermonde proc~getie getIe proc~getie->proc~integrate_basis_1d_ie Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code vandermonde Source Code subroutine vandermonde ( n , Vinv ) integer :: ii , jj integer :: n real ( wp ), dimension ( n ) :: x real ( wp ), dimension (( n ) ** 2 ) :: V_flat real ( wp ), dimension ( n , n ) :: V , Vinv , eye call linspace ( - 1.0 d0 , 1.0 d0 , x ) V_flat = [( [( [ x ( ii ) ** real ( jj - 1 , wp )], ii = 1 , n )], jj = 1 , n )] V = reshape ([ V_flat ], [ n , n ]) ! call r8mat_print(n, n, V, 'Original V Matrix: ') eye = 0.0 d0 do ii = 1 , n eye ( ii , ii ) = 1.0 d0 end do call linsolve_quick ( n , V , n , eye , Vinv ) return end subroutine vandermonde","tags":""},{"title":"r8mat_print – learn_dg","loc":"proc/r8mat_print.html","text":"public subroutine r8mat_print(m, n, a, title) * * * * * * * * * * * *80 R8MAT_PRINT prints an R8MAT. Arguments Type Intent Optional Attributes Name integer(kind=4) :: m integer(kind=4) :: n real(kind=8) :: a (m,n) character(len=*) :: title Calls proc~~r8mat_print~~CallsGraph proc~r8mat_print r8mat_print proc~r8mat_print_some r8mat_print_some proc~r8mat_print->proc~r8mat_print_some Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called By proc~~r8mat_print~~CalledByGraph proc~r8mat_print r8mat_print program~main main program~main->proc~r8mat_print Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs.","tags":""},{"title":"r8mat_print_some – learn_dg","loc":"proc/r8mat_print_some.html","text":"public subroutine r8mat_print_some(m, n, a, ilo, jlo, ihi, jhi, title) * * * * * * * * * * * *80 R8MAT_PRINT_SOME prints some of an R8MAT. Arguments Type Intent Optional Attributes Name integer(kind=4) :: m integer(kind=4) :: n real(kind=8) :: a (m,n) integer(kind=4) :: ilo integer(kind=4) :: jlo integer(kind=4) :: ihi integer(kind=4) :: jhi character(len=*) :: title Called By proc~~r8mat_print_some~~CalledByGraph proc~r8mat_print_some r8mat_print_some proc~r8mat_print r8mat_print proc~r8mat_print->proc~r8mat_print_some program~main main program~main->proc~r8mat_print Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs.","tags":""},{"title":"integration – learn_dg","loc":"module/integration.html","text":"Uses: iso_fortran_env lib_array module~~integration~~UsesGraph module~integration integration iso_fortran_env iso_fortran_env iso_fortran_env->module~integration lib_array lib_array lib_array->module~integration Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used By module~~integration~~UsedByGraph module~integration integration module~legendre legendre module~integration->module~legendre program~main main module~legendre->program~main Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Subroutines cgwt gaussquad integrate lgwt Subroutines public subroutine cgwt (num_pts, x, w) Arguments Type Intent Optional Attributes Name integer, intent(in) :: num_pts real(kind=wp), intent(out), dimension(:) :: x real(kind=wp), intent(out), dimension(:) :: w public subroutine gaussquad (n, r1, r2) Arguments Type Intent Optional Attributes Name integer :: n real(kind=wp) :: r1 (:) real(kind=wp) :: r2 (:) public subroutine integrate (sub, a, b, result) Arguments Type Intent Optional Attributes Name public subroutine sub(xx, yy) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: xx real(kind=wp), intent(out), dimension(:) :: yy real(kind=wp), intent(in) :: a real(kind=wp), intent(in) :: b real(kind=wp), intent(out) :: result private subroutine lgwt (a, b, num_pts, x, w) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a real(kind=wp), intent(in) :: b integer, intent(in) :: num_pts real(kind=wp), intent(out), dimension(:) :: x real(kind=wp), intent(out), dimension(:) :: w","tags":""},{"title":"io – learn_dg","loc":"module/io.html","text":"Uses: iso_fortran_env module~~io~~UsesGraph module~io io iso_fortran_env iso_fortran_env iso_fortran_env->module~io Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used By module~~io~~UsedByGraph module~io io program~main main module~io->program~main Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Subroutines get_command_argument_wrapper read_gmsh_file_1D Subroutines public subroutine get_command_argument_wrapper (arg) Arguments Type Intent Optional Attributes Name character(len=*), intent(out) :: arg public subroutine read_gmsh_file_1D (filename, num_nodes, order, elem_conn, xcoords) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename integer, intent(out) :: num_nodes integer, intent(out), dimension(:), allocatable :: order integer, intent(out), dimension(:,:), allocatable :: elem_conn real(kind=wp), intent(out), dimension(:), allocatable :: xcoords","tags":""},{"title":"legendre – learn_dg","loc":"module/legendre.html","text":"Uses: iso_fortran_env misc lib_array integration module~~legendre~~UsesGraph module~legendre legendre module~integration integration module~integration->module~legendre module~misc misc module~misc->module~legendre iso_fortran_env iso_fortran_env iso_fortran_env->module~legendre iso_fortran_env->module~integration iso_fortran_env->module~misc lib_array lib_array lib_array->module~legendre lib_array->module~integration Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used By module~~legendre~~UsedByGraph module~legendre legendre program~main main module~legendre->program~main Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Functions basis_1D integrate_basis_1d integrate_basis_1d_Ie Subroutines getIe linsolve linsolve_quick vandermonde Functions private function basis_1D (x, alpha, dx) result(y) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: x real(kind=wp), intent(in), dimension(:) :: alpha integer, intent(in) :: dx Return Value real(kind=wp),\n  dimension(:), allocatable private function integrate_basis_1d (order, basis_num, dx) result(integral) Arguments Type Intent Optional Attributes Name integer, intent(in) :: order integer, intent(in) :: basis_num integer, intent(in) :: dx Return Value real(kind=wp) private function integrate_basis_1d_Ie (N, ii, jj, dx1, dx2, xcoords) result(integral) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N integer, intent(in) :: ii integer, intent(in) :: jj integer, intent(in) :: dx1 integer, intent(in) :: dx2 real(kind=wp), intent(in), dimension(:) :: xcoords Return Value real(kind=wp) Subroutines public subroutine getIe (dx1, dx2, xcoords, Ie) Arguments Type Intent Optional Attributes Name integer, intent(in) :: dx1 integer, intent(in) :: dx2 real(kind=wp), intent(in), dimension(:) :: xcoords real(kind=wp), intent(out), dimension(:,:) :: Ie public subroutine linsolve (n, a, nrhs, b, x, LU, P, toggle) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=wp), intent(in), dimension(n, n) :: a integer, intent(in) :: nrhs real(kind=wp), intent(in), dimension(n, nrhs) :: b real(kind=wp), intent(out), dimension(n, nrhs) :: x real(kind=wp), intent(inout), dimension(n, n) :: LU integer, intent(inout), dimension(n) :: P logical, intent(in) :: toggle public subroutine linsolve_quick (n, a, nrhs, b, x) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=wp), intent(in), dimension(n, n) :: a integer, intent(in) :: nrhs real(kind=wp), intent(in), dimension(n, nrhs) :: b real(kind=wp), intent(out), dimension(n, nrhs) :: x private subroutine vandermonde (n, Vinv) Arguments Type Intent Optional Attributes Name integer :: n real(kind=wp), dimension(n, n) :: Vinv","tags":""},{"title":"misc – learn_dg","loc":"module/misc.html","text":"Uses: iso_fortran_env module~~misc~~UsesGraph module~misc misc iso_fortran_env iso_fortran_env iso_fortran_env->module~misc Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used By module~~misc~~UsedByGraph module~misc misc module~legendre legendre module~misc->module~legendre program~main main module~misc->program~main module~legendre->program~main Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Abstract Interfaces func1 func2 Subroutines r8mat_print r8mat_print_some Abstract Interfaces abstract interface public pure function func1 (xx) result(yy) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: xx Return Value real(kind=wp),\n  dimension(:), allocatable abstract interface public pure function func2 (xx, aa) result(yy) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: xx real(kind=wp), intent(in), dimension(:) :: aa Return Value real(kind=wp),\n  dimension(:), allocatable Subroutines public subroutine r8mat_print (m, n, a, title) * * * * * * * * * * * *80 Arguments Type Intent Optional Attributes Name integer(kind=4) :: m integer(kind=4) :: n real(kind=8) :: a (m,n) character(len=*) :: title public subroutine r8mat_print_some (m, n, a, ilo, jlo, ihi, jhi, title) * * * * * * * * * * * *80 Arguments Type Intent Optional Attributes Name integer(kind=4) :: m integer(kind=4) :: n real(kind=8) :: a (m,n) integer(kind=4) :: ilo integer(kind=4) :: jlo integer(kind=4) :: ihi integer(kind=4) :: jhi character(len=*) :: title","tags":""},{"title":"main – learn_dg","loc":"program/main.html","text":"Uses: iso_fortran_env legendre misc io program~~main~~UsesGraph program~main main module~legendre legendre module~legendre->program~main module~io io module~io->program~main module~misc misc module~misc->program~main module~misc->module~legendre iso_fortran_env iso_fortran_env iso_fortran_env->program~main iso_fortran_env->module~legendre iso_fortran_env->module~io iso_fortran_env->module~misc module~integration integration iso_fortran_env->module~integration module~integration->module~legendre lib_array lib_array lib_array->module~legendre lib_array->module~integration Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Calls program~~main~~CallsGraph program~main main dexp dexp program~main->dexp getie getie program~main->getie proc~linsolve_quick linsolve_quick program~main->proc~linsolve_quick proc~get_command_argument_wrapper get_command_argument_wrapper program~main->proc~get_command_argument_wrapper proc~r8mat_print r8mat_print program~main->proc~r8mat_print read_gmsh_file_1d read_gmsh_file_1d program~main->read_gmsh_file_1d proc~linsolve linsolve proc~linsolve_quick->proc~linsolve proc~r8mat_print_some r8mat_print_some proc~r8mat_print->proc~r8mat_print_some dgetrf dgetrf proc~linsolve->dgetrf dgetrs dgetrs proc~linsolve->dgetrs Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Variables GlobalA GlobalB GlobalX IeN analytical arg diff elem_connN ii ios jj num_nodes orderN r vel xcoordsN Source Code main Variables Type Attributes Name Initial real(kind=wp), dimension(:,:), allocatable :: GlobalA real(kind=wp), dimension(:), allocatable :: GlobalB real(kind=wp), dimension(:), allocatable :: GlobalX real(kind=wp), dimension(:,:), allocatable :: IeN real(kind=wp), dimension(:), allocatable :: analytical character(len=50) :: arg real(kind=wp) :: diff = 0.5_wp integer, dimension(:,:), allocatable :: elem_connN integer :: ii integer :: ios integer :: jj integer :: num_nodes integer, dimension(:), allocatable :: orderN real(kind=wp) :: r real(kind=wp) :: vel = -1.0_wp real(kind=wp), dimension(:), allocatable :: xcoordsN Source Code program main use iso_fortran_env , only : wp => real64 use legendre , only : getIe , linsolve_quick use misc , only : r8mat_print use io , only : get_command_argument_wrapper , read_gmsh_file_1D implicit none integer :: ii , jj , num_nodes , ios real ( wp ) :: vel = - 1.0_wp , diff = 0.5_wp real ( wp ) :: r ! integer :: order = 4 ! real(wp), dimension(:),   allocatable :: xcoords ! real(wp), dimension(:,:), allocatable :: Ie integer , dimension (:), allocatable :: orderN integer , dimension (:,:), allocatable :: elem_connN real ( wp ), dimension (:), allocatable :: xcoordsN , GlobalB , GlobalX real ( wp ), dimension (:), allocatable :: analytical real ( wp ), dimension (:,:), allocatable :: IeN , GlobalA character ( len = 50 ) :: arg ! allocate(xcoords(order+1)) ! allocate(Ie(order+1, order+1)) ! xcoords = [0.0_wp, 1.2_wp, 1.9_wp, 2.5_wp, 3.0_wp] ! ! do ii = 1, order+1 !   Ie(ii, :) = [( integrate_basis_1d_Ie(order, ii, jj, 1, 1, xcoords), jj = 1, order+1 )] ! end do ! ! call getIe(1, 1, xcoords, Ie) ! call r8mat_print(order+1, order+1, Ie, 'Elemental Stiffness matrix:') ! ! deallocate(xcoords, Ie) call get_command_argument_wrapper ( arg ) call read_gmsh_file_1D ( arg , num_nodes , orderN , elem_connN , xcoordsN ) ! write(*,*) orderN(1), elem_connN(1,:), xcoordsN(elem_connN(1,:)) allocate ( GlobalA ( num_nodes , num_nodes )) allocate ( GlobalB ( num_nodes )) allocate ( GlobalX ( num_nodes )) allocate ( analytical ( num_nodes )) GlobalA (:,:) = 0.0_wp GlobalB (:) = 0.0_wp GlobalB ( 1 ) = 0.0_wp GlobalB ( 2 ) = 1.0_wp GlobalX (:) = 0.0_wp call r8mat_print ( num_nodes , 1 , GlobalB , 'Global RHS:' ) ! Add elemental stiffness matrices to Global Stiffness Matrix do ii = 1 , size ( orderN ) ! Reallocate elemental stiffness matrix allocate ( IeN ( orderN ( ii ) + 1 , orderN ( ii ) + 1 )) call getIe ( 1 , 1 , xcoordsN ( elem_connN ( ii ,:)), IeN ) ! call r8mat_print(orderN(ii)+1, orderN(ii)+1, IeN, 'Elemental Stiffness Matrix:') GlobalA ( elem_connN ( ii ,:), elem_connN ( ii ,:)) = & GlobalA ( elem_connN ( ii ,:), elem_connN ( ii ,:)) - diff * IeN ! deallocate(IeN) ! allocate(IeN(orderN(ii)+1, orderN(ii)+1)) call getIe ( 0 , 1 , xcoordsN ( elem_connN ( ii ,:)), IeN ) ! call r8mat_print(orderN(ii)+1, orderN(ii)+1, IeN, 'Elemental Stiffness Matrix:') GlobalA ( elem_connN ( ii ,:), elem_connN ( ii ,:)) = & GlobalA ( elem_connN ( ii ,:), elem_connN ( ii ,:)) - vel * IeN ! Deallocate elemental stiffness matrix after every loop deallocate ( IeN ) ! stop end do ! call r8mat_print(num_nodes, num_nodes, GlobalA, 'Global Stiffness Matrix:') GlobalA ( 1 ,:) = 0.0_wp GlobalA ( 1 , 1 ) = 1.0_wp GlobalA ( 2 ,:) = 0.0_wp GlobalA ( 2 , 2 ) = 1.0_wp ! call r8mat_print(num_nodes, num_nodes, GlobalA, 'Global Stiffness matrix:') call linsolve_quick ( num_nodes , GlobalA , 1 , GlobalB , GlobalX ) ! call r8mat_print(num_nodes, 1, GlobalB, 'Global RHS:') call r8mat_print ( num_nodes , 1 , GlobalX , 'Global Solution Vector:' ) open ( unit = 21 , file = 'data.out' , iostat = ios , status = \"replace\" , action = \"write\" ) if ( ios /= 0 ) stop \"Error opening file 21\" r = vel / diff ! do ii = 1, num_nodes !   write(*,*) (1.0_wp-exp(xcoordsN(ii))) / (1.0_wp - exp(1.0_wp)) ! end do ! stop analytical = ( 1.0_wp - dexp ( r * xcoordsN )) / ( 1.0_wp - dexp ( r ) ) do ii = 1 , num_nodes write ( 21 , * ) xcoordsN ( ii ), GlobalX ( ii ), analytical ( ii ) end do write ( * , * ) write ( * , * ) norm2 ([ GlobalX - analytical ]) close ( unit = 21 , iostat = ios ) if ( ios /= 0 ) stop \"Error closing file unit 21\" if ( allocated ( orderN ) ) deallocate ( orderN ) if ( allocated ( elem_connN ) ) deallocate ( elem_connN ) if ( allocated ( xcoordsN ) ) deallocate ( xcoordsN ) if ( allocated ( GlobalA ) ) deallocate ( GlobalA ) if ( allocated ( GlobalB ) ) deallocate ( GlobalB ) if ( allocated ( GlobalX ) ) deallocate ( GlobalX ) if ( allocated ( analytical ) ) deallocate ( analytical ) end program main","tags":""}]}